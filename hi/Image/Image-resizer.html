<!DOCTYPE html>
<html lang="hi-IN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title id="page-title">मुफ्त ऑनलाइन इमेज रेसाइज़र | CaliperTools</title>
    <meta name="description" id="page-description" content="इमेज को ऑनलाइन मुफ्त में रेसाइज़ करें। क्रॉप, रोटेट, स्केल और इमेज समायोजित करें। कई प्रारूप, सोशल प्रीसेट। कोई पंजीकरण की आवश्यकता नहीं। सर्वोत्तम गुणवत्ता।">
    <link rel="icon" type="image/png" sizes="32x32" href="../../images/favicon32.png">
    <link rel="stylesheet" href="../../styles.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <script src="../scripts/script.js"></script>
    <script src="../scripts/script-related-tools.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
    <style>
/* Basic Style Reset */
* {
    margin: 0;
    padding: 0;
    box-sizing: border-box;
}

/* Tutorial and Introduction Section Styles */
.tutorial-section {
    background: linear-gradient(to right, #3b82f6, #8b5cf6);
    color: white;
    padding: 5rem 0;
    margin-top: 5rem;
}

.container {
    max-width: 1400px;
    margin: 0 auto;
    padding: 0 1.5rem;
}

.text-4xl {
    font-size: 2.5rem;
    font-weight: bold;
    text-align: center;
    margin-bottom: 4rem;
}

.grid {
    display: grid;
    gap: 2rem;
}

.grid-cols-1 {
    grid-template-columns: 1fr;
}

@media (min-width: 640px) {
    .sm\:grid-cols-2 {
        grid-template-columns: repeat(2, 1fr);
    }
}

@media (min-width: 1024px) {
    .lg\:grid-cols-4 {
        grid-template-columns: repeat(4, 1fr);
    }
}

.tutorial-card {
    background: white;
    color: #1f2937;
    border-radius: 0.75rem;
    padding: 2rem;
    box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1);
    transition: all 0.3s ease;
}

.tutorial-card:hover {
    transform: scale(1.05);
    box-shadow: 0 20px 25px -5px rgba(0, 0, 0, 0.1);
}

.tutorial-card h3 {
    font-size: 1.5rem;
    font-weight: bold;
    display: flex;
    align-items: center;
    margin-bottom: 1rem;
}

.tutorial-icon {
    background: #3b82f6;
    color: white;
    width: 2.5rem;
    height: 2.5rem;
    border-radius: 50%;
    display: flex;
    align-items: center;
    justify-content: center;
    margin-right: 1rem;
    font-size: 1.25rem;
}

.tutorial-card p {
    color: #6b7280;
    line-height: 1.5;
    overflow: hidden;
    display: -webkit-box;
    -webkit-line-clamp: 3;
    -webkit-box-orient: vertical;
    cursor: help;
    font-size: 0.875rem;
}

/* Feature Section Styles */
.feature-section {
    padding: 5rem 0;
    background: white;
}

.feature-section.gray {
    background: #f9fafb;
}

.grid-cols-2 {
    display: grid;
    grid-template-columns: 1fr;
    gap: 4rem;
    align-items: center;
}

@media (min-width: 768px) {
    .grid-cols-2 {
        grid-template-columns: repeat(2, 1fr);
    }
}

.content-image img {
    border-radius: 0.75rem;
    box-shadow: 0 20px 25px -5px rgba(0, 0, 0, 0.1);
    width: 100%;
}

.content-text h2 {
    font-size: 2.25rem;
    font-weight: bold;
    color: #111827;
    margin-bottom: 1.5rem;
}

.content-text p {
    font-size: 1.125rem;
    color: #6b7280;
    margin-bottom: 1.5rem;
    line-height: 1.75;
}

/* Order Classes */
.order-2 {
    order: 2;
}

.order-1 {
    order: 1;
}

@media (min-width: 768px) {
    .md\:order-1 {
        order: 1;
    }
    .md\:order-2 {
        order: 2;
    }
}

/* Bottom Text Area */
.bottom-text-section {
    padding: 5rem 0;
    background: linear-gradient(to bottom, #f9fafb, white);
}

.bottom-text-section h2 {
    font-size: 2.25rem;
    font-weight: bold;
    color: #111827;
    margin-bottom: 1.5rem;
}

.bottom-text-section p {
    font-size: 1.125rem;
    color: #6b7280;
    margin-bottom: 1.5rem;
    line-height: 1.75;
}

.mb-10 {
    margin-bottom: 2.5rem;
}

/* Related Tools Section */
.related-tools {
    padding: 4rem 0;
    background: white;
}

.section-title {
    font-size: 2.25rem;
    font-weight: bold;
    color: #111827;
    margin-bottom: 3rem;
    text-align: center;
}

body {
    font-family: Arial, sans-serif;
    background-color: #f4f4f4;
}

/* Container Styles */
.image-resizer-container {
    display: flex;
    width: 100%;
    max-width: 1400px;
    margin: 40px auto 0;
    background-color: #fff;
    height: 850px;
}

/* Responsive Design */
@media (max-width: 768px) {
    .image-resizer-container {
        flex-direction: column;
        height: auto;
    }

    .sidebar-container {
        width: 100%;
        border-right: none;
        border-bottom: 1px solid #ddd;
    }

    .sidebar {
        height: auto;
        max-height: 500px;
    }

    .gallery {
        height: auto;
        max-height: 500px;
    }

    .export-area {
        width: 100%;
        float: none;
    }
}

@media (max-width: 480px) {
    .resize-tabs {
        flex-direction: column;
    }

    .tab {
        margin-right: 0;
        margin-bottom: 5px;
    }

    .dimension-group, .percentage-group {
        flex-direction: column;
    }

    .dimension-group input, .dimension-group select, .percentage-group select {
        width: 100%;
        margin-bottom: 5px;
    }
}

/* Left Menu - Scrolling Function */
.sidebar-container {
    width: 380px;
    border-right: 1px solid #ddd;
}

.sidebar {
    padding: 20px;
    padding-bottom: 150px;
    background-color: #ffffff;
    height: 750px;
    overflow-y: auto;
    overflow-x: hidden;
    display: flex;
    flex-direction: column;
}

.sidebar::-webkit-scrollbar {
    width: 6px;
}

.sidebar::-webkit-scrollbar-track {
    background: #f1f1f1;
}

.sidebar::-webkit-scrollbar-thumb {
    background: #bbb;
    border-radius: 3px;
}

.sidebar::-webkit-scrollbar-thumb:hover {
    background: #999;
}

.upload-section {
    margin-bottom: 20px;
    display: flex;
    justify-content: space-between;
    align-items: center;
}

.upload-btn {
    background-color: #007bff;
    color: #fff;
    border: none;
    padding: 10px 20px;
    font-size: 20px;
    cursor: pointer;
    transition: background-color 0.3s ease;
}

.upload-btn:hover {
    background-color: #0056b3;
}

.delete-btn {
    background: none;
    border: none;
    color: #dc3545;
    font-size: 20px;
    cursor: pointer;
    transition: color 0.3s ease;
}

.delete-btn:hover {
    color: #b21f2d;
}

.file-input {
    display: none;
}

.resize-settings, .export-settings {
    margin-bottom: 20px;
}

.resize-settings {
    margin-top: 30px;
}

h2 {
    font-size: 18px;
    margin-bottom: 15px;
    color: #0F172A;
}

/* Optimized Tab Styles */
.resize-tabs {
    display: flex;
    margin-bottom: 15px;
    width: 100%;
}

.tab {
    background-color: #eee;
    border: none;
    padding: 12px 0;
    flex: 1;
    margin-right: 5px;
    cursor: pointer;
    font-size: 16px;
    transition: all 0.3s ease;
}

.tab:last-child {
    margin-right: 0;
}

.tab.active {
    background-color: #007bff;
    color: #fff;
}

.tab:hover:not(.active) {
    background-color: #ddd;
}

.tab-content {
    display: none;
    padding: 10px;
}

.tab-content.active {
    display: block;
}

.input-group {
    margin-bottom: 10px;
    display: flex;
    flex-direction: column;
}

.input-row {
    display: flex;
    align-items: center;
    gap: 10px;
}

/* Fix Target File Size Input Box Proportion */
.input-row #file-size {
    flex: 3; /* Input box longer */
}

.input-row #size-unit {
    flex: 1; /* Unit box shorter */
    width: auto;
}

.full-width-input select {
    width: 100%;
    box-sizing: border-box;
}

.dimension-group {
    display: flex;
    align-items: center;
    gap: 10px;
    margin-bottom: 15px;
    width: 100%;
}

.percentage-group {
    display: flex;
    align-items: center;
    gap: 10px;
    margin-bottom: 15px;
    width: 100%;
}

/* Percentage Slider Container */
.percentage-slider-container {
    display: flex;
    align-items: center;
    gap: 10px;
    margin-bottom: 15px;
    width: 100%;
}

.percentage-slider {
    flex: 1;
    height: 8px;
    -webkit-appearance: none;
    appearance: none;
    background: #ddd;
    outline: none;
    border-radius: 4px;
}

.percentage-slider::-webkit-slider-thumb {
    -webkit-appearance: none;
    appearance: none;
    width: 20px;
    height: 20px;
    border-radius: 50%;
    background: #007bff;
    cursor: pointer;
}

/* Percentage Input Box and Unit Container */
.percentage-input-container {
    display: flex;
    justify-content: space-between;
    align-items: center;
    gap: 10px;
    margin-bottom: 15px;
}

.percentage-input {
    flex: 2;
    padding: 12px 8px;
    border: 1px solid #ddd;
    box-sizing: border-box;
    height: 44px;
    font-size: 16px;
}

.percentage-unit-select {
    flex: 1;
    padding: 12px 8px;
    border: 1px solid #ddd;
    box-sizing: border-box;
    height: 44px;
    font-size: 16px;
}

.percentage-value {
    min-width: 50px;
    text-align: right;
}

.dimension-group input, 
.dimension-group select,
.percentage-group select {
    padding: 12px 8px;
    border: 1px solid #ddd;
    box-sizing: border-box;
    height: 44px;
    font-size: 16px;
}

.dimension-group input {
    flex: 2;
    min-width: 0;
}

.dimension-group select,
.percentage-group select {
    flex: 1;
    min-width: 80px;
}

.dimension-group span {
    margin: 0 5px;
}

.input-group label {
    display: block;
    margin-bottom: 5px;
    text-align: left;
    font-weight: bold;
}

.input-group input, .input-group select {
    padding: 12px 8px;
    border: 1px solid #ddd;
    width: 100%;
    height: 44px;
    font-size: 16px;
}

.checkbox-group {
    display: flex;
    align-items: center;
    margin-bottom: 15px;
}

.checkbox-group input {
    margin-right: 5px;
    width: auto;
}

.resolution-options {
    margin-top: 10px;
    margin-bottom: 15px;
}

.background-options {
    margin-top: 10px;
    margin-bottom: 15px;
    display: none;
}

.color-input-group {
    display: flex;
    align-items: center;
    gap: 10px;
    margin-bottom: 10px;
}

.color-input-group input[type="checkbox"] {
    width: auto;
}

.color-input-group label {
    flex: 1;
    margin-bottom: 0;
}

.color-input-group input[type="color"] {
    width: 40px;
    height: 30px;
    padding: 0;
    border: 1px solid #ddd;
}

.color-input-group input[type="text"] {
    width: 80px;
}

.help-tooltip {
    position: relative;
    display: inline-block;
    cursor: help;
    font-size: 16px;
}

.help-tooltip .tooltip-text {
    visibility: hidden;
    width: 120px;
    background-color: #555;
    color: #fff;
    text-align: center;
    border-radius: 6px;
    padding: 5px;
    position: absolute;
    z-index: 1;
    bottom: 125%;
    left: 24%;
    margin-left: -60px;
    opacity: 0;
    transition: opacity 0.3s;
    font-size: 12px;
}

.help-tooltip:hover .tooltip-text {
    visibility: visible;
    opacity: 1;
}

/* New Area Below Left Menu Function Zone - Export Area */
.export-area {
    width: 333px;
    background-color: #f9f9f9;
    border-radius: 4px;
    box-shadow: 0 2px 10px rgba(0,0,0,0.05);
    border: 1px solid #ddd;
    margin-top: 20px;
    clear: both;
    display: block;
    float: left;
    margin-left: 20px;
}

.export-actions {
    display: flex;
    gap: 10px;
    width: 100%;
    box-sizing: border-box;
}

/* Export and ZIP Button Style Optimization */
.export-btn, .zip-btn {
    font-size: 18px;
    padding: 15px 20px;
    height: auto;
    font-weight: bold;
    transition: all 0.2s ease;
    white-space: nowrap;
    min-width: 0;
    flex: 1;
    display: flex;
    align-items: center;
    justify-content: center;
    gap: 5px;
}

.export-btn {
    background-color: #007bff;
    color: #fff;
    border: none;
    cursor: pointer;
    flex: 1;
}

.zip-btn {
    background-color: #28a745;
    color: #fff;
    border: none;
    cursor: pointer;
    flex: 1;
}

.export-btn:hover, .zip-btn:hover {
    transform: translateY(-2px);
    box-shadow: 0 4px 8px rgba(0,0,0,0.1);
}

/* Right Side Image Browser Window */
.gallery {
    flex: 1;
    padding: 20px;
    overflow-y: auto;
    height: 850px;
    display: flex;
    flex-direction: column;
}

.upload-prompt {
    flex: 1;
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    text-align: center;
    padding: 20px;
    border: 2px dashed #ccc;
    border-radius: 8px;
    margin: 20px;
    transition: all 0.3s ease;
    cursor: pointer;
}

.upload-prompt:hover {
    border-color: #007bff;
    background-color: rgba(0, 123, 255, 0.05);
}

.upload-prompt.drag-over {
    border-color: #007bff;
    background-color: rgba(0, 123, 255, 0.1);
}

.upload-prompt-icon {
    font-size: 60px;
    color: #007bff;
    margin-bottom: 20px;
}

.upload-prompt-title {
    font-size: 24px;
    font-weight: bold;
    margin-bottom: 15px;
    color: #0F172A;
}

.upload-prompt-instruction {
    font-size: 16px;
    margin-bottom: 20px;
    color: #666;
}

.supported-formats {
    display: flex;
    flex-wrap: wrap;
    justify-content: center;
    gap: 10px;
    margin-bottom: 15px;
    font-size: 14px;
    max-width: 450px;
}

.format-item {
    color: #555;
}

.more-formats {
    display: flex;
    align-items: center;
    gap: 5px;
    color: #007bff;
    cursor: pointer;
    margin-bottom: 20px;
    font-size: 14px;
}

.formats-tooltip {
    position: relative;
    display: inline-block;
}

.formats-tooltip .tooltip-text {
    visibility: hidden;
    width: 300px;
    background-color: #555;
    color: #fff;
    text-align: center;
    border-radius: 6px;
    padding: 10px;
    position: absolute;
    z-index: 100;
    bottom: 125%;
    left: 50%;
    margin-left: -150px;
    opacity: 0;
    transition: opacity 0.3s;
    font-size: 12px;
    text-align: left;
    line-height: 1.5;
}

.formats-tooltip:hover .tooltip-text {
    visibility: visible;
    opacity: 1;
}

.recommendation {
    font-size: 14px;
    color: #666;
    margin-bottom: 8px;
}

.image-container {
    display: flex;
    flex-wrap: wrap;
    gap: 20px;
    margin-top: 20px;
}

.image-item {
    width: calc(25% - 15px);
    height: 300px;
    margin-bottom: 20px;
    border: 1px solid #ddd;
    padding: 10px;
    position: relative;
    display: flex;
    flex-direction: column;
    transition: box-shadow 0.3s ease;
}

.image-item:hover {
    box-shadow: 0 4px 8px rgba(0,0,0,0.1);
}

.image-preview-container {
    flex: 1;
    height: 220px;
    width: 100%;
    display: flex;
    align-items: center;
    justify-content: center;
    overflow: hidden;
    background-color: #f9f9f9;
    margin-bottom: 10px;
    position: relative;
}

.image-item img {
    max-width: 100% !important;
    max-height: 100% !important;
    width: auto !important;
    height: auto !important;
    object-fit: contain !important;
    display: block !important;
    transform: none !important;
    transition: none !important;
}

.image-actions {
    position: absolute;
    top: 10px;
    right: 10px;
    display: flex;
    gap: 5px;
}

.image-action-btn {
    width: 28px;
    height: 28px;
    border-radius: 50%;
    background-color: rgba(255, 255, 255, 0.8);
    border: none;
    display: flex;
    align-items: center;
    justify-content: center;
    cursor: pointer;
    font-size: 14px;
    color: #0F172A;
    transition: all 0.2s ease;
    position: relative;
}

.image-action-btn:hover {
    background-color: white;
    transform: scale(1.1);
}

.image-action-btn .tooltip {
    visibility: hidden;
    width: auto;
    background-color: #555;
    color: #fff;
    text-align: center;
    border-radius: 6px;
    padding: 5px 10px;
    position: absolute;
    z-index: 1;
    bottom: 125%;
    left: 50%;
    transform: translateX(-50%);
    opacity: 0;
    transition: opacity 0.3s;
    font-size: 12px;
    white-space: nowrap;
}

.image-action-btn:hover .tooltip {
    visibility: visible;
    opacity: 1;
}

.crop-btn:hover {
    color: #28a745;
}

.rotate-btn:hover {
    color: #007bff;
}

.info-btn:hover {
    color: #ffc107;
}

.delete-img-btn:hover {
    color: #dc3545;
}

.image-info {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: 5px;
    font-size: 13px;
}

.image-meta {
    font-size: 12px;
    color: #666;
}

/* Modal Box Styles */
.modal {
    display: none;
    position: fixed;
    z-index: 1000;
    left: 0;
    top: 0;
    width: 100%;
    height: 100%;
    overflow: auto;
    background-color: rgba(0, 0, 0, 0.4);
    opacity: 0;
    transition: opacity 0.3s ease;
}

.modal.show {
    display: block;
    opacity: 1;
}

.modal-content {
    background-color: #fefefe;
    margin: 15% auto;
    padding: 20px;
    border: 1px solid #888;
    width: 300px;
    text-align: center;
    border-radius: 5px;
    transform: translateY(-20px);
    transition: transform 0.3s ease;
}

/* Crop Modal Box Styles */
.crop-modal-content {
    width: 900px;
    height: 740px;
    margin: 50px auto;
    max-width: none;
    padding: 0;
    display: flex;
    flex-direction: column;
    border-radius: 8px;
    overflow: hidden;
    box-shadow: 0 5px 15px rgba(0,0,0,0.3);
    transform: none;
    transition: none;
}

/* Vertical Layout Group */
.vertical-group {
    margin-bottom: 15px;
}

/* Full Width Input Box */
.full-width-input {
    width: 100%;
}

/* Half Width Input Box */
.half-width {
    flex: 1;
}

/* Input Row */
.input-row {
    display: flex;
    gap: 10px;
    margin-bottom: 15px;
}

.crop-modal-content .modal-header {
    height: 66px;
    width: 100%;
    background-color: #f5f5f5;
    padding: 0 20px;
    display: flex;
    align-items: center;
    justify-content: space-between;
    border-bottom: 1px solid #ddd;
}

.crop-modal-content h2 {
    margin: 0;
    font-size: 20px;
    font-weight: 600;
}

.modal-navigation {
    display: flex;
    gap: 10px;
}

.nav-btn {
    border: none;
    width: 30px;
    height: 30px;
    border-radius: 4px;
    cursor: pointer;
    display: flex;
    align-items: center;
    justify-content: center;
}

.crop-body {
    display: flex;
    height: calc(100% - 66px);
}

.crop-modal-body {
    display: flex;
    flex: 1;
    padding: 15px;
    gap: 20px;
    overflow: hidden;
    height: 100%;
}

.crop-preview-container {
    width: 570px;
    height: 640px;
    padding: 15px;
    background-color: #f9f9f9;
    border-radius: 8px;
    display: flex;
    align-items: center;
    justify-content: center;
}

.crop-image-container {
    width: 540px;
    height: 610px;
    position: relative;
    overflow: hidden;
    background-color: white;
    border: 1px solid #e0e0e0;
}

#cropImage {
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
}

.crop-selection {
    position: absolute;
    border: 1px dashed #0F172A;
    background-color: rgba(50, 150, 255, 0.2);
    cursor: move;
    box-sizing: border-box;
    pointer-events: none; /* Disable mouse events for the entire crop box, let child elements handle */
}

.crop-grid {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background-image: linear-gradient(to right, transparent 33%, rgba(0,0,0,0.1) 33%, rgba(0,0,0,0.1) 34%, transparent 34%, transparent 66%, rgba(0,0,0,0.1) 66%, rgba(0,0,0,0.1) 67%, transparent 67%),
                      linear-gradient(to bottom, transparent 33%, rgba(0,0,0,0.1) 33%, rgba(0,0,0,0.1) 34%, transparent 34%, transparent 66%, rgba(0,0,0,0.1) 66%, rgba(0,0,0,0.1) 67%, transparent 67%);
    pointer-events: auto; /* Ensure grid can receive mouse events for dragging */
}
        
/* Ensure control point cursor has higher priority */
.crop-handle {
    position: absolute;
    width: 20px;
    height: 20px;
    background-color: white;
    border: 1px solid #0F172A;
    border-radius: 4px;
    z-index: 20;
    cursor: pointer; /* Default pointer */
    pointer-events: auto; /* Ensure control points can receive mouse events */
}

.crop-selection-top {
    position: absolute;
    top: -5px;
    left: 15px; /* Leave space for top-left corner point */
    right: 15px; /* Leave space for top-right corner point */
    height: 10px;
    cursor: ns-resize;
    z-index: 10;
    pointer-events: auto; /* Enable mouse events for top border */
}

.crop-selection-bottom {
    position: absolute;
    bottom: -5px;
    left: 15px; /* Leave space for bottom-left corner point */
    right: 15px; /* Leave space for bottom-right corner point */
    height: 10px;
    cursor: ns-resize;
    z-index: 10;
    pointer-events: auto; /* Enable mouse events for bottom border */
}

.crop-selection-left {
    position: absolute;
    left: -5px;
    top: 15px; /* Leave space for top-left corner point */
    bottom: 15px; /* Leave space for bottom-left corner point */
    width: 10px;
    cursor: ew-resize;
    z-index: 10;
    pointer-events: auto; /* Enable mouse events for left border */
}

.crop-selection-right {
    position: absolute;
    right: -5px;
    top: 15px; /* Leave space for top-right corner point */
    bottom: 15px; /* Leave space for bottom-right corner point */
    width: 10px;
    cursor: ew-resize;
    z-index: 10;
    pointer-events: auto; /* Enable mouse events for right border */
}

.crop-handle {
    position: absolute;
    width: 20px;
    height: 20px;
    background-color: white;
    border: 1px solid #0F172A;
    border-radius: 4px;
    z-index: 20;
    cursor: pointer; /* Default pointer */
}

.crop-handle.top-left {
    top: -10px;
    left: -10px;
    cursor: nwse-resize !important;
    z-index: 35; /* Corner points have higher z-index */
}

.crop-handle.top-middle {
    top: -10px;
    left: 50%;
    transform: translateX(-50%);
    cursor: ns-resize !important;
    z-index: 32; /* Edge midpoints have slightly lower z-index */
}

.crop-handle.top-right {
    top: -10px;
    right: -10px;
    cursor: nesw-resize !important;
    z-index: 35; /* Corner points have higher z-index */
}

.crop-handle.middle-left {
    top: 50%;
    left: -10px;
    transform: translateY(-50%);
    cursor: ew-resize !important;
    z-index: 32; /* Edge midpoints have slightly lower z-index */
}

.crop-handle.middle-right {
    top: 50%;
    right: -10px;
    transform: translateY(-50%);
    cursor: ew-resize !important;
    z-index: 32; /* Edge midpoints have slightly lower z-index */
}

.crop-handle.bottom-left {
    bottom: -10px;
    left: -10px;
    cursor: nesw-resize !important;
    z-index: 35; /* Corner points have higher z-index */
}

.crop-handle.bottom-middle {
    bottom: -10px;
    left: 50%;
    transform: translateX(-50%);
    cursor: ns-resize !important;
    z-index: 32; /* Edge midpoints have slightly lower z-index */
}

.crop-handle.bottom-right {
    bottom: -10px;
    right: -10px;
    cursor: nwse-resize !important;
    z-index: 35; /* Corner points have higher z-index */
}

.crop-grid {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background-image: linear-gradient(to right, transparent 33%, rgba(0,0,0,0.1) 33%, rgba(0,0,0,0.1) 34%, transparent 34%, transparent 66%, rgba(0,0,0,0.1) 66%, rgba(0,0,0,0.1) 67%, transparent 67%),
                      linear-gradient(to bottom, transparent 33%, rgba(0,0,0,0.1) 33%, rgba(0,0,0,0.1) 34%, transparent 34%, transparent 66%, rgba(0,0,0,0.1) 66%, rgba(0,0,0,0.1) 67%, transparent 67%);
}

.crop-controls {
    flex: 1;
    min-width: 250px;
    display: flex;
    flex-direction: column;
}

.crop-controls h3 {
    margin: 15px 0 20px;
    font-size: 20px;
    font-weight: 600;
    text-align: left;
}

.input-group, .aspect-ratio-group, .position-group {
    margin-bottom: 15px;
}

.crop-controls label {
    display: block;
    margin-bottom: 5px;
    font-size: 14px;
    color: #555;
    text-align: left;
}

.crop-input, .crop-select {
    width: 100%;
    padding: 8px 10px;
    border: 1px solid #ddd;
    border-radius: 4px;
    font-size: 14px;
    margin-bottom: 8px;
}

.input-group, .position-group {
    display: flex;
    gap: 10px;
}

.input-group .crop-input, .position-group .crop-input {
    flex: 1;
}

.custom-ratio-group {
    display: flex;
    gap: 10px;
    margin-bottom: 15px;
    display: none;
}

.small-input {
    flex: 1;
}

.crop-actions {
    margin-top: auto;
    display: flex;
    justify-content: flex-end;
    gap: 10px;
    padding-top: 20px;
}

.modal.show .modal-content {
    transform: translateY(0);
}

.modal-buttons {
    display: flex;
    justify-content: center;
    gap: 10px;
    margin-top: 20px;
}

.modal-btn {
    padding: 8px 16px;
    cursor: pointer;
    border: none;
    border-radius: 4px;
    transition: background-color 0.3s ease;
}

.cancel-btn {
    background-color: #6c757d;
    color: white;
}

.cancel-btn:hover {
    background-color: #5a6268;
}

.confirm-btn {
    background-color: #dc3545;
    color: white;
}

.confirm-btn:hover {
    background-color: #c82333;
}

/* Social Media Related Styles */
.social-select-fullwidth {
    width: 100%;
    padding: 12px 8px;
    border: 1px solid #ddd;
    box-sizing: border-box;
    margin-bottom: 15px;
    height: 44px;
    font-size: 16px;
}

/* Rotate and Flip Modal Box Styles */
#rotate-flip-modal {
    z-index: 2000;
}

.rotate-flip-modal-content {
    width: 900px;
    height: 740px;
    margin: 50px auto;
    padding: 0;
    border-radius: 8px;
    overflow: hidden;
    box-shadow: 0 5px 15px rgba(0,0,0,0.3);
}

/* Rotate and Flip Top */
.rotate-flip-header {
    height: 66px;
    width: 100%;
    background-color: #f5f5f5;
    padding: 0 20px;
    display: flex;
    align-items: center;
    justify-content: space-between;
    border-bottom: 1px solid #ddd;
}

.rotate-flip-header h2 {
    margin: 0;
    font-size: 20px;
    color: #0F172A;
}

.rotate-flip-navigation {
    display: flex;
    align-items: center;
    gap: 10px;
}

.close-rotate-flip {
    background: none;
    border: none;
    font-size: 24px;
    cursor: pointer;
    color: #495057;
    transition: color 0.2s ease;
}

.close-rotate-flip:hover {
    color: #dc3545;
}

.rotate-flip-body {
    display: flex;
    height: calc(100% - 66px);
}

.rotate-flip-preview-container {
    flex: 570;
    padding: 15px;
    background-color: #f9f9f9;
    display: flex;
    align-items: center;
    justify-content: center;
    position: relative;
}

.rotate-flip-preview {
    position: relative;
    max-width: 100%;
    max-height: 100%;
}

.rotate-flip-image {
    max-width: 100%;
    max-height: 570px;
    display: block;
    margin: 0 auto;
}

.rotate-flip-controls {
    flex: 330;
    padding: 20px;
    background-color: #fff;
    overflow-y: auto;
    display: flex;
    flex-direction: column;
}

.rotate-controls {
    display: flex;
    justify-content: space-between;
    margin-bottom: 30px;
}

.flip-controls {
    display: flex;
    justify-content: space-between;
    margin-bottom: 30px;
}

.rotate-btn-large, .flip-btn-large {
        width: 128px;
        height: 110px;
        background-color: #e9f5ff;
        border: 1px solid #007bff;
        border-radius: 8px;
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        cursor: pointer;
        transition: all 0.3s ease;
        box-shadow: 0 2px 4px rgba(0,0,0,0.05);
    }

    .rotate-btn-large:hover, .flip-btn-large:hover {
        background-color: #d1e7ff;
        border-color: #0056b3;
        transform: translateY(-2px);
        box-shadow: 0 4px 8px rgba(0,0,0,0.1);
    }

    .rotate-btn-large i, .flip-btn-large i {
        font-size: 40px;
        color: #007bff;
        margin-bottom: 8px;
    }

    .btn-name {
        font-size: 14px;
        font-weight: bold;
        color: #0F172A;
        text-align: center;
    }

.rotate-flip-actions {
    display: flex;
    justify-content: space-between;
    gap: 10px;
    padding: 10px;
    border-top: 1px solid #eee;
    background-color: #fff;
    margin-top: auto;
    width: 100%;
    box-sizing: border-box;
}

.apply-rotate-flip-btn, .reset-rotate-flip-btn {
    flex: 1;
    padding: 15px;
    border: none;
    border-radius: 4px;
    cursor: pointer;
    font-size: 18px;
    font-weight: bold;
    transition: all 0.3s ease;
}

.apply-rotate-flip-btn {
    background-color: #007bff;
    color: white;
    box-shadow: 0 2px 4px rgba(0,0,0,0.1);
}

.apply-rotate-flip-btn:hover {
    background-color: #0056b3;
    transform: translateY(-2px);
    box-shadow: 0 4px 8px rgba(0,0,0,0.15);
}

.reset-rotate-flip-btn {
    background-color: #6c757d;
    color: white;
    box-shadow: 0 2px 4px rgba(0,0,0,0.1);
}

.reset-rotate-flip-btn:hover {
    background-color: #5a6268;
    transform: translateY(-2px);
    box-shadow: 0 4px 8px rgba(0,0,0,0.15);
}

.nav-btn {
    border: none;
    width: 36px;
    height: 36px;
    border-radius: 4px;
    display: flex;
    align-items: center;
    justify-content: center;
    cursor: pointer;
    font-size: 16px;
    color: #495057;
    transition: all 0.2s ease;
}

.nav-btn:hover {
    background-color: #007bff;
    color: white;
}

.close-crop {
    background: none;
    border: none;
    font-size: 24px;
    cursor: pointer;
    color: #495057;
    transition: color 0.2s ease;
}

.close-crop:hover {
    color: #dc3545;
}

.crop-body {
    display: flex;
    height: calc(100% - 66px);
}

.crop-preview-container {
    width: 570px;
    height: 640px;
    padding: 0;
    background-color: #999;
    border: 15px solid #e7e6e6;
    display: flex;
    align-items: center;
    justify-content: center;
    position: relative;
    box-sizing: border-box;
}




/* Responsive Design */
@media (max-width: 1200px) {
    .image-item {
        width: calc(33.333% - 14px);
    }
}

@media (max-width: 992px) {
    .image-item {
        width: calc(50% - 10px);
    }
    
    .crop-modal-content {
        width: 90%;
        height: auto;
        max-height: 90vh;
    }
    
    .crop-body {
        flex-direction: column;
    }
    
    .crop-preview-container {
        flex: none;
        height: 400px;
    }
    
    .crop-controls {
        flex: none;
        max-height: 400px;
    }
}

@media (max-width: 768px) {
    .image-resizer-container {
        flex-direction: column;
    }

    .sidebar-container {
        width: 100%;
        border-right: none;
        border-bottom: 1px solid #ddd;
        order: 2;
    }

    .sidebar {
        height: auto;
        max-height: 70vh;
    }

    .gallery {
        width: 100%;
        order: 1;
        height: auto;
        max-height: 50vh;
    }

    .dimension-group, .percentage-group, .percentage-slider-container,
    .percentage-input-container {
        flex-direction: column;
        align-items: stretch;
    }
    
    .dimension-group input, .dimension-group select,
    .percentage-group input, .percentage-group select,
    .percentage-slider-container select,
    .percentage-input, .percentage-unit-select,
    .input-group input, .input-group select {
        width: 100%;
        box-sizing: border-box;
    }
    
    .dimension-group span, .percentage-value {
        display: none;
    }
}

@media (max-width: 480px) {
    .image-item {
        width: 100%;
    }
    
    .supported-formats {
        gap: 8px;
        font-size: 12px;
    }
}

.nav-btn:hover {
    background-color: #007bff !important;
    color: white !important;
}
</style>
<script>  
    document.addEventListener('contextmenu', function(e) {
        e.preventDefault();
        alert('राइट-क्लिक मेनू डिसेबल है।');
    });

    document.addEventListener('selectstart', function(e) {
        e.preventDefault();
    });

    document.addEventListener('keydown', function(e) {
        if ((e.ctrlKey || e.metaKey) && (e.key === 'c' || e.key === 'u' || e.key === 's' || e.key === 'a')) {
            e.preventDefault();
            alert('कॉपी फ़ंक्शन डिसेबल है।');
        }
    });

    document.addEventListener('keydown', function(e) {
        if (e.key === 'F12' || (e.ctrlKey && e.shiftKey && e.key === 'I')) {
            e.preventDefault();
            alert('डेवलपर टूल अक्षम हैं');
        }
    });
</script>
</head>
<body>
    <main class="main">
    <div id="tool-main-section" class="image-resizer-container">
        <!-- Left Menu Container -->
        <div class="sidebar-container">
            <div class="sidebar">
                <div class="upload-section">
                    <button id="upload-btn" class="upload-btn">+</button>
                    <input type="file" id="file-input" class="file-input" multiple accept="image/*">
                    <button id="delete-all-btn" class="delete-btn"><i class="fas fa-trash"></i></button>
                </div>
                <p>अधिकतम फ़ाइल आकार: 10 MB</p>

                <div class="resize-settings">
                    <h2>रेसाइज़ सेटिंग्स</h2>
                    <div class="resize-tabs">
                        <button class="tab active" data-tab="dimensions">आयामों से</button>
                        <button class="tab" data-tab="percentage">प्रतिशत</button>
                        <button class="tab" data-tab="social">सोशल मीडिया</button>
                    </div>

                    <!-- Resize by Dimensions -->
                    <div class="tab-content active" id="dimensions">
                        <label>चौड़ाई और ऊंचाई</label>
                        <div class="dimension-group">
                            <input type="number" id="width-dim" placeholder="Width">
                            <span>x</span>
                            <input type="number" id="height-dim" placeholder="Height">
                        </div>
                        
                        <div class="checkbox-group">
                            <input type="checkbox" id="lock-aspect-dim" checked>
                            <label for="lock-aspect-dim">आस्पेक्ट रेशियो लॉक करें</label>
                        </div>

                        <!-- Background Fill Options - Hidden by Default -->
                        <div id="background-options-dim" class="background-options">
                            <div class="color-input-group">
                                <input type="checkbox" id="use-background-dim">
                            <label for="use-background-dim">रंग चुनें</label>
                                <input type="text" id="color-code-dim" value="#FFFFFF" readonly>
                                <input type="color" id="color-picker-dim" value="#FFFFFF">
                            </div>
                            <div class="color-input-group">
                                <input type="checkbox" id="use-transparency-dim">
                            <label for="use-transparency-dim">पारदर्शी</label>
                            <span class="help-tooltip">❓
                                <span class="tooltip-text">केवल PNG इमेज के लिए लागू होता है</span>
                            </span>
                            </div>
                        </div>
                    </div>

                    <!-- Resize by Percentage -->
                    <div class="tab-content" id="percentage">
                        <div class="input-group">
                            <label>स्केल प्रतिशत</label>
                            <div class="percentage-slider-container">
                                <input type="range" id="percentage-slider" class="percentage-slider" min="10" max="300" value="100">
                                <span id="percentage-display" class="percentage-value">100%</span>
                            </div>
                            
                            <div class="percentage-input-container">
                                <input type="number" id="percentage-input" class="percentage-input" min="10" max="300" value="100" placeholder="Percentage">
                            </div>
                        </div>
                    </div>

                    <!-- Social Media Presets -->
                    <div class="tab-content" id="social">
                        <div class="input-group">
                            <label>सोशल मीडिया प्लेटफॉर्म</label>
                            <select id="social-platform" class="social-select-fullwidth">
                                <option value="">कृपया प्लेटफॉर्म चुनें</option>
                                <option value="facebook">Facebook</option>
                                <option value="instagram">Instagram</option>
                                <option value="twitter">Twitter</option>
                                <option value="youtube">YouTube</option>
                            </select>
                        </div>

                        <div class="input-group">
                            <label>प्रीसेट प्रकार</label>
                            <select id="social-preset" class="social-select-fullwidth">
                                <option value="">कृपया पहले प्लेटफॉर्म चुनें</option>
                            </select>
                        </div>

                        <label>Width & Height</label>
                        <div class="dimension-group">
                            <input type="number" id="width-social" placeholder="Width">
                            <span>x</span>
                            <input type="number" id="height-social" placeholder="Height">
                        </div>
                        
                        <div class="checkbox-group">
                            <input type="checkbox" id="lock-aspect-social" checked>
                            <label for="lock-aspect-social">आस्पेक्ट रेशियो लॉक करें</label>
                        </div>

                        <div id="background-options-social" class="background-options">
                            <div class="color-input-group">
                                <input type="checkbox" id="use-background-social">
                            <label for="use-background-social">रंग चुनें</label>
                                <input type="text" id="color-code-social" value="#FFFFFF" readonly>
                                <input type="color" id="color-picker-social" value="#FFFFFF">
                            </div>
                            <div class="color-input-group">
                                <input type="checkbox" id="use-transparency-social">
                            <label for="use-transparency-social">पारदर्शी</label>
                            <span class="help-tooltip">❓
                                <span class="tooltip-text">केवल PNG इमेज के लिए लागू होता है</span>
                            </span>
                            </div>
                        </div>
                    </div>
                </div>

                <div class="export-settings">
                    <h2>निर्यात सेटिंग्स</h2>
                    <div class="input-group">
                        <label for="file-size">लक्ष्य फ़ाइल आकार (वैकल्पिक)</label>
                        <div class="input-row">
                            <input type="number" id="file-size" placeholder="Enter Size">
                            <select id="size-unit">
                                <option value="KB">KB</option>
                                <option value="MB">MB</option>
                            </select>
                        </div>
                    </div>
                    

                    
                    <div class="input-group full-width-input">
                        <label for="save-as">आउटपुट प्रारूप</label>
                        <select id="save-as">
                            <option value="original">मूल</option>
                            <option value="jpg">JPG</option>
                            <option value="png">PNG</option>
                            <option value="webp">WEBP</option>
                        </select>
                    </div>
                </div>
            </div>

        <!-- New Area Below Left Menu Function Zone - Export Area -->
        <div class="export-area">
            <div class="export-actions">
                <button id="export-btn" class="export-btn"><i class="fas fa-download"></i> निर्यात करें</button>
                <button id="zip-btn" class="zip-btn"><i class="fas fa-file-archive"></i> ZIP संग्रह</button>
            </div>
    </div>
    </div>

    <!-- Crop Image Modal Box -->
    <div id="cropModal" class="modal">
        <div class="modal-content crop-modal-content">
            <div class="modal-header">
                    <h2>इमेज क्रॉप करें</h2>
                <div class="modal-navigation" id="cropModalNavigation">
                    <button class="nav-btn prev-image" id="prevImageCropBtn">
                        <i class="fas fa-chevron-left"></i>
                    </button>
                    <button class="nav-btn next-image" id="nextImageCropBtn">
                        <i class="fas fa-chevron-right"></i>
                    </button>
                </div>
                <button class="close-rotate-flip" id="closeCropModal">×</button>
            </div>
            <div class="crop-body">
                <div class="crop-modal-body">
                    <div class="crop-preview-container">
                        <div class="crop-image-container" id="cropImageContainer">
                            <img id="cropImage" alt="Crop Preview">
                            <div class="crop-selection" id="cropSelection">
                                <div class="crop-handle top-left"></div>
                                <div class="crop-handle top-middle"></div>
                                <div class="crop-handle top-right"></div>
                                <div class="crop-handle middle-left"></div>
                                <div class="crop-handle middle-right"></div>
                                <div class="crop-handle bottom-left"></div>
                                <div class="crop-handle bottom-middle"></div>
                                <div class="crop-handle bottom-right"></div>
                                <div class="crop-selection-top"></div>
                                <div class="crop-selection-bottom"></div>
                                <div class="crop-selection-left"></div>
                                <div class="crop-selection-right"></div>
                                <div class="crop-grid"></div>
                            </div>
                        </div>
                    </div>
                    <div class="crop-controls">
                        <h3>Crop Rectangle</h3>
                        <div class="vertical-group">
                            <div class="input-row">
                                <div class="vertical-group half-width">
                                    <label for="cropWidth">Width</label>
                                    <input type="number" id="cropWidth" class="crop-input full-width-input">
                                </div>
                                <div class="vertical-group half-width">
                                    <label for="cropHeight">Height</label>
                                    <input type="number" id="cropHeight" class="crop-input full-width-input">
                                </div>
                            </div>
                        </div>
                        <div class="vertical-group">
                            <label for="aspectRatioSelect">Aspect Ratio</label>
                            <select id="aspectRatioSelect" class="crop-select full-width-input">
                                <option value="free">Free Ratio</option>
                                <option value="original">Original Ratio</option>
                                <option value="custom">Custom</option>
                            </select>
                        </div>
                        <div id="customRatioGroup" class="vertical-group">
                            <div class="input-row">
                                <div class="vertical-group half-width">
                                    <label for="customRatioX">Ratio (X)</label>
                                    <input type="number" id="customRatioX" class="crop-input full-width-input" min="1">
                                </div>
                                <div class="vertical-group half-width">
                                    <label for="customRatioY">Ratio (Y)</label>
                                    <input type="number" id="customRatioY" class="crop-input full-width-input" min="1">
                                </div>
                            </div>
                        </div>
                        <h3>Crop Position</h3>
                        <div class="vertical-group">
                            <div class="input-row">
                                <div class="vertical-group half-width">
                                    <label for="cropPositionX">Position (X)</label>
                                    <input type="number" id="cropPositionX" class="crop-input full-width-input">
                                </div>
                                <div class="vertical-group half-width">
                                    <label for="cropPositionY">Position (Y)</label>
                                    <input type="number" id="cropPositionY" class="crop-input full-width-input">
                                </div>
                            </div>
                        </div>
                        <div class="crop-actions">
                            <button id="applyCropBtn" class="apply-rotate-flip-btn"><i class="fas fa-check"></i> क्रॉप करें</button>
                            <button id="resetCropBtn" class="reset-rotate-flip-btn"><i class="fas fa-undo"></i> रीसेट करें</button>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>
    <!-- End Crop Image Modal Box -->

        <!-- Right Side Image Browser Window -->
        <div class="gallery">
            <div id="upload-prompt" class="upload-prompt">
                <div class="upload-prompt-icon">
                    <i class="fas fa-image"></i>
                </div>
                <div class="upload-prompt-title">बहुउद्देश्यीय इमेज रेसाइज़र</div>
                    <div class="upload-prompt-instruction">इमेज अपलोड करने के लिए यहां क्लिक करें, ड्रैग & ड्रॉप करें, या Ctrl+V दबाएं</div>
                <div class="supported-formats">
                    <div class="format-item">✅ jpg</div>
                    <div class="format-item">✅ png</div>
                    <div class="format-item">✅ webp</div>
                    <div class="format-item">✅ gif</div>
                    <div class="format-item">✅ psd/psb</div>
                    <div class="format-item">✅ heic/heif</div>
                </div>
                <div class="formats-tooltip">
                        <div class="more-formats">
                            <i class="fas fa-ellipsis-h"></i> अधिक प्रारूप
                        </div>
                    <span class="tooltip-text">
                        tga, xcf, miff, dcm, xpm, pcx, fits, ppm, pgm, pím, mng, dds, otb
                    </span>
                </div>
                <div class="recommendation">अनुशंसित कुल फ़ाइलें: &lt; 100</div>
                    <div class="recommendation">अनुशंसित फ़ाइल आकार: &lt; 10Mb</div>
            </div>
            
            <div id="image-container" class="image-container">
                <!-- Images Will Be Added Dynamically Via JavaScript -->
            </div>
        </div>
    </div>

    <!-- Delete Confirmation Modal Box -->
    <div id="delete-modal" class="modal">
        <div class="modal-content">
                <p>सभी इमेज डिलीट करें?</p>
            <div class="modal-buttons">
                <button id="cancel-delete" class="modal-btn cancel-btn">रद्द करें</button>
                <button id="confirm-delete" class="modal-btn confirm-btn">पुष्टि करें</button>
            </div>
        </div>
    </div>

    <!-- Single Image Delete Confirmation Modal Box -->
    <div id="delete-image-modal" class="modal">
        <div class="modal-content">
                <p>क्या आप वाकई इस इमेज को डिलीट करना चाहते हैं?</p>
            <div class="modal-buttons">
                <button id="cancel-delete-image" class="modal-btn cancel-btn">रद्द करें</button>
                <button id="confirm-delete-image" class="modal-btn confirm-btn">पुष्टि करें</button>
            </div>
        </div>
    </div>

    <!-- Rotate and Flip Modal Box -->
    <div id="rotate-flip-modal" class="modal">
        <div class="rotate-flip-modal-content">
            <div class="rotate-flip-header">
                <h2>इमेज घुमाएं और फ्लिप करें</h2>
                <div class="rotate-flip-navigation" id="rotate-flip-navigation">
                    <button class="nav-btn prev-image" id="prev-image-rotate">
                        <i class="fas fa-chevron-left"></i>
                    </button>
                    <button class="nav-btn next-image" id="next-image-rotate">
                        <i class="fas fa-chevron-right"></i>
                    </button>
                </div>
                <button class="close-rotate-flip" id="close-rotate-flip">×</button>
            </div>
            <div class="rotate-flip-body">
                <div class="rotate-flip-preview-container">
                    <div class="rotate-flip-preview">
                        <img id="rotate-flip-image" class="rotate-flip-image" src="" alt="Rotate and Flip Image">
                    </div>
                </div>
                <div class="rotate-flip-controls">
                    <div class="rotate-controls">
                    <button class="rotate-btn-large clockwise" id="rotate-clockwise">
                        <i class="fas fa-sync-alt"></i>
                        <div class="btn-name">दक्षिणावर्त</div>
                    </button>
                    <button class="rotate-btn-large counterclockwise" id="rotate-counterclockwise">
                        <i class="fas fa-sync-alt fa-rotate-180"></i>
                        <div class="btn-name">वामावर्त</div>
                    </button>
                </div>
                <div class="flip-controls">
                    <button class="flip-btn-large horizontal" id="flip-horizontal">
                        <i class="fas fa-exchange-alt"></i>
                        <div class="btn-name">क्षैतिज फ्लिप</div>
                    </button>
                    <button class="flip-btn-large vertical" id="flip-vertical">
                        <i class="fas fa-exchange-alt fa-rotate-90"></i>
                        <div class="btn-name">ऊर्ध्वाधर फ्लिप</div>
                    </button>
                </div>
                <div class="rotate-flip-actions">
                <button id="apply-rotate-flip" class="apply-rotate-flip-btn"><i class="fas fa-check"></i> लागू करें</button>
                <button id="reset-rotate-flip" class="reset-rotate-flip-btn"><i class="fas fa-undo"></i> रीसेट करें</button>
            </div>
            </div>
            </div>
        </div>
    </div>

    <!-- Tutorial Section -->
    <section class="tutorial-section">
        <div class="container">
            <h2 class="text-4xl">इमेज रेसाइज़र का उपयोग कैसे करें</h2>
            <div class="grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-4">
                <!-- Step 1 -->
                <div class="tutorial-card">
                    <h3>
                        <span class="tutorial-icon">
                            <i class="fas fa-cloud-upload-alt"></i>
                        </span>
                        इमेज अपलोड करें
                    </h3>
                    <div>
                        <p title="अपनी इमेज को सीधे अपलोड क्षेत्र पर ड्रैग और ड्रॉप करें या अपलोड बटन पर क्लिक करके अपने डिवाइस से चुनें। JPG, PNG और WebP प्रारूपों का समर्थन करता है।">अपनी इमेज को सीधे अपलोड क्षेत्र पर ड्रैग और ड्रॉप करें या अपलोड बटन पर क्लिक करके अपने डिवाइस से चुनें। JPG, PNG और WebP प्रारूपों का समर्थन करता है।</p>
                    </div>
                </div>
                <!-- Step 2 -->
                <div class="tutorial-card">
                    <h3>
                        <span class="tutorial-icon">
                            <i class="fas fa-sliders-h"></i>
                        </span>
                        विकल्प चुनें
                    </h3>
                    <div>
                        <p title="तीन रेसाइज़ मोडों में से चुनें: आयामों से, प्रतिशत से, या सोशल मीडिया के लिए। चौड़ाई, ऊंचाई सेट करें, या फेसबुक, इंस्टाग्राम, ट्विटर और यूट्यूब के लिए प्रीसेट चुनें।">तीन रेसाइज़ मोडों में से चुनें: आयामों से, प्रतिशत से, या सोशल मीडिया के लिए। चौड़ाई, ऊंचाई सेट करें, या फेसबुक, इंस्टाग्राम, ट्विटर और यूट्यूब के लिए प्रीसेट चुनें।</p>
                    </div>
                </div>
                <!-- Step 3 -->
                <div class="tutorial-card">
                    <h3>
                        <span class="tutorial-icon">
                            <i class="fas fa-crop-alt"></i>
                        </span>
                        इमेज रेसाइज़ करें
                    </h3>
                    <div>
                        <p title="अपनी इमेज पर रेसाइज़ सेटिंग्स लागू करें। आप इमेज को क्रॉप, रोटेट और फ्लिप भी कर सकते हैं। एक बार में कई इमेज रेसाइज़ करने के लिए बैच प्रोसेसिंग का उपयोग करें।">अपनी इमेज पर रेसाइज़ सेटिंग्स लागू करें। आप इमेज को क्रॉप, रोटेट और फ्लिप भी कर सकते हैं। एक बार में कई इमेज रेसाइज़ करने के लिए बैच प्रोसेसिंग का उपयोग करें।</p>
                    </div>
                </div>
                <!-- Step 4 -->
                <div class="tutorial-card">
                    <h3>
                        <span class="tutorial-icon">
                            <i class="fas fa-download"></i>
                        </span>
                        परिणाम डाउनलोड करें
                    </h3>
                    <div>
                        <p title="फॉर्मेट सेलेक्टर अपने मूल इमेज प्रारूप से स्वचालित रूप से मेल खाता है। आप मैन्युअल रूप से PNG, JPG, या WebP प्रारूप भी चुन सकते हैं। अपनी रेसाइज़ की गई इमेज डाउनलोड करने के लिए निर्यात पर क्लिक करें।">फॉर्मेट सेलेक्टर अपने मूल इमेज प्रारूप से स्वचालित रूप से मेल खाता है। आप मैन्युअल रूप से PNG, JPG, या WebP प्रारूप भी चुन सकते हैं। अपनी रेसाइज़ की गई इमेज डाउनलोड करने के लिए निर्यात पर क्लिक करें।</p>
                    </div>
                </div>
            </div>
        </div>
    </section>

    <!-- Feature Introduction Area -->
    <section class="feature-section">
        <div class="container">
            <div class="grid-cols-2">
                <div class="content-image">
                    <img src="https://images.unsplash.com/photo-1542831371-29b0f74f9713?w=600&h=400&fit=crop" alt="Image Resizer">
                </div>
                <div class="content-text">
                    <h2>पेशेवर इमेज रेसाइज़िंग</h2>
                    <p>इमेज को सटीकता और आसानी से रेसाइज़ करें। हमारा टूल आपको किसी भी उद्देश्य के लिए अपनी इमेज को अनुकूलित करने में मदद करने के लिए कई रेसाइज़िंग विकल्प प्रदान करता है।</p>
                    <p>आयामों, प्रतिशत से रेसाइज़ करें, या फेसबुक, इंस्टाग्राम, ट्विटर और यूट्यूब के लिए सोशल मीडिया प्रीसेट का उपयोग करें। वेब डिजाइनरों, सोशल मीडिया मैनेजरों और इमेज के साथ काम करने वाले किसी भी व्यक्ति के लिए उपयुक्त।</p>
                </div>
            </div>
        </div>
    </section>

    <!-- Tool Features Area -->
    <section class="feature-section gray">
        <div class="container">
            <div class="grid-cols-2">
                <div class="content-text order-2 md:order-1">
                    <h2>शक्तिशाली रेसाइज़िंग टूल्स</h2>
                    <p>साधारण आयाम समायोजन से लेकर बैच प्रोसेसिंग तक, हमारे टूल में पेशेवर रूप से इमेज रेसाइज़ करने के लिए आपको जो कुछ भी चाहिए वह सब है।</p>
                    <p>कस्टम एस्पेक्ट रेशियो के साथ इमेज को क्रॉप करें, इमेज को रोटेट और फ्लिप करें, बैकग्राउंड रंग बदलें, या बैकग्राउंड को पारदर्शी बनाएं। अनुकूलित गुणवत्ता के साथ PNG, JPG, या WebP प्रारूप में निर्यात करें।</p>
                </div>
                <div class="content-image order-1 md:order-2">
                    <img src="https://images.unsplash.com/photo-1551288049-bebda4e38f71?w=600&h=400&fit=crop" alt="Resizing Tools">
                </div>
            </div>
        </div>
    </section>

    <!-- Privacy Security Area -->
    <section class="feature-section">
        <div class="container">
            <div class="grid-cols-2">
                <div class="content-image">
                    <img src="https://plus.unsplash.com/premium_photo-1687382111414-7b87afa5da34?w=600&h=400&fit=crop" alt="Privacy Protection">
                </div>
                <div class="content-text">
                    <h2>100% गोपनीयता सुरक्षा</h2>
                    <p>सभी इमेज प्रोसेसिंग आपके ब्राउज़र में स्थानीय रूप से होती है। आपकी इमेज कभी भी किसी सर्वर पर अपलोड नहीं की जाती है।</p>
                    <p>आपका डेटा आपके डिवाइस पर रहता है, जिससे संवेदनशील इमेज के लिए पूर्ण गोपनीयता और सुरक्षा सुनिश्चित होती है।</p>
                </div>
            </div>
        </div>
    </section>

    <!-- Mobile Support Area -->
    <section class="feature-section gray">
        <div class="container">
            <div class="grid-cols-2">
                <div class="content-text order-2 md:order-1">
                    <h2>मोबाइल-फ्रेंडली डिजाइन</h2>
                    <p>हमारे मोबाइल-फ्रेंडली डिजाइन के साथ चलते-चलते इमेज रेसाइज़ करें। हमारा टूल स्मार्टफोन और टैबलेट पर सहजता से काम करता है, जिससे आप कहीं भी हों, इमेज संपादित कर सकते हैं।</p>
                    <p>किसी भी स्क्रीन आकार के अनुकूल होने वाले रिस्पॉन्सिव इंटरफेस के साथ, आप अपने मोबाइल डिवाइस का उपयोग करके आसानी से इमेज अपलोड, रेसाइज़ और डाउनलोड कर सकते हैं। इंस्टॉल करने के लिए कोई ऐप नहीं, बस अपना ब्राउज़र खोलें और रेसाइज़ करना शुरू करें।</p>
                </div>
                <div class="content-image order-1 md:order-2">
                    <img src="https://images.unsplash.com/photo-1520333789090-1afc82db536a?w=600&h=400&fit=crop" alt="Mobile-Friendly Design">
                </div>
            </div>
        </div>
    </section>

    <!-- Bottom Text Area -->
    <section class="bottom-text-section">
        <div class="container">
            <h2>इमेज को मुफ्त में रेसाइज़ करें</h2>
            <p>इमेज रेसाइज़ करने के लिए जटिल सॉफ्टवेयर का उपयोग करने का अलविदा कहें। CaliperTools इमेज रेसाइज़र के साथ, आप आसानी से अपनी इमेज को मुफ्त में रेसाइज़ कर सकते हैं। सबसे अच्छी बात यह है कि आप किसी भी डिवाइस से ब्राउज़र के साथ हमारे टूल का उपयोग कर सकते हैं, कोई डाउनलोड या इंस्टॉलेशन की आवश्यकता नहीं है। कोई अनुभव आवश्यक नहीं है!</p>
            <p class="mb-10">अपनी इमेज अपलोड करने के लिए ड्रैग-एंड-ड्रॉप एडिटर का उपयोग करें, और CaliperTools इमेज रेसाइज़र बाकी सब काम कर लेगा। जब आप काम पूरा कर लेते हैं, तो फॉर्मेट सेलेक्टर स्वचालित रूप से आपके मूल इमेज प्रारूप से मेल खाता है, या आप मैन्युअल रूप से PNG, JPG, या WebP चुन सकते हैं। जितनी चाहें उतनी तस्वीरें रेसाइज़ करें, सब कुछ बस कुछ ही क्लिक में।</p>
            
            <h2>हर बार उच्च-गुणवत्ता वाली रेसाइज़िंग</h2>
            <p>रेसाइज़ करते समय अपनी इमेज की गुणवत्ता को बनाए रखें। हमारे उन्नत एल्गोरिदम सुनिश्चित करते हैं कि आपकी इमेज अपनी स्पष्टता और विवरण को बनाए रखे, चाहे आप वेब, सोशल मीडिया या प्रिंट के लिए रेसाइज़ कर रहे हों।</p>
            <p>हमारे अंतर्निहित अनुकूलन विकल्पों के साथ, आप किसी भी प्लेटफॉर्म के लिए अपनी इमेज को सही बनाने के लिए आयाम, प्रतिशत समायोजित कर सकते हैं, या सोशल मीडिया प्रीसेट का उपयोग कर सकते हैं। पूरी तरह से रेसाइज़ की गई इमेज के साथ अपनी तस्वीरों को उन्नत करें और अपने कार्यप्रवाह को बेहतर बनाएं।</p>
        </div>
    </section>

    <!-- Related Tools Area -->
    <section class="section related-tools">
        <div class="container">
            <h2 class="section-title">संबंधित टूल्स</h2>
            <div class="tools-grid" id="relatedTools">
                <!-- Related tools will be dynamically generated by JS -->
            </div>
        </div>
    </section>
</main>
<script src="../scripts/script-related-tools.js"></script>
<script>
    // Initialize related tools
    document.addEventListener('DOMContentLoaded', function() {
        const currentSlug = 'image-resizer';
        if (typeof initRelatedTools === 'function') {
            initRelatedTools(currentSlug);
        }
    });
</script>

    

    
    <script>
// Execute after DOM is loaded
document.addEventListener('DOMContentLoaded', function() {
    // Social media preset data
    const socialPresets = {
        facebook: [
            { name: 'Profile', width: 170, height: 170 },
            { name: 'Cover', width: 820, height: 312 },
            { name: 'Post', width: 1200, height: 900 },
            { name: 'Ad', width: 1280, height: 720 }
        ],
        instagram: [
            { name: 'Profile', width: 110, height: 110 },
            { name: 'Post', width: 320, height: 320 },
            { name: 'Story', width: 1080, height: 1920 }
        ],
        twitter: [
            { name: 'Profile', width: 400, height: 400 },
            { name: 'Header', width: 1500, height: 500 },
            { name: 'Image', width: 1024, height: 512 },
            { name: 'Card', width: 1200, height: 628 },
            { name: 'Ad', width: 1200, height: 675 }
        ],
        youtube: [
            { name: 'Profile', width: 800, height: 800 },
            { name: 'Channel Art', width: 2560, height: 1440 },
            { name: 'Thumbnail', width: 1280, height: 720 }
        ]
    };

    // Rotation and flip related variables
    let currentRotateFlipImageIndex = -1;
    let originalRotateFlipImage = null;
    let rotateFlipData = {
        rotation: 0, // Rotation angle
        flipX: false, // Horizontal flip
        flipY: false // Vertical flip
    };

    // DOM element cache
    const elements = {
        // Rotation and flip related
        rotateFlipModal: document.getElementById('rotate-flip-modal'),
        rotateFlipImage: document.getElementById('rotate-flip-image'),
        closeRotateFlipBtn: document.getElementById('close-rotate-flip'),
        prevImageRotateBtn: document.getElementById('prev-image-rotate'),
        nextImageRotateBtn: document.getElementById('next-image-rotate'),
        rotateClockwiseBtn: document.getElementById('rotate-clockwise'),
        rotateCounterclockwiseBtn: document.getElementById('rotate-counterclockwise'),
        flipHorizontalBtn: document.getElementById('flip-horizontal'),
        flipVerticalBtn: document.getElementById('flip-vertical'),
        applyRotateFlipBtn: document.getElementById('apply-rotate-flip'),
        resetRotateFlipBtn: document.getElementById('reset-rotate-flip'),
        rotateFlipNavigation: document.getElementById('rotate-flip-navigation'),
        // Upload related
        uploadBtn: document.getElementById('upload-btn'),
        fileInput: document.getElementById('file-input'),
        deleteAllBtn: document.getElementById('delete-all-btn'),
        uploadPrompt: document.getElementById('upload-prompt'),
        imageContainer: document.getElementById('image-container'),
        
        // Modal box related
        deleteModal: document.getElementById('delete-modal'),
        cancelDeleteBtn: document.getElementById('cancel-delete'),
        confirmDeleteBtn: document.getElementById('confirm-delete'),
        deleteImageModal: document.getElementById('delete-image-modal'),
        cancelDeleteImageBtn: document.getElementById('cancel-delete-image'),
        confirmDeleteImageBtn: document.getElementById('confirm-delete-image'),
        
        // Tab related
        tabs: document.querySelectorAll('.tab'),
        tabContents: document.querySelectorAll('.tab-content'),
        
        // Export related
        exportBtn: document.getElementById('export-btn'),
        zipBtn: document.getElementById('zip-btn'),

        
        // Dimensions related
        widthInputDim: document.getElementById('width-dim'),
        heightInputDim: document.getElementById('height-dim'),
        lockAspectDimCheckbox: document.getElementById('lock-aspect-dim'),
        backgroundOptionsDim: document.getElementById('background-options-dim'),
        
        // Percentage related
        percentageSlider: document.getElementById('percentage-slider'),
        percentageDisplay: document.getElementById('percentage-display'),
        percentageInput: document.getElementById('percentage-input'),
        
        // Social media related
        socialPlatformSelect: document.getElementById('social-platform'),
        socialPresetSelect: document.getElementById('social-preset'),
        widthInputSocial: document.getElementById('width-social'),
        heightInputSocial: document.getElementById('height-social'),
        lockAspectSocialCheckbox: document.getElementById('lock-aspect-social'),
        backgroundOptionsSocial: document.getElementById('background-options-social'),
        
        // Export settings related
        fileSizeInput: document.getElementById('file-size'),
        sizeUnitSelect: document.getElementById('size-unit'),
        saveAsSelect: document.getElementById('save-as'),
        

    };

    // Store uploaded image information
    let uploadedImages = [];
    let currentTab = 'dimensions'; // Current active tab
    let currentSocialPreset = null; // Current selected social media preset
    let imageToDelete = -1; // Index of image to delete
    // Store current image pixel dimensions
    let currentPixelWidth = 0;
    let currentPixelHeight = 0;
    // Store Original Aspect Ratio
    let originalAspectRatio = 1;

    // Initialize
    function init() {
        // Validate if all necessary elements exist
        if (!validateElements()) {
            console.error('Critical DOM elements missing, unable to initialize application');
            return;
        }
        
        // Parse URL parameters first
        parseUrlParams();
        
        // Set event listeners
        setupEventListeners();
        
        // Set Color Picker
        setupColorPicker('color-picker-dim', 'color-code-dim');
        setupColorPicker('color-picker-social', 'color-code-social');
        
        // Set mutex relationship for background and transparency options
        setupBackgroundTransparencyMutex('use-background-dim', 'use-transparency-dim');
        setupBackgroundTransparencyMutex('use-background-social', 'use-transparency-social');
        
        // Set aspect ratio locking for all tabs
        setupDimensionAspectLock(
            elements.widthInputDim, 
            elements.heightInputDim, 
            elements.lockAspectDimCheckbox,
            'dim'
        );
        setupDimensionAspectLock(
            elements.widthInputSocial, 
            elements.heightInputSocial, 
            elements.lockAspectSocialCheckbox,
            'social'
        );
        
        // Set unit conversion for all tabs (using fixed DPI conversion)
        
        // Initialize state
        checkLockAspectForBackground('dim');
        checkLockAspectForBackground('perc');
        checkLockAspectForBackground('social');
        
        // Initialize percentage slider and input box linkage
        setupPercentageSync();

        // Initialize rotation and flip functionality
        setupRotateFlipFunctionality();
        
        // Initially hide image container
        elements.imageContainer.style.display = 'none';
    }

    // Validate if necessary DOM elements exist
    function validateElements() {
        for (const [key, element] of Object.entries(elements)) {
            if (element === null || element === undefined) {
                console.error(`Missing necessary DOM element: ${key}`);
                return false;
            }
        }
        return true;
    }

    // Set all event listeners
    function setupEventListeners() {
        // Upload image
        elements.uploadBtn.addEventListener('click', () => {
            elements.fileInput.click();
        });

        // Click on upload prompt to upload
        elements.uploadPrompt.addEventListener('click', () => {
            elements.fileInput.click();
        });

        elements.fileInput.addEventListener('change', handleFileUpload);

        // Drag and drop upload
        const gallery = document.querySelector('.gallery');
        gallery.addEventListener('dragover', (e) => {
            e.preventDefault();
            elements.uploadPrompt.classList.add('drag-over');
        });

        gallery.addEventListener('dragleave', () => {
            elements.uploadPrompt.classList.remove('drag-over');
        });

        gallery.addEventListener('drop', (e) => {
            e.preventDefault();
            elements.uploadPrompt.classList.remove('drag-over');
            const files = e.dataTransfer.files;
            if (files.length) {
                handleFiles(files);
            }
        });

        // Copy and paste upload
        document.addEventListener('paste', (e) => {
            const items = (e.clipboardData || e.originalEvent.clipboardData).items;
            for (let item of items) {
                if (item.kind === 'file') {
                    const file = item.getAsFile();
                    if (file.type.startsWith('image/')) {
                        handleFiles([file]);
                    }
                }
            }
        });

        // Delete all images related
        elements.deleteAllBtn.addEventListener('click', () => {
            if (uploadedImages.length > 0) {
                elements.deleteModal.classList.add('show');
            }
        });

        elements.cancelDeleteBtn.addEventListener('click', () => {
            elements.deleteModal.classList.remove('show');
        });

        elements.confirmDeleteBtn.addEventListener('click', () => {
            elements.imageContainer.innerHTML = '';
            uploadedImages = [];
            currentPixelWidth = 0;
            currentPixelHeight = 0;
            originalAspectRatio = 1;
            elements.deleteModal.classList.remove('show');
            // Show upload prompt, hide image container
            elements.uploadPrompt.style.display = 'flex';
            elements.imageContainer.style.display = 'none';
            
            // Reset to original state
            resetToOriginalState();
        });

        // Single image delete related
        elements.cancelDeleteImageBtn.addEventListener('click', () => {
            elements.deleteImageModal.classList.remove('show');
            imageToDelete = -1;
        });

        elements.confirmDeleteImageBtn.addEventListener('click', () => {
            if (imageToDelete !== -1 && imageToDelete < uploadedImages.length) {
                // Remove image data
                uploadedImages.splice(imageToDelete, 1);
                
                // Update current image index
                if (currentCropImageIndex === imageToDelete) {
                    currentCropImageIndex = -1; // Reset crop image index
                    // Close crop modal
                    if (cropElements && cropElements.cropModal) {
                        cropElements.cropModal.classList.remove('show');
                    }
                } else if (currentCropImageIndex > imageToDelete) {
                    currentCropImageIndex--; // Adjust index
                }
                
                if (currentRotateFlipImageIndex === imageToDelete) {
                    currentRotateFlipImageIndex = -1; // Reset rotation flip image index
                    // Close rotation flip modal
                    if (elements.rotateFlipModal) {
                        elements.rotateFlipModal.classList.remove('show');
                    }
                } else if (currentRotateFlipImageIndex > imageToDelete) {
                    currentRotateFlipImageIndex--; // Adjust index
                }
                
                // Close delete image modal
                elements.deleteImageModal.classList.remove('show');
                
                // Re-render images
                renderImages();
                
                // If no images, show upload prompt and reset to original state
                if (uploadedImages.length === 0) {
                    elements.uploadPrompt.style.display = 'flex';
                    elements.imageContainer.style.display = 'none';
                    currentPixelWidth = 0;
                    currentPixelHeight = 0;
                    originalAspectRatio = 1;
                    resetToOriginalState();
                } else if (imageToDelete === 0) {
                    // If first image is deleted, update dimension inputs
                    updateDimensionInputsWithFirstImage();
                }
                
                elements.deleteImageModal.classList.remove('show');
                imageToDelete = -1;
            }
        });

        // Close modal when clicking outside area
        window.addEventListener('click', (e) => {
            if (e.target === elements.deleteModal) {
                elements.deleteModal.classList.remove('show');
            }
            if (e.target === elements.deleteImageModal) {
                elements.deleteImageModal.classList.remove('show');
                imageToDelete = -1;
            }

        });

        // Tab switching
        elements.tabs.forEach(tab => {
            tab.addEventListener('click', () => {
                const tabId = tab.getAttribute('data-tab');
                currentTab = tabId;

                elements.tabs.forEach(t => t.classList.remove('active'));
                tab.classList.add('active');

                elements.tabContents.forEach(content => {
                    content.classList.remove('active');
                    if (content.id === tabId) {
                        content.classList.add('active');
                    }
                });

                // Check background options display status for current tab
                checkLockAspectForBackground(tabId === 'dimensions' ? 'dim' : 
                                           tabId === 'percentage' ? 'perc' : 'social');

                updateImageDimensions();

                // Update URL based on tab
                updateUrlForTab(tabId);
            });
        });

        // Social media platform selection change
        elements.socialPlatformSelect.addEventListener('change', () => {
            const platform = elements.socialPlatformSelect.value;
            elements.socialPresetSelect.innerHTML = '';
            
            // Update URL based on platform
            updateUrlForPlatform(platform);
            
            if (!platform) {
                const option = document.createElement('option');
                option.value = '';
                option.textContent = 'Please select platform first';
                elements.socialPresetSelect.appendChild(option);
                if (uploadedImages.length > 0) {
                    elements.widthInputSocial.value = uploadedImages[0].originalWidth;
                    elements.heightInputSocial.value = uploadedImages[0].originalHeight;
                    currentPixelWidth = uploadedImages[0].originalWidth;
                    currentPixelHeight = uploadedImages[0].originalHeight;
                } else {
                    elements.widthInputSocial.value = '';
                    elements.heightInputSocial.value = '';
                    currentPixelWidth = 0;
                    currentPixelHeight = 0;
                }
                currentSocialPreset = null;
            } else {
                // Add preset options for selected platform
                socialPresets[platform].forEach(preset => {
                    const option = document.createElement('option');
                    option.value = JSON.stringify(preset);
                    option.textContent = `${preset.name} (${preset.width} x ${preset.height} px)`;
                    elements.socialPresetSelect.appendChild(option);
                });
                
                // Auto-select first preset
                if (socialPresets[platform].length > 0) {
                    elements.socialPresetSelect.selectedIndex = 0;
                    const firstPreset = socialPresets[platform][0];
                    elements.widthInputSocial.value = firstPreset.width;
                    elements.heightInputSocial.value = firstPreset.height;
                    currentSocialPreset = firstPreset;
                    // Update pixel size record
                    currentPixelWidth = firstPreset.width;
                    currentPixelHeight = firstPreset.height;
                }
            }
            
            updateImageDimensions();
        });

        // Social media preset selection change
        elements.socialPresetSelect.addEventListener('change', () => {
            const presetStr = elements.socialPresetSelect.value;
            if (presetStr) {
                currentSocialPreset = JSON.parse(presetStr);
                elements.widthInputSocial.value = currentSocialPreset.width;
                elements.heightInputSocial.value = currentSocialPreset.height;
                // Update pixel size record
                currentPixelWidth = currentSocialPreset.width;
                currentPixelHeight = currentSocialPreset.height;
            } else {
                currentSocialPreset = null;
                if (uploadedImages.length > 0) {
                    elements.widthInputSocial.value = uploadedImages[0].originalWidth;
                    elements.heightInputSocial.value = uploadedImages[0].originalHeight;
                    currentPixelWidth = uploadedImages[0].originalWidth;
                    currentPixelHeight = uploadedImages[0].originalHeight;
                } else {
                    elements.widthInputSocial.value = '';
                    elements.heightInputSocial.value = '';
                    currentPixelWidth = 0;
                    currentPixelHeight = 0;
                }
            }
            updateImageDimensions();
        });

        // Image processing function
        function processImage(image) {
            return new Promise((resolve) => {
                const canvas = document.createElement('canvas');
                const ctx = canvas.getContext('2d');
                
                // Fixed export resolution to 72 DPI (for web use)
                const exportDPI = 72;
                const defaultDPI = 72;
                
                // Calculate DPI scaling factor
                const dpiScale = exportDPI / defaultDPI;
                
                // Calculate new dimensions based on current settings (considering DPI scaling)
                let displayWidth = currentPixelWidth;
                let displayHeight = currentPixelHeight;
                
                // Set canvas actual size (pixels = display size × DPI scaling factor)
                canvas.width = Math.round(displayWidth * dpiScale);
                canvas.height = Math.round(displayHeight * dpiScale);
                
                // Set CSS display size to ensure image displays correctly
                canvas.style.width = `${displayWidth}px`;
                canvas.style.height = `${displayHeight}px`;
                
                // Set Canvas context scaling factor to ensure drawn content scales according to DPI
                ctx.scale(dpiScale, dpiScale);
                
                // Decide whether to fill background color based on user selection
                const useBackgroundDim = document.getElementById('use-background-dim');
                const useTransparencyDim = document.getElementById('use-transparency-dim');
                const useBackgroundSocial = document.getElementById('use-background-social');
                const useTransparencySocial = document.getElementById('use-transparency-social');
                
                // Check background settings for current tab
                let shouldUseBackground = false;
                let shouldUseTransparent = false;
                let backgroundColor = '#FFFFFF'; // Default white
                
                if (currentTab === 'dimensions' || currentTab === 'percentage') {
                    if (useTransparencyDim && useTransparencyDim.checked) {
                        shouldUseTransparent = true; // Transparent background
                    } else if (useBackgroundDim && useBackgroundDim.checked) {
                        shouldUseBackground = true;
                        // Get color picker value
                        const colorPicker = document.getElementById('color-picker-dim');
                        if (colorPicker) {
                            backgroundColor = colorPicker.value;
                        }
                    }
                } else if (currentTab === 'social') {
                    if (useTransparencySocial && useTransparencySocial.checked) {
                        shouldUseTransparent = true; // Transparent background
                    } else if (useBackgroundSocial && useBackgroundSocial.checked) {
                        shouldUseBackground = true;
                        // Get color picker value
                        const colorPicker = document.getElementById('color-picker-social');
                        if (colorPicker) {
                            backgroundColor = colorPicker.value;
                        }
                    }
                }
                
                // Draw image (centered)
                const img = new Image();
                img.crossOrigin = 'anonymous';
                img.src = image.src;
                img.onload = () => {
                    // Draw image directly according to set dimensions, without preserving original aspect ratio
                    ctx.drawImage(img, 0, 0, displayWidth, displayHeight);
                    
                    // If user selected Transparent or Select Color, process the image to remove/replace background
                    if (shouldUseTransparent || shouldUseBackground) {
                        const imageData = ctx.getImageData(0, 0, displayWidth, displayHeight);
                        const data = imageData.data;
                        
                        // Get background color from top-left corner pixel
                        const bgR = data[0];
                        const bgG = data[1];
                        const bgB = data[2];
                        
                        // Process each pixel
                        for (let i = 0; i < data.length; i += 4) {
                            const r = data[i];
                            const g = data[i + 1];
                            const b = data[i + 2];
                            
                            // Check if pixel matches background color (with some tolerance)
                            const tolerance = 30;
                            if (Math.abs(r - bgR) < tolerance && 
                                Math.abs(g - bgG) < tolerance && 
                                Math.abs(b - bgB) < tolerance) {
                                if (shouldUseTransparent) {
                                    // Make transparent
                                    data[i + 3] = 0;
                                } else if (shouldUseBackground) {
                                    // Replace with selected color
                                    const hexColor = backgroundColor;
                                    const colorR = parseInt(hexColor.slice(1, 3), 16);
                                    const colorG = parseInt(hexColor.slice(3, 5), 16);
                                    const colorB = parseInt(hexColor.slice(5, 7), 16);
                                    data[i] = colorR;
                                    data[i + 1] = colorG;
                                    data[i + 2] = colorB;
                                    data[i + 3] = 255;
                                }
                            }
                        }
                        
                        ctx.putImageData(imageData, 0, 0);
                    }
                    
                    // Convert image according to save format
                    let saveFormat = elements.saveAsSelect.value === 'original' ? 
                        image.file.type.split('/')[1] : elements.saveAsSelect.value;
                    
                    // If transparent background is selected, force PNG format
                    if (shouldUseTransparent) {
                        saveFormat = 'png';
                    }
                    
                    // Generate image with DPI information
                    const dataURL = canvas.toDataURL(`image/${saveFormat}`);
                    
                    // For PNG format, we need to manually embed DPI information
                    // For JPEG and other formats, use canvas directly (canvas is already set to 72 DPI)
                    if (saveFormat === 'png') {
                        // Convert to Blob and embed DPI information
                        createImageWithDPI(dataURL, exportDPI, saveFormat, shouldUseBackground ? backgroundColor : null, shouldUseTransparent).then(blob => {
                            resolve({
                                blob: blob,
                                name: `${image.name.split('.')[0]}.${saveFormat}`,
                                format: saveFormat,
                                dpi: exportDPI
                            });
                        });
                    } else {
                        canvas.toBlob((blob) => {
                            resolve({
                                blob: blob,
                                name: `${image.name.split('.')[0]}.${saveFormat}`,
                                format: saveFormat,
                                dpi: exportDPI
                            });
                        }, `image/${saveFormat}`);
                    }
                };
            });
        }
        
        // Export functionality
        elements.exportBtn.addEventListener('click', async () => {
            if (uploadedImages.length === 0) {
                alert('Please upload images first');
                return;
            }
            
            // Process and download each image
            for (let i = 0; i < uploadedImages.length; i++) {
                const processedImage = await processImage(uploadedImages[i]);
                
                // Create download link
                const url = URL.createObjectURL(processedImage.blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = processedImage.name;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
            }
        });

        // ZIP packaging functionality
        elements.zipBtn.addEventListener('click', async () => {
            if (uploadedImages.length === 0) {
                alert('Please upload images first');
                return;
            }
            
            const zip = new JSZip();
            
            // Process all images
            for (let i = 0; i < uploadedImages.length; i++) {
                const processedImage = await processImage(uploadedImages[i]);
                zip.file(processedImage.name, processedImage.blob);
            }
            
            // Generate ZIP file
            zip.generateAsync({ type: 'blob' }).then((content) => {
                // Create download link
                const url = URL.createObjectURL(content);
                const a = document.createElement('a');
                a.href = url;
                a.download = 'images.zip';
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
            });
        });

        // Save format selection change
        elements.saveAsSelect.addEventListener('change', () => {
            const format = elements.saveAsSelect.value;
            updateUrlForFormat(format);
        });
    }

    // Crop related variables
    let currentCropImageIndex = -1;
    let originalCropImage = null;
    let cropData = {
        x: 0,
        y: 0,
        width: 0,
        height: 0,
        aspectRatio: null,
        imageNaturalWidth: 0,
        imageNaturalHeight: 0,
        scale: 1
    };
    let isDragging = false;
    let isResizing = false;
    let resizeHandle = null;
    let startX, startY, startCropX, startCropY, startCropWidth, startCropHeight;

    // Crop DOM elements
    const cropElements = {
        cropModal: document.getElementById('cropModal'),
        closeCropModal: document.getElementById('closeCropModal'),
        prevImageCropBtn: document.getElementById('prevImageCropBtn'),
        nextImageCropBtn: document.getElementById('nextImageCropBtn'),
        cropImage: document.getElementById('cropImage'),
        cropSelection: document.getElementById('cropSelection'),
        cropImageContainer: document.getElementById('cropImageContainer'),
        cropWidth: document.getElementById('cropWidth'),
        cropHeight: document.getElementById('cropHeight'),
        aspectRatioSelect: document.getElementById('aspectRatioSelect'),
        customRatioGroup: document.getElementById('customRatioGroup'),
        customRatioX: document.getElementById('customRatioX'),
        customRatioY: document.getElementById('customRatioY'),
        cropPositionX: document.getElementById('cropPositionX'),
        cropPositionY: document.getElementById('cropPositionY'),
        applyCropBtn: document.getElementById('applyCropBtn'),
        resetCropBtn: document.getElementById('resetCropBtn'),
        cropModalNavigation: document.getElementById('cropModalNavigation')
    };

    // Set crop functionality
    function setupCropFunctionality() {
        // Close crop window
        cropElements.closeCropModal.addEventListener('click', () => {
            cropElements.cropModal.classList.remove('show');
        });

        // Previous/next image navigation
        cropElements.prevImageCropBtn.addEventListener('click', () => {
            if (uploadedImages.length <= 1) return;
            currentCropImageIndex = (currentCropImageIndex - 1 + uploadedImages.length) % uploadedImages.length;
            openCropModal(currentCropImageIndex);
        });

        cropElements.nextImageCropBtn.addEventListener('click', () => {
            if (uploadedImages.length <= 1) return;
            currentCropImageIndex = (currentCropImageIndex + 1) % uploadedImages.length;
            openCropModal(currentCropImageIndex);
        });

        // Aspect ratio selection change
        cropElements.aspectRatioSelect.addEventListener('change', () => {
            const selectedValue = cropElements.aspectRatioSelect.value;
            cropElements.customRatioGroup.style.display = selectedValue === 'custom' ? 'flex' : 'none';

            if (selectedValue === 'free') {
                cropData.aspectRatio = null;
                resetCropSelection();
            } else if (selectedValue === 'original') {
                cropData.aspectRatio = originalCropImage.naturalWidth / originalCropImage.naturalHeight;
                resetCropSelection();
            } else if (selectedValue === 'custom') {
                // Custom ratio will be applied after user input
                cropData.aspectRatio = null;
            }
        });

        // Custom ratio input change
        cropElements.customRatioX.addEventListener('input', updateCustomRatio);
        cropElements.customRatioY.addEventListener('input', updateCustomRatio);

        // Crop size input change
        cropElements.cropWidth.addEventListener('input', () => {
            let width = parseInt(cropElements.cropWidth.value) || 0;
            if (cropData.aspectRatio && !isNaN(cropData.aspectRatio)) {
                cropData.width = width;
                cropData.height = width / cropData.aspectRatio;
                cropElements.cropHeight.value = Math.round(cropData.height);
            } else {
                cropData.width = width;
            }
            constrainCropSize();
            updateCropSelection();
        });

        cropElements.cropHeight.addEventListener('input', () => {
            let height = parseInt(cropElements.cropHeight.value) || 0;
            if (cropData.aspectRatio && !isNaN(cropData.aspectRatio)) {
                cropData.height = height;
                cropData.width = height * cropData.aspectRatio;
                cropElements.cropWidth.value = Math.round(cropData.width);
            } else {
                cropData.height = height;
            }
            constrainCropSize();
            updateCropSelection();
        });

        // Crop position input change
        cropElements.cropPositionX.addEventListener('input', () => {
            cropData.x = parseInt(cropElements.cropPositionX.value) || 0;
            constrainCropPosition();
            updateCropSelection();
        });

        cropElements.cropPositionY.addEventListener('input', () => {
            cropData.y = parseInt(cropElements.cropPositionY.value) || 0;
            constrainCropPosition();
            updateCropSelection();
        });

        // Apply crop
        cropElements.applyCropBtn.addEventListener('click', applyCrop);

        // Reset Crop
        cropElements.resetCropBtn.addEventListener('click', resetCropSelection);

        // Set crop selection area event listener
        setupCropSelectionEvents();
    }

    // Update custom ratio
    function updateCustomRatio() {
        const x = parseInt(cropElements.customRatioX.value) || 1;
        const y = parseInt(cropElements.customRatioY.value) || 1;
        cropData.aspectRatio = x / y;
        resetCropSelection();
    }

    // Set crop selection area event listener
    function setupCropSelectionEvents() {
        // Crop area dragging - Only triggers inside crop box area (not on borders and handles)
        cropElements.cropSelection.addEventListener('mousedown', (e) => {
            // Check if click is inside crop box (not on borders and handles)
            const isOnHandle = e.target.classList.contains('crop-handle');
            const isOnBorder = e.target.classList.contains('crop-selection-top') || 
                              e.target.classList.contains('crop-selection-bottom') ||
                              e.target.classList.contains('crop-selection-left') ||
                              e.target.classList.contains('crop-selection-right');
            
            if (!isOnHandle && !isOnBorder) {
                startDrag(e);
            }
        });
        document.addEventListener('mousemove', drag);
        document.addEventListener('mouseup', stopDrag);

        // Resize Handle Events
        const handles = cropElements.cropSelection.querySelectorAll('.crop-handle');
        handles.forEach(handle => {
            handle.addEventListener('mousedown', (e) => {
                e.stopPropagation(); // Prevent event propagation
                startResize(e, handle);
            });
        });
        
        // Resize border event - Top border
        const topBorder = cropElements.cropSelection.querySelector('.crop-selection-top');
        if (topBorder) {
            topBorder.addEventListener('mousedown', (e) => {
                e.stopPropagation(); // Prevent event propagation
                // Create a virtual middle top handle
                const fakeHandle = document.createElement('div');
                fakeHandle.className = 'crop-handle top-middle';
                startResize(e, fakeHandle);
            });
        }
        
        // Resize border event - Bottom border
        const bottomBorder = cropElements.cropSelection.querySelector('.crop-selection-bottom');
        if (bottomBorder) {
            bottomBorder.addEventListener('mousedown', (e) => {
                e.stopPropagation(); // Prevent event propagation
                // Create a virtual middle bottom handle
                const fakeHandle = document.createElement('div');
                fakeHandle.className = 'crop-handle bottom-middle';
                startResize(e, fakeHandle);
            });
        }
        
        // Resize border event - Left border
        const leftBorder = cropElements.cropSelection.querySelector('.crop-selection-left');
        if (leftBorder) {
            leftBorder.addEventListener('mousedown', (e) => {
                e.stopPropagation(); // Prevent event propagation
                // Create a virtual middle left handle
                const fakeHandle = document.createElement('div');
                fakeHandle.className = 'crop-handle middle-left';
                startResize(e, fakeHandle);
            });
        }
        
        // Resize border event - Right border
        const rightBorder = cropElements.cropSelection.querySelector('.crop-selection-right');
        if (rightBorder) {
            rightBorder.addEventListener('mousedown', (e) => {
                e.stopPropagation(); // Prevent event propagation
                // Create a virtual middle right handle
                const fakeHandle = document.createElement('div');
                fakeHandle.className = 'crop-handle middle-right';
                startResize(e, fakeHandle);
            });
        }
    }

    // Start dragging
    function startDrag(e) {
        // Only trigger dragging when clicking on crop box itself or grid, not on borders and handles
        const isOnHandle = e.target.classList.contains('crop-handle');
        const isOnBorder = e.target.classList.contains('crop-selection-top') || 
                          e.target.classList.contains('crop-selection-bottom') ||
                          e.target.classList.contains('crop-selection-left') ||
                          e.target.classList.contains('crop-selection-right');
        
        // Check if click is inside crop box (but not on control points or borders)
        const isOnCropSelection = e.target === cropElements.cropSelection || 
                                 e.target.classList.contains('crop-grid') ||
                                 cropElements.cropSelection.contains(e.target);
        
        if (isOnCropSelection && !isOnHandle && !isOnBorder) {
            isDragging = true;
            startX = e.clientX;
            startY = e.clientY;
            startCropX = cropData.x;
            startCropY = cropData.y;
            cropElements.cropSelection.style.cursor = 'grabbing';
            e.preventDefault();
        }
    }

    // During dragging
    function drag(e) {
        if (isDragging) {
            const dx = (e.clientX - startX) / cropData.scale;
            const dy = (e.clientY - startY) / cropData.scale;

            // Calculate new position
            let newX = startCropX + dx;
            let newY = startCropY + dy;
            
            // Ensure crop box is completely within image bounds
            const imageWidth = cropData.imageNaturalWidth;
            const imageHeight = cropData.imageNaturalHeight;
            
            // Limit top-left corner
            newX = Math.max(0, newX);
            newY = Math.max(0, newY);
            
            // Limit bottom-right corner
            newX = Math.min(newX, imageWidth - cropData.width);
            newY = Math.min(newY, imageHeight - cropData.height);
            
            // Update crop data
            cropData.x = newX;
            cropData.y = newY;

            // Save crop state to current image
            if (currentCropImageIndex !== -1 && currentCropImageIndex < uploadedImages.length) {
                const imageInfo = uploadedImages[currentCropImageIndex];
                imageInfo.cropData.x = cropData.x;
                imageInfo.cropData.y = cropData.y;
            }

            // Update UI
            updateCropSelection();
            updateCropPositionInputs();
        } else if (isResizing && resizeHandle) {
            resizeCrop(e);
        }
    }

    // Stop dragging
    function stopDrag() {
        isDragging = false;
        isResizing = false;
        resizeHandle = null;
        cropElements.cropSelection.style.cursor = 'move';
    }

    // Start resizing
    function startResize(e, handle) {
        isResizing = true;
        resizeHandle = handle;
        startX = e.clientX;
        startY = e.clientY;
        startCropX = cropData.x;
        startCropY = cropData.y;
        startCropWidth = cropData.width;
        startCropHeight = cropData.height;
        e.preventDefault();
    }

    // Resize logic (corrected)
    function resizeCrop(e) {
        const dx = (e.clientX - startX) / cropData.scale;
        const dy = (e.clientY - startY) / cropData.scale;

        // Reset crop data to initial state
        cropData.x = startCropX;
        cropData.y = startCropY;
        cropData.width = startCropWidth;
        cropData.height = startCropHeight;

        // Only apply correction logic when not in free ratio (exclude free ratio)
        const isFixedRatio = cropData.aspectRatio && !isNaN(cropData.aspectRatio);
        const EDGE_TOLERANCE = 1; // Edge tolerance (pixels)
        let isHitTopOrBottomEdge = false; // Mark if top/bottom edges touched (for subsequent ratio validation)

        switch (resizeHandle.className) {
            // -------------------------- Corner Handles (Solving Issue ①) --------------------------
            case 'crop-handle bottom-right':
                if (isFixedRatio) {
                    const fixedLeft = startCropX;
                    const fixedTop = startCropY;
                    const maxWidth = cropData.imageNaturalWidth - fixedLeft;
                    const maxHeight = cropData.imageNaturalHeight - fixedTop;
                    
                    let newWidth = Math.min(maxWidth, startCropWidth + dx);
                    let newHeight = Math.min(maxHeight, startCropHeight + dy);
                    newWidth = Math.max(10, newWidth);
                    newHeight = Math.max(10, newHeight);

                    const hitRightEdge = newWidth >= maxWidth - EDGE_TOLERANCE;
                    const hitBottomEdge = newHeight >= maxHeight - EDGE_TOLERANCE;
                    isHitTopOrBottomEdge = hitBottomEdge; // Mark bottom edge touched

                    if (hitRightEdge) {
                        newWidth = maxWidth; // Force lock width
                        newHeight = newWidth / cropData.aspectRatio;
                        newHeight = Math.min(newHeight, maxHeight);
                    } else if (hitBottomEdge) {
                        newHeight = maxHeight; // Force lock height
                        newWidth = newHeight * cropData.aspectRatio;
                        newWidth = Math.min(newWidth, maxWidth);
                    } else {
                        newHeight = newWidth / cropData.aspectRatio;
                    }

                    cropData.width = newWidth;
                    cropData.height = newHeight;
                } else {
                    cropData.width = Math.min(cropData.imageNaturalWidth - startCropX, startCropWidth + dx);
                    cropData.height = Math.min(cropData.imageNaturalHeight - startCropY, startCropHeight + dy);
                }
                break;

            case 'crop-handle bottom-left':
                if (isFixedRatio) {
                    const fixedRight = startCropX + startCropWidth;
                    const fixedTop = startCropY;
                    const maxHeight = cropData.imageNaturalHeight - fixedTop;
                    
                    let newX = Math.max(0, startCropX + dx);
                    let newHeight = Math.min(maxHeight, startCropHeight + dy);
                    newHeight = Math.max(10, newHeight);
                    let newWidth = fixedRight - newX;
                    newWidth = Math.max(10, newWidth);

                    const hitLeftEdge = newX <= EDGE_TOLERANCE;
                    const hitBottomEdge = newHeight >= maxHeight - EDGE_TOLERANCE;
                    isHitTopOrBottomEdge = hitBottomEdge;

                    if (hitLeftEdge) {
                        newX = 0;
                        newWidth = fixedRight - newX;
                        newHeight = newWidth / cropData.aspectRatio;
                        newHeight = Math.min(newHeight, maxHeight);
                    } else if (hitBottomEdge) {
                        newHeight = maxHeight; // Force lock height
                        newWidth = newHeight * cropData.aspectRatio;
                        newX = fixedRight - newWidth;
                        newX = Math.max(0, newX);
                    } else {
                        newHeight = newWidth / cropData.aspectRatio;
                    }

                    cropData.x = newX;
                    cropData.width = newWidth;
                    cropData.height = newHeight;
                } else {
                    cropData.x = Math.max(0, startCropX + dx);
                    cropData.width = Math.max(10, startCropX + startCropWidth - cropData.x);
                    cropData.height = Math.min(cropData.imageNaturalHeight - startCropY, startCropHeight + dy);
                }
                break;

            case 'crop-handle top-left':
                if (isFixedRatio) {
                    const fixedRight = startCropX + startCropWidth;
                    const fixedBottom = startCropY + startCropHeight;
                    const minY = 0;
                    
                    let newX = Math.max(0, startCropX + dx);
                    let newY = Math.max(minY, startCropY + dy);
                    let newWidth = fixedRight - newX;
                    let newHeight = fixedBottom - newY;
                    newWidth = Math.max(10, newWidth);
                    newHeight = Math.max(10, newHeight);

                    const hitLeftEdge = newX <= EDGE_TOLERANCE;
                    const hitTopEdge = newY <= EDGE_TOLERANCE;
                    isHitTopOrBottomEdge = hitTopEdge; // Mark top edge touched

                    if (hitLeftEdge) {
                        newX = 0;
                        newWidth = fixedRight - newX;
                        newHeight = newWidth / cropData.aspectRatio;
                        newY = fixedBottom - newHeight;
                        newY = Math.max(minY, newY);
                    } else if (hitTopEdge) {
                        newY = minY; // Force lock y coordinate (top edge)
                        newHeight = fixedBottom - newY;
                        newWidth = newHeight * cropData.aspectRatio;
                        newX = fixedRight - newWidth;
                        newX = Math.max(0, newX);
                    } else {
                        newHeight = newWidth / cropData.aspectRatio;
                        newY = fixedBottom - newHeight;
                    }

                    cropData.x = newX;
                    cropData.y = newY;
                    cropData.width = newWidth;
                    cropData.height = newHeight;
                } else {
                    cropData.x = Math.max(0, startCropX + dx);
                    cropData.y = Math.max(0, startCropY + dy);
                    cropData.width = Math.max(10, startCropX + startCropWidth - cropData.x);
                    cropData.height = Math.max(10, startCropY + startCropHeight - cropData.y);
                }
                break;

            case 'crop-handle top-right':
                if (isFixedRatio) {
                    const fixedLeft = startCropX;
                    const fixedBottom = startCropY + startCropHeight;
                    const minY = 0;
                    
                    let newY = Math.max(minY, startCropY + dy);
                    let newWidth = Math.min(cropData.imageNaturalWidth - fixedLeft, startCropWidth + dx);
                    newWidth = Math.max(10, newWidth);
                    let newHeight = fixedBottom - newY;
                    newHeight = Math.max(10, newHeight);

                    const hitRightEdge = newWidth >= (cropData.imageNaturalWidth - fixedLeft) - EDGE_TOLERANCE;
                    const hitTopEdge = newY <= EDGE_TOLERANCE;
                    isHitTopOrBottomEdge = hitTopEdge;

                    if (hitRightEdge) {
                        newWidth = cropData.imageNaturalWidth - fixedLeft;
                        newHeight = newWidth / cropData.aspectRatio;
                        newY = fixedBottom - newHeight;
                        newY = Math.max(minY, newY);
                    } else if (hitTopEdge) {
                        newY = minY; // Force lock y coordinate (top edge)
                        newHeight = fixedBottom - newY;
                        newWidth = newHeight * cropData.aspectRatio;
                        newWidth = Math.min(newWidth, cropData.imageNaturalWidth - fixedLeft);
                    } else {
                        newHeight = newWidth / cropData.aspectRatio;
                        newY = fixedBottom - newHeight;
                    }

                    cropData.y = newY;
                    cropData.width = newWidth;
                    cropData.height = newHeight;
                } else {
                    cropData.y = Math.max(0, startCropY + dy);
                    cropData.width = Math.min(cropData.imageNaturalWidth - startCropX, startCropWidth + dx);
                    cropData.height = Math.max(10, startCropY + startCropHeight - cropData.y);
                }
                break;
            // -------------------------- Middle Handles (Solving Issue ②) --------------------------
            case 'crop-handle middle-left':
                if (isFixedRatio) {
                    const fixedRight = startCropX + startCropWidth; // Right position remains unchanged
                    let newX = Math.max(0, startCropX + dx); // Left x coordinate (drag adjustment)
                    let newWidth = fixedRight - newX; // New width = Right fixed point - New x
                    newWidth = Math.max(10, newWidth);

                    // Calculate new height based on aspect ratio
                    let newHeight = newWidth / cropData.aspectRatio;
                    // Keep vertical center unchanged (adjust y)
                    const centerY = startCropY + startCropHeight / 2;
                    let newY = centerY - newHeight / 2;

                    // Restrict within image range
                    newY = Math.max(0, newY);
                    newHeight = Math.min(newHeight, cropData.imageNaturalHeight - newY);

                    cropData.x = newX;
                    cropData.y = newY;
                    cropData.width = newWidth;
                    cropData.height = newHeight;
                } else {
                    cropData.x = Math.max(0, startCropX + dx);
                    cropData.width = Math.max(10, startCropX + startCropWidth - cropData.x);
                }
                break;

            case 'crop-handle middle-right':
                if (isFixedRatio) {
                    const fixedLeft = startCropX; // Left position remains unchanged
                    let newWidth = Math.min(cropData.imageNaturalWidth - fixedLeft, startCropWidth + dx); // Drag to adjust width
                    newWidth = Math.max(10, newWidth);

                    // Calculate new height based on aspect ratio
                    let newHeight = newWidth / cropData.aspectRatio;
                    // Keep vertical center unchanged
                    const centerY = startCropY + startCropHeight / 2;
                    let newY = centerY - newHeight / 2;

                    // Restrict within image range
                    newY = Math.max(0, newY);
                    newHeight = Math.min(newHeight, cropData.imageNaturalHeight - newY);

                    cropData.y = newY;
                    cropData.width = newWidth;
                    cropData.height = newHeight;
                } else {
                    cropData.width = Math.min(cropData.imageNaturalWidth - startCropX, startCropWidth + dx);
                }
                break;

            case 'crop-handle top-middle':
                if (isFixedRatio) {
                    const fixedBottom = startCropY + startCropHeight; // Bottom position remains unchanged
                    let newY = Math.max(0, startCropY + dy); // Top y coordinate (drag adjustment)
                    let newHeight = fixedBottom - newY; // New height = Bottom fixed point - New y
                    newHeight = Math.max(10, newHeight);

                    // Calculate new width based on aspect ratio
                    let newWidth = newHeight * cropData.aspectRatio;
                    // Keep horizontal center unchanged
                    const centerX = startCropX + startCropWidth / 2;
                    let newX = centerX - newWidth / 2;

                    // Restrict within image range
                    newX = Math.max(0, newX);
                    newWidth = Math.min(newWidth, cropData.imageNaturalWidth - newX);

                    cropData.x = newX;
                    cropData.y = newY;
                    cropData.width = newWidth;
                    cropData.height = newHeight;
                } else {
                    cropData.y = Math.max(0, startCropY + dy);
                    cropData.height = Math.max(10, startCropY + startCropHeight - cropData.y);
                }
                break;

            case 'crop-handle bottom-middle':
                if (isFixedRatio) {
                    const fixedTop = startCropY; // Top position remains unchanged
                    let newHeight = Math.min(cropData.imageNaturalHeight - fixedTop, startCropHeight + dy); // Drag to adjust height
                    newHeight = Math.max(10, newHeight);

                    // Calculate new width based on aspect ratio
                    let newWidth = newHeight * cropData.aspectRatio;
                    // Keep horizontal center unchanged
                    const centerX = startCropX + startCropWidth / 2;
                    let newX = centerX - newWidth / 2;

                    // Restrict within image range
                    newX = Math.max(0, newX);
                    newWidth = Math.min(newWidth, cropData.imageNaturalWidth - newX);

                    cropData.x = newX;
                    cropData.width = newWidth;
                    cropData.height = newHeight;
                } else {
                    cropData.height = Math.min(cropData.imageNaturalHeight - startCropY, startCropHeight + dy);
                }
                break;
        }

        // Ratio validation: Only execute when not touching top/bottom edges (avoid breaking lock)
        if (isFixedRatio && !isHitTopOrBottomEdge) {
            const targetHeight = cropData.width / cropData.aspectRatio;
            if (Math.abs(cropData.height - targetHeight) > 0.5) {
                cropData.height = targetHeight;
                if (['top-left', 'top-right', 'top-middle'].includes(resizeHandle.className.split(' ')[1])) {
                    cropData.y = Math.min(cropData.y, cropData.imageNaturalHeight - cropData.height);
                }
            }
        }

        // Boundary constraints
        constrainCropPosition();
        // Update UI
        updateCropSelection();
        updateCropSizeInputs();
        updateCropPositionInputs();
    }

    // Limit crop position within image bounds
    function constrainCropPosition() {
        // Ensure crop box top-left corner is within image bounds
        cropData.x = Math.max(0, cropData.x);
        cropData.y = Math.max(0, cropData.y);
        
        // Ensure crop box bottom-right corner is within image bounds
        cropData.x = Math.min(cropData.x, cropData.imageNaturalWidth - cropData.width);
        cropData.y = Math.min(cropData.y, cropData.imageNaturalHeight - cropData.height);
    }

    // Limit crop size not to exceed image
    function constrainCropSize() {
        // Ensure crop box size is within reasonable range
        cropData.width = Math.max(20, cropData.width);
        cropData.height = Math.max(20, cropData.height);
        
        // Ensure crop box doesn't exceed image boundaries
        cropData.width = Math.min(cropData.width, cropData.imageNaturalWidth);
        cropData.height = Math.min(cropData.height, cropData.imageNaturalHeight);
        
        // Ensure crop box bottom-right corner doesn't exceed image range
        cropData.width = Math.min(cropData.width, cropData.imageNaturalWidth - cropData.x);
        cropData.height = Math.min(cropData.height, cropData.imageNaturalHeight - cropData.y);
        
        // Recheck position to ensure crop box is completely within image bounds
        constrainCropPosition();
    }

    // Update custom ratio
    function updateCustomRatio() {
        const x = parseInt(cropElements.customRatioX.value) || 1;
        const y = parseInt(cropElements.customRatioY.value) || 1;
        if (x > 0 && y > 0) {
            cropData.aspectRatio = x / y;
            resetCropSelection();
        }
    }

    // Update crop selection area display
    function updateCropSelection() {
        // Calculate image offset in container (center display)
        const containerWidth = 540;
        const containerHeight = 610;
        const imageDisplayWidth = cropData.imageNaturalWidth * cropData.scale;
        const imageDisplayHeight = cropData.imageNaturalHeight * cropData.scale;
        const offsetX = (containerWidth - imageDisplayWidth) / 2;
        const offsetY = (containerHeight - imageDisplayHeight) / 2;

        // Apply offset
        cropElements.cropSelection.style.left = `${cropData.x * cropData.scale + offsetX}px`;
        cropElements.cropSelection.style.top = `${cropData.y * cropData.scale + offsetY}px`;
        cropElements.cropSelection.style.width = `${cropData.width * cropData.scale}px`;
        cropElements.cropSelection.style.height = `${cropData.height * cropData.scale}px`;
    }

    // Update crop size input boxes
    function updateCropSizeInputs() {
        cropElements.cropWidth.value = Math.round(cropData.width);
        cropElements.cropHeight.value = Math.round(cropData.height);
    }

    // Update crop position input boxes
    function updateCropPositionInputs() {
        cropElements.cropPositionX.value = Math.round(cropData.x);
        cropElements.cropPositionY.value = Math.round(cropData.y);
    }

    // Reset crop selection
    function resetCropSelection() {
        // Default crop area is the middle half of the image
        if (cropData.aspectRatio && !isNaN(cropData.aspectRatio)) {
            // Calculate by Ratio
            if (cropData.aspectRatio > cropData.imageNaturalWidth / cropData.imageNaturalHeight) {
                // Wide image
                cropData.width = cropData.imageNaturalWidth / 2;
                cropData.height = cropData.width / cropData.aspectRatio;
            } else {
                // Tall image
                cropData.height = cropData.imageNaturalHeight / 2;
                cropData.width = cropData.height * cropData.aspectRatio;
            }
        } else {
            // Free ratio
            cropData.width = cropData.imageNaturalWidth / 2;
            cropData.height = cropData.imageNaturalHeight / 2;
        }

        // Center display
        cropData.x = (cropData.imageNaturalWidth - cropData.width) / 2;
        cropData.y = (cropData.imageNaturalHeight - cropData.height) / 2;

        // Ensure Crop Box is Within Image Range
        constrainCropSize();
        constrainCropPosition();

        // Save crop state to current image
        if (currentCropImageIndex !== -1 && currentCropImageIndex < uploadedImages.length) {
            const imageInfo = uploadedImages[currentCropImageIndex];
            imageInfo.cropData.x = cropData.x;
            imageInfo.cropData.y = cropData.y;
            imageInfo.cropData.width = cropData.width;
            imageInfo.cropData.height = cropData.height;
            imageInfo.cropData.aspectRatio = cropData.aspectRatio;
            imageInfo.cropData.scale = cropData.scale;
        }

        // Update UI
        updateCropSelection();
        updateCropSizeInputs();
        updateCropPositionInputs();
    }

    // Open crop modal
    function openCropModal(index) {
        if (index < 0 || index >= uploadedImages.length) return;

        currentCropImageIndex = index;
        const imageInfo = uploadedImages[index];

        // Load crop data from image's independent state
        cropData.x = imageInfo.cropData.x;
        cropData.y = imageInfo.cropData.y;
        cropData.width = imageInfo.cropData.width;
        cropData.height = imageInfo.cropData.height;
        cropData.aspectRatio = imageInfo.cropData.aspectRatio;
        cropData.scale = imageInfo.cropData.scale;

        // Control navigation button display
        if (uploadedImages.length <= 1) {
            cropElements.cropModalNavigation.style.display = 'none';
        } else {
            cropElements.cropModalNavigation.style.display = 'flex';
        }

        // Load original image
        originalCropImage = new Image();
        originalCropImage.src = imageInfo.src;

        originalCropImage.onload = () => {
            // Set crop image source
            cropElements.cropImage.src = imageInfo.src;
            cropData.imageNaturalWidth = originalCropImage.naturalWidth;
            cropData.imageNaturalHeight = originalCropImage.naturalHeight;

            // Calculate image scaling ratio - Ensure image fills entire container
            const containerWidth = 540;
            const containerHeight = 610;
            const imageRatio = cropData.imageNaturalWidth / cropData.imageNaturalHeight;
            const containerRatio = containerWidth / containerHeight;

            if (imageRatio > containerRatio) {
                // Image is wider, scale by width to fill container
                cropData.scale = containerWidth / cropData.imageNaturalWidth;
            } else {
                // Image is taller, scale by height to fill container
                cropData.scale = containerHeight / cropData.imageNaturalHeight;
            }
            
            // Ensure image always fills entire container regardless of original size
            // Remove scaling ratio limits, allow image to be enlarged or reduced
            
            // Apply scaling ratio to image, combined with centering effect
            cropElements.cropImage.style.transform = `translate(-50%, -50%) scale(${cropData.scale})`;

            // Set default crop area
            cropElements.aspectRatioSelect.value = 'free';
            cropElements.customRatioGroup.style.display = 'none';
            resetCropSelection();

            // Update URL for crop functionality
            updateUrlForCrop();

            // Show crop window
            cropElements.cropModal.classList.add('show');
        };
    }

    // Apply crop
    function applyCrop() {
        if (currentCropImageIndex === -1 || !originalCropImage) return;

        // Create canvas for cropping
        const canvas = document.createElement('canvas');
        const ctx = canvas.getContext('2d');

        // Set canvas size
        canvas.width = cropData.width;
        canvas.height = cropData.height;

        // Draw crop area
        ctx.drawImage(
            originalCropImage,
            cropData.x, cropData.y, cropData.width, cropData.height,
            0, 0, canvas.width, canvas.height
        );

        // Convert cropped image to dataURL
        const dataUrl = canvas.toDataURL('image/png', 1.0);

        // Update image data
        const img = new Image();
        img.onload = () => {
            // Save current crop state to image's independent state
            uploadedImages[currentCropImageIndex] = {
                ...uploadedImages[currentCropImageIndex],
                src: dataUrl,
                originalWidth: img.width,
                originalHeight: img.height,
                aspectRatio: img.width / img.height,
                // Save Crop State
                cropData: {
                    x: 0,
                    y: 0,
                    width: img.width,
                    height: img.height,
                    aspectRatio: null,
                    scale: 1
                },
                // Reset rotation flip state
                rotateFlipData: {
                    rotation: 0,
                    flipX: false,
                    flipY: false
                }
            };

            // Update input boxes with cropped dimensions
            elements.widthInputDim.value = img.width;
            elements.heightInputDim.value = img.height;
            elements.widthInputSocial.value = img.width;
            elements.heightInputSocial.value = img.height;
            
            // Update current pixel dimensions
            currentPixelWidth = img.width;
            currentPixelHeight = img.height;

            // Update display
            renderImages();

            // Close crop window
            cropElements.cropModal.classList.remove('show');
        };
        img.src = dataUrl;
    }

    // Set rotation and flip functionality
    function setupRotateFlipFunctionality() {
        setupCropFunctionality(); // Initialize crop functionality
        // Close rotation and flip window
        elements.closeRotateFlipBtn.addEventListener('click', () => {
            elements.rotateFlipModal.classList.remove('show');
        });
        
        // Previous/next image navigation
        elements.prevImageRotateBtn.addEventListener('click', () => {
            if (uploadedImages.length <= 1) return;
            
            currentRotateFlipImageIndex = (currentRotateFlipImageIndex - 1 + uploadedImages.length) % uploadedImages.length;
            openRotateFlipModal(currentRotateFlipImageIndex);
        });
        
        elements.nextImageRotateBtn.addEventListener('click', () => {
            if (uploadedImages.length <= 1) return;
            
            currentRotateFlipImageIndex = (currentRotateFlipImageIndex + 1) % uploadedImages.length;
            openRotateFlipModal(currentRotateFlipImageIndex);
        });
        
        // Rotate clockwise
        elements.rotateClockwiseBtn.addEventListener('click', () => {
            rotateFlipData.rotation = (rotateFlipData.rotation + 90) % 360;
            updateRotateFlipPreview();
            updateUrlForRotateClockwise();
        });
        
        // Rotate counter clockwise
        elements.rotateCounterclockwiseBtn.addEventListener('click', () => {
            rotateFlipData.rotation = (rotateFlipData.rotation - 90 + 360) % 360;
            updateRotateFlipPreview();
            updateUrlForRotateCounterClockwise();
        });
        
        // Horizontal flip
        elements.flipHorizontalBtn.addEventListener('click', () => {
            rotateFlipData.flipX = !rotateFlipData.flipX;
            updateRotateFlipPreview();
            updateUrlForFlipHorizontal();
        });
        
        // Vertical flip
        elements.flipVerticalBtn.addEventListener('click', () => {
            rotateFlipData.flipY = !rotateFlipData.flipY;
            updateRotateFlipPreview();
            updateUrlForFlipVertical();
        });
        
        // Apply rotation and flip
        elements.applyRotateFlipBtn.addEventListener('click', () => {
            applyRotateFlip();
        });
        
        // Reset rotation and flip
        elements.resetRotateFlipBtn.addEventListener('click', () => {
            resetRotateFlip();
        });
    }

    // Open rotation and flip window
    function openRotateFlipModal(index) {
        if (index < 0 || index >= uploadedImages.length) return;
        
        currentRotateFlipImageIndex = index;
        const imageInfo = uploadedImages[index];
        
        // Load rotation flip data from image's independent state
        rotateFlipData.rotation = imageInfo.rotateFlipData.rotation;
        rotateFlipData.flipX = imageInfo.rotateFlipData.flipX;
        rotateFlipData.flipY = imageInfo.rotateFlipData.flipY;
        
        // Control navigation button display
        if (uploadedImages.length <= 1) {
            elements.rotateFlipNavigation.style.display = 'none';
        } else {
            elements.rotateFlipNavigation.style.display = 'flex';
        }
        
        // Load original image
        originalRotateFlipImage = new Image();
        originalRotateFlipImage.src = imageInfo.src;
        
        originalRotateFlipImage.onload = () => {
            // Set Rotation and Flip Image Source
            elements.rotateFlipImage.src = imageInfo.src;
            
            // Apply current rotation and flip state
            updateRotateFlipPreview();

            // Show rotation and flip window
            elements.rotateFlipModal.classList.add('show');
        };
    }

    // Reset rotation and flip
    function resetRotateFlip() {
        rotateFlipData = {
            rotation: 0,
            flipX: false,
            flipY: false
        };
        
        if (elements.rotateFlipImage) {
            elements.rotateFlipImage.style.transform = 'none';
        }
    }

    // Update Rotation and Flip Preview
    function updateRotateFlipPreview() {
        if (!originalRotateFlipImage) return;
        
        // Apply rotation and flip transformation
        let transform = `rotate(${rotateFlipData.rotation}deg)`;
        if (rotateFlipData.flipX) {
            transform += ' scaleX(-1)';
        }
        if (rotateFlipData.flipY) {
            transform += ' scaleY(-1)';
        }
        
        elements.rotateFlipImage.style.transform = transform;
    }

    // Apply rotation and flip
    function applyRotateFlip() {
        if (currentRotateFlipImageIndex === -1 || !originalRotateFlipImage) return;
        
        // Create canvas for rotation and flip
        const canvas = document.createElement('canvas');
        const ctx = canvas.getContext('2d');
        
        // Adjust canvas size based on rotation angle
        let canvasWidth, canvasHeight;
        if (rotateFlipData.rotation === 90 || rotateFlipData.rotation === 270) {
            canvasWidth = originalRotateFlipImage.height;
            canvasHeight = originalRotateFlipImage.width;
        } else {
            canvasWidth = originalRotateFlipImage.width;
            canvasHeight = originalRotateFlipImage.height;
        }
        
        canvas.width = canvasWidth;
        canvas.height = canvasHeight;
        
        // Move origin to canvas center
        ctx.translate(canvasWidth / 2, canvasHeight / 2);
        
        // Apply Rotation
        ctx.rotate(rotateFlipData.rotation * Math.PI / 180);
        
        // Apply flip
        if (rotateFlipData.flipX) {
            ctx.scale(-1, 1);
        }
        if (rotateFlipData.flipY) {
            ctx.scale(1, -1);
        }
        
        // Draw Image
        ctx.drawImage(
            originalRotateFlipImage,
            -originalRotateFlipImage.width / 2,
            -originalRotateFlipImage.height / 2
        );
        
        // Convert rotated and flipped image to dataURL
        const dataUrl = canvas.toDataURL('image/png', 1.0);
        
        // Update image data
        const img = new Image();
        img.src = dataUrl;
        img.onload = () => {
            uploadedImages[currentRotateFlipImageIndex] = {
                ...uploadedImages[currentRotateFlipImageIndex],
                src: dataUrl,
                originalWidth: img.width,
                originalHeight: img.height,
                aspectRatio: img.width / img.height,
                // Save rotation flip state
                rotateFlipData: {
                    rotation: 0,
                    flipX: false,
                    flipY: false
                },
                // Reset crop state
                cropData: {
                    x: 0,
                    y: 0,
                    width: img.width,
                    height: img.height,
                    aspectRatio: null,
                    scale: 1
                }
            };
            
            // Update input boxes with rotated dimensions
            elements.widthInputDim.value = img.width;
            elements.heightInputDim.value = img.height;
            elements.widthInputSocial.value = img.width;
            elements.heightInputSocial.value = img.height;
            
            // Update current pixel dimensions
            currentPixelWidth = img.width;
            currentPixelHeight = img.height;
            
            // Update display
            renderImages();
            
            // Close rotation and flip window
            elements.rotateFlipModal.classList.remove('show');
        };
    }




    // Render all images
    function renderImages() {
        elements.imageContainer.innerHTML = '';
        // Reverse array to ensure newly uploaded images appear first
        [...uploadedImages].reverse().forEach((image, reversedIndex) => {
            // Calculate index in original array
            const originalIndex = uploadedImages.length - 1 - reversedIndex;
            addImageToGallery(image, originalIndex);
        });
        updateImageDimensions();
    }

    // Set percentage slider and input box linkage
    function setupPercentageSync() {
        // Update input box when slider changes
        elements.percentageSlider.addEventListener('input', () => {
            const value = elements.percentageSlider.value;
            elements.percentageDisplay.textContent = `${value}%`;
            // Prevent circular triggering
            if (parseInt(elements.percentageInput.value) !== parseInt(value)) {
                elements.percentageInput.value = value;
            }
            updateImageDimensions();
        });

        // Update slider when input box changes
        elements.percentageInput.addEventListener('input', () => {
            let value = parseInt(elements.percentageInput.value);
            // Limit to 10-300 range
            if (isNaN(value)) value = 100;
            if (value < 10) value = 10;
            if (value > 300) value = 300;
            
            elements.percentageInput.value = value;
            elements.percentageDisplay.textContent = `${value}%`;
            
            // Prevent circular triggering
            if (elements.percentageSlider.value !== value.toString()) {
                elements.percentageSlider.value = value;
            }
            updateImageDimensions();
        });

        // Ensure value is within valid range when input box loses focus
        elements.percentageInput.addEventListener('blur', () => {
            let value = parseInt(elements.percentageInput.value);
            if (isNaN(value) || value < 10 || value > 300) {
                value = 100;
                elements.percentageInput.value = value;
                elements.percentageSlider.value = value;
                elements.percentageDisplay.textContent = `${value}%`;
            }
            updateImageDimensions();
        });
    }

    // Handle file upload
    function handleFileUpload(e) {
        const files = e.target.files;
        if (files.length) {
            handleFiles(files);
            // Reset file input to allow re-uploading the same file
            e.target.value = '';
        }
    }

    // Handle files
    function handleFiles(files) {
        // Hide upload prompt, show image container
        elements.uploadPrompt.style.display = 'none';
        elements.imageContainer.style.display = 'flex';
        
        for (let file of files) {
            if (file.type.startsWith('image/')) {
                const reader = new FileReader();
                reader.onload = (e) => {
                    const img = new Image();
                    img.src = e.target.result;
                    img.onload = () => {
                        // Store original image information and independent crop and rotation flip state
                        const imageInfo = {
                            src: img.src,
                            name: file.name,
                            originalWidth: img.width,
                            originalHeight: img.height,
                            file: file,
                            aspectRatio: img.width / img.height, // Store original aspect ratio
                            // Independent crop state for each image
                            cropData: {
                                x: 0,
                                y: 0,
                                width: img.width / 2, // Default to half of image
                                height: img.height / 2,
                                aspectRatio: null,
                                scale: 1
                            },
                            // Independent rotation flip state for each image
                            rotateFlipData: {
                                rotation: 0,
                                flipX: false,
                                flipY: false
                            }
                        };
                        uploadedImages.push(imageInfo);
                        
                        // If first image, auto-fill dimensions
                        if (uploadedImages.length === 1) {
                            currentPixelWidth = img.width;
                            currentPixelHeight = img.height;
                            originalAspectRatio = img.width / img.height;
                            updateDimensionInputsWithFirstImage();
                        }
                        
                        renderImages();
                    };
                };
                reader.readAsDataURL(file);
            }
        }
    }

    // Update input boxes using first image's dimensions
    function updateDimensionInputsWithFirstImage() {
        if (uploadedImages.length === 0) return;
        
        const firstImage = uploadedImages[0];
        
        // Update dimensions tab
        elements.widthInputDim.value = firstImage.originalWidth;
        elements.heightInputDim.value = firstImage.originalHeight;
        
        // Update social media tab
        if (elements.socialPlatformSelect.value === "") {
            elements.widthInputSocial.value = firstImage.originalWidth;
            elements.heightInputSocial.value = firstImage.originalHeight;
        }
    }

    // Add image to gallery
    function addImageToGallery(image, index) {
        const imageItem = document.createElement('div');
        imageItem.className = 'image-item';
        imageItem.dataset.index = index;

        // Image preview container
        const previewContainer = document.createElement('div');
        previewContainer.className = 'image-preview-container';
        
        const imgElement = document.createElement('img');
        imgElement.src = image.src;
        imgElement.alt = image.name;
        
        previewContainer.appendChild(imgElement);

        // Image operation buttons
        const actionsContainer = document.createElement('div');
        actionsContainer.className = 'image-actions';
        
        // Rotate button
        const rotateBtn = document.createElement('button');
        rotateBtn.className = 'image-action-btn rotate-btn';
        rotateBtn.innerHTML = '<i class="fas fa-rotate-right"></i>';
        rotateBtn.title = 'Rotate and Flip';
        rotateBtn.addEventListener('click', () => {
            openRotateFlipModal(index);
        });
        // Add mouse hover event
        rotateBtn.addEventListener('mouseover', (e) => {
            // Create tooltip element
            let tooltip = document.createElement('div');
            tooltip.className = 'custom-tooltip';
            tooltip.textContent = 'Rotate and Flip Image';
            tooltip.style.position = 'absolute';
            tooltip.style.backgroundColor = 'rgba(0, 0, 0, 0.9)';
            tooltip.style.color = 'white';
            tooltip.style.padding = '8px 15px';
            tooltip.style.borderRadius = '3px';
            tooltip.style.fontSize = '14px';
            tooltip.style.height = '56px';
            tooltip.style.display = 'flex';
            tooltip.style.alignItems = 'center';
            tooltip.style.zIndex = '1000';
            tooltip.style.top = `${e.clientY + 10}px`;
            tooltip.style.left = `${e.clientX + 10}px`;
            document.body.appendChild(tooltip);
            // Store tooltip reference
            rotateBtn.tooltip = tooltip;
        });
        // Add mouse out event
        rotateBtn.addEventListener('mouseout', () => {
            if (rotateBtn.tooltip) {
                document.body.removeChild(rotateBtn.tooltip);
                rotateBtn.tooltip = null;
            }
        });
        
        // Info button
        const infoBtn = document.createElement('button');
        infoBtn.className = 'image-action-btn info-btn';
        infoBtn.innerHTML = '<i class="fas fa-info"></i>';
        infoBtn.title = 'Info';
        infoBtn.addEventListener('click', () => {
            // Calculate file size
            const fileSize = image.file.size;
            let sizeText;
            if (fileSize < 1024) {
                sizeText = `${fileSize} B`;
            } else if (fileSize < 1024 * 1024) {
                sizeText = `${(fileSize / 1024).toFixed(2)} KB`;
            } else {
                sizeText = `${(fileSize / (1024 * 1024)).toFixed(2)} MB`;
            }
            alert(`${image.name}\nOriginal Size: ${image.originalWidth} x ${image.originalHeight} px\nFile Size: ${sizeText}`);
        });
        // Add mouse hover event
        infoBtn.addEventListener('mouseover', (e) => {
            // Calculate file size
            const fileSize = image.file.size;
            let sizeText;
            if (fileSize < 1024) {
                sizeText = `${fileSize} B`;
            } else if (fileSize < 1024 * 1024) {
                sizeText = `${(fileSize / 1024).toFixed(2)} KB`;
            } else {
                sizeText = `${(fileSize / (1024 * 1024)).toFixed(2)} MB`;
            }
            // Create tooltip element
            let tooltip = document.createElement('div');
            tooltip.className = 'custom-tooltip';
            tooltip.innerHTML = `${image.name}<br>Original Size: ${image.originalWidth} x ${image.originalHeight} px<br>File Size: ${sizeText}`;
            tooltip.style.position = 'absolute';
            tooltip.style.backgroundColor = 'rgba(0, 0, 0, 0.9)';
            tooltip.style.color = 'white';
            tooltip.style.padding = '8px 15px';
            tooltip.style.borderRadius = '3px';
            tooltip.style.fontSize = '14px';
            tooltip.style.zIndex = '1000';
            tooltip.style.top = `${e.clientY + 10}px`;
            tooltip.style.left = `${e.clientX + 10}px`;
            tooltip.style.whiteSpace = 'pre-line';
            document.body.appendChild(tooltip);
            // Store tooltip reference
            infoBtn.tooltip = tooltip;
        });
        // Add mouse out event
        infoBtn.addEventListener('mouseout', () => {
            if (infoBtn.tooltip) {
                document.body.removeChild(infoBtn.tooltip);
                infoBtn.tooltip = null;
            }
        });
        
        // Crop button
        const cropBtn = document.createElement('button');
        cropBtn.className = 'image-action-btn crop-btn';
        cropBtn.innerHTML = '<i class="fas fa-crop"></i>';
        cropBtn.title = 'Crop Image';
        cropBtn.addEventListener('click', () => {
            openCropModal(index);
        });
        // Add mouse hover event
        cropBtn.addEventListener('mouseover', (e) => {
            // Create tooltip element
            let tooltip = document.createElement('div');
            tooltip.className = 'custom-tooltip';
            tooltip.textContent = 'Crop Image';
            tooltip.style.position = 'absolute';
            tooltip.style.backgroundColor = 'rgba(0, 0, 0, 0.9)';
            tooltip.style.color = 'white';
            tooltip.style.padding = '8px 15px';
            tooltip.style.borderRadius = '3px';
            tooltip.style.fontSize = '14px';
            tooltip.style.height = '56px';
            tooltip.style.display = 'flex';
            tooltip.style.alignItems = 'center';
            tooltip.style.zIndex = '1000';
            tooltip.style.top = `${e.clientY + 10}px`;
            tooltip.style.left = `${e.clientX + 10}px`;
            document.body.appendChild(tooltip);
            // Store tooltip reference
            cropBtn.tooltip = tooltip;
        });
        // Add mouse out event
        cropBtn.addEventListener('mouseout', () => {
            if (cropBtn.tooltip) {
                document.body.removeChild(cropBtn.tooltip);
                cropBtn.tooltip = null;
            }
        });
        
        // Delete button
        const deleteBtn = document.createElement('button');
        deleteBtn.className = 'image-action-btn delete-img-btn';
        deleteBtn.innerHTML = '<i class="fas fa-trash"></i>';
        deleteBtn.title = 'Delete Image';
        deleteBtn.addEventListener('click', () => {
            imageToDelete = index;
            elements.deleteImageModal.classList.add('show');
        });
        // Add mouse hover event
        deleteBtn.addEventListener('mouseover', (e) => {
            // Create tooltip element
            let tooltip = document.createElement('div');
            tooltip.className = 'custom-tooltip';
            tooltip.textContent = 'Delete Image';
            tooltip.style.position = 'absolute';
            tooltip.style.backgroundColor = 'rgba(0, 0, 0, 0.9)';
            tooltip.style.color = 'white';
            tooltip.style.padding = '8px 15px';
            tooltip.style.borderRadius = '3px';
            tooltip.style.fontSize = '14px';
            tooltip.style.height = '56px';
            tooltip.style.display = 'flex';
            tooltip.style.alignItems = 'center';
            tooltip.style.zIndex = '1000';
            tooltip.style.top = `${e.clientY + 10}px`;
            tooltip.style.left = `${e.clientX + 10}px`;
            document.body.appendChild(tooltip);
            // Store tooltip reference
            deleteBtn.tooltip = tooltip;
        });
        // Add mouse out event
        deleteBtn.addEventListener('mouseout', () => {
            if (deleteBtn.tooltip) {
                document.body.removeChild(deleteBtn.tooltip);
                deleteBtn.tooltip = null;
            }
        });
        
        actionsContainer.appendChild(rotateBtn);
        actionsContainer.appendChild(cropBtn);
        actionsContainer.appendChild(infoBtn);
        actionsContainer.appendChild(deleteBtn);

        // Image info
        const imageInfo = document.createElement('div');
        imageInfo.className = 'image-info';
        
        // Truncate image name to 15 characters, add ellipsis and keep file extension
        const originalName = image.name;
        const nameParts = originalName.split('.');
        const extension = nameParts.length > 1 ? nameParts.pop() : '';
        const baseName = nameParts.join('.');
        let truncatedName = baseName;
        if (baseName.length > 15) {
            truncatedName = baseName.substring(0, 15) + '...';
        }
        const displayName = extension ? `${truncatedName}.${extension}` : truncatedName;
        
        const imageName = document.createElement('div');
        imageName.className = 'image-name';
        imageName.textContent = displayName;
        
        imageInfo.appendChild(imageName);

        // Image metadata container with size and dimensions
        const imageMeta = document.createElement('div');
        imageMeta.className = 'image-meta';
        imageMeta.style.display = 'flex';
        imageMeta.style.justifyContent = 'space-between';
        imageMeta.style.alignItems = 'center';
        
        // Calculate file size
        const fileSize = image.file.size;
        let sizeText;
        if (fileSize < 1024) {
            sizeText = `${fileSize} B`;
        } else if (fileSize < 1024 * 1024) {
            sizeText = `${(fileSize / 1024).toFixed(2)} KB`;
        } else {
            sizeText = `${(fileSize / (1024 * 1024)).toFixed(2)} MB`;
        }
        
        // File size (left aligned)
        const fileSizeElement = document.createElement('span');
        fileSizeElement.style.textAlign = 'left';
        fileSizeElement.textContent = sizeText;
        
        // Image dimensions (right aligned)
        const imageSize = document.createElement('span');
        imageSize.style.textAlign = 'right';
        // Display the resized dimensions instead of original dimensions
        imageSize.textContent = `${currentPixelWidth} × ${currentPixelHeight} px`;
        
        imageMeta.appendChild(fileSizeElement);
        imageMeta.appendChild(imageSize);

        imageItem.appendChild(previewContainer);
        imageItem.appendChild(actionsContainer);
        imageItem.appendChild(imageInfo);
        imageItem.appendChild(imageMeta);

        elements.imageContainer.appendChild(imageItem);
    }

    // Sync all dimension inputs based on current pixel dimensions
    function syncAllDimensions() {
        if (uploadedImages.length === 0) return;
        
        const baseImage = uploadedImages[0];
        const percentage = (currentPixelWidth / baseImage.originalWidth) * 100;
        
        // Update dimensions tab
        if (parseInt(elements.widthInputDim.value) !== currentPixelWidth) {
            elements.widthInputDim.value = currentPixelWidth;
        }
        if (parseInt(elements.heightInputDim.value) !== currentPixelHeight) {
            elements.heightInputDim.value = currentPixelHeight;
        }
        
        // Update percentage tab
        const percentageValue = Math.round(percentage);
        if (parseInt(elements.percentageInput.value) !== percentageValue) {
            elements.percentageInput.value = percentageValue;
        }
        if (parseInt(elements.percentageSlider.value) !== percentageValue) {
            elements.percentageSlider.value = percentageValue;
        }
        elements.percentageDisplay.textContent = `${percentageValue}%`;
        
        // Update social media tab if no specific preset is selected
        if (!currentSocialPreset) {
            if (parseInt(elements.widthInputSocial.value) !== currentPixelWidth) {
                elements.widthInputSocial.value = currentPixelWidth;
            }
            if (parseInt(elements.heightInputSocial.value) !== currentPixelHeight) {
                elements.heightInputSocial.value = currentPixelHeight;
            }
        }
    }
    
    // Update image dimensions and sync across all tabs
    function updateImageDimensions() {
        // Update current pixel dimensions based on current tab
        if (currentTab === 'dimensions') {
            // Update by dimensions tab
            const widthValue = parseFloat(elements.widthInputDim.value);
            const heightValue = parseFloat(elements.heightInputDim.value);
            
            if (!isNaN(widthValue) && !isNaN(heightValue) && widthValue > 0 && heightValue > 0) {
                currentPixelWidth = widthValue;
                currentPixelHeight = heightValue;
            }
        } else if (currentTab === 'percentage') {
            // Update percentage tab
            const percentageValue = parseFloat(elements.percentageInput.value);
            
            if (!isNaN(percentageValue) && uploadedImages.length > 0) {
                const baseImage = uploadedImages[0];
                const percentage = percentageValue / 100;
                
                currentPixelWidth = Math.round(baseImage.originalWidth * percentage);
                currentPixelHeight = Math.round(baseImage.originalHeight * percentage);
            }
        } else if (currentTab === 'social') {
            // Update social media tab
            const widthValue = parseFloat(elements.widthInputSocial.value);
            const heightValue = parseFloat(elements.heightInputSocial.value);
            
            if (!isNaN(widthValue) && !isNaN(heightValue) && widthValue > 0 && heightValue > 0) {
                currentPixelWidth = widthValue;
                currentPixelHeight = heightValue;
            }
        }
        
        // Sync all dimensions after updating current pixel dimensions
        syncAllDimensions();
        
        // Update image size display in gallery
        updateImageSizeDisplays();
    }
    
    // Update image size displays in gallery
    function updateImageSizeDisplays() {
        if (uploadedImages.length === 0) return;
        
        // Get all image size elements in the gallery
        const imageSizeElements = document.querySelectorAll('.image-meta span:nth-child(2)');
        imageSizeElements.forEach((element) => {
            element.textContent = `${currentPixelWidth} × ${currentPixelHeight} px`;
        });
    }

    // Set color picker functionality
    function setupColorPicker(colorPickerId, colorCodeId) {
        const colorPicker = document.getElementById(colorPickerId);
        const colorCode = document.getElementById(colorCodeId);
        if (colorPicker && colorCode) {
            colorPicker.addEventListener('input', () => {
                colorCode.value = colorPicker.value;
            });
        }
    }

    // Set mutex relationship for background and transparency options
    function setupBackgroundTransparencyMutex(backgroundCheckboxId, transparentCheckboxId) {
        const backgroundCheckbox = document.getElementById(backgroundCheckboxId);
        const transparentCheckbox = document.getElementById(transparentCheckboxId);
        if (backgroundCheckbox && transparentCheckbox) {
            backgroundCheckbox.addEventListener('change', () => {
                if (backgroundCheckbox.checked) {
                    transparentCheckbox.checked = false;
                    updateUrlForBackgroundColor();
                }
            });
            transparentCheckbox.addEventListener('change', () => {
                if (transparentCheckbox.checked) {
                    backgroundCheckbox.checked = false;
                    updateUrlForTransparent();
                }
            });
        }
    }

    // Update URL for transparent background
    function updateUrlForTransparent() {
        updateUrlWithMode('transparent-background');
    }

    // Update URL for background color
    function updateUrlForBackgroundColor() {
        updateUrlWithMode('change-background-color');
    }

    // Set aspect ratio locking for resize by dimensions
    function setupDimensionAspectLock(widthInput, heightInput, aspectLockCheckbox, tabType) {
        // When aspect ratio is locked, automatically calculate height
        widthInput.addEventListener('input', () => {
            if (aspectLockCheckbox.checked && widthInput.value && originalAspectRatio) {
                const width = parseInt(widthInput.value);
                if (!isNaN(width)) {
                    heightInput.value = Math.round(width / originalAspectRatio);
                }
            }
            updateImageDimensions();
        });
        
        // When aspect ratio is locked, automatically calculate width
        heightInput.addEventListener('input', () => {
            if (aspectLockCheckbox.checked && heightInput.value && originalAspectRatio) {
                const height = parseInt(heightInput.value);
                if (!isNaN(height)) {
                    widthInput.value = Math.round(height * originalAspectRatio);
                }
            }
            updateImageDimensions();
        });
        
        // When aspect ratio lock state changes, handle background option display
        aspectLockCheckbox.addEventListener('change', () => {
            checkLockAspectForBackground(tabType);
            updateImageDimensions();
        });
    }

    // Check aspect ratio lock state, decide whether to show background options
    function checkLockAspectForBackground(tabType) {
        let backgroundOptions, aspectLockCheckbox;
        if (tabType === 'dim') {
            backgroundOptions = elements.backgroundOptionsDim;
            aspectLockCheckbox = elements.lockAspectDimCheckbox;
        } else if (tabType === 'social') {
            backgroundOptions = elements.backgroundOptionsSocial;
            aspectLockCheckbox = elements.lockAspectSocialCheckbox;
        } else {
            // Percentage tab doesn't need background options
            return;
        }
        
        if (backgroundOptions && aspectLockCheckbox) {
            if (!aspectLockCheckbox.checked) {
                backgroundOptions.style.display = 'block';
            } else {
                backgroundOptions.style.display = 'none';
            }
        }
    }

    // Initialize application
    init();
});

// Create image with DPI information
function createImageWithDPI(dataURL, dpi, format, backgroundColor = null, shouldUseTransparent = false) {
    return new Promise((resolve) => {
        // For PNG format, we need to manually modify PNG file header to embed DPI information
        if (format === 'png') {
            // Convert dataURL to ArrayBuffer
            const byteString = atob(dataURL.split(',')[1]);
            const mimeString = dataURL.split(',')[0].split(':')[1].split(';')[0];
            const ab = new ArrayBuffer(byteString.length);
            const ia = new Uint8Array(ab);
            
            for (let i = 0; i < byteString.length; i++) {
                ia[i] = byteString.charCodeAt(i);
            }
            
            // Create a new PNG file, embed DPI information
            const modifiedPng = addPngDPIInfo(ia, dpi);
            const blob = new Blob([modifiedPng], {type: 'image/png'});
            resolve(blob);
        } else {
            // For JPEG format, we create a Canvas and set its size to affect DPI
            const img = new Image();
            img.onload = function() {
                // Calculate actual size (in inches)
                const inchWidth = img.width / 72; // Original image calculated at 72 DPI
                const inchHeight = img.height / 72;
                
                // Calculate new pixel dimensions based on target DPI
                const newWidth = Math.round(inchWidth * dpi);
                const newHeight = Math.round(inchHeight * dpi);
                
                const canvas = document.createElement('canvas');
                const ctx = canvas.getContext('2d');
                
                canvas.width = newWidth;
                canvas.height = newHeight;
                
                // Fill background only if user specified a background color
                if (backgroundColor) {
                    ctx.fillStyle = backgroundColor;
                    ctx.fillRect(0, 0, canvas.width, canvas.height);
                }
                
                // Draw image, preserve aspect ratio
                ctx.drawImage(img, 0, 0, canvas.width, canvas.height);
                
                canvas.toBlob((blob) => {
                    resolve(blob);
                }, `image/${format}`);
            };
            img.src = dataURL;
        }
    });
}

// Add PNG DPI information
function addPngDPIInfo(pngArrayBuffer, dpi) {
    // Create new array to store modified PNG
    const uint8Array = new Uint8Array(pngArrayBuffer);
    
    // Find first block position after IHDR chunk (after PNG header and IHDR chunk)
    let pos = 8 + 4 + 4 + 13 + 4; // PNG signature(8) + Length(4) + Type(4) + IHDR data(13) + CRC(4)
    
    // Find position before IDAT chunk, we'll insert pHYs chunk there
    while (pos < uint8Array.length - 8) {
        const chunkLength = (uint8Array[pos] << 24) | (uint8Array[pos + 1] << 16) | (uint8Array[pos + 2] << 8) | uint8Array[pos + 3];
        const chunkType = String.fromCharCode(uint8Array[pos + 4], uint8Array[pos + 5], uint8Array[pos + 6], uint8Array[pos + 7]);
        
        if (chunkType === 'IDAT') {
            // Found IDAT chunk, we insert pHYs chunk between IHDR and IDAT
            break;
        }
        
        pos += 8 + chunkLength + 4; // Jump to next chunk
    }
    
    // Convert DPI from dots per inch to meters unit (1 inch = 0.0254 meter)
    const dpiPerMeter = Math.round(dpi / 0.0254);
    
    // Create pHYs chunk data
    const physData = new Uint8Array(9); // 9-byte pHYs data (x=4, y=4, unit=1)
    // X direction pixel density (4 bytes)
    physData[0] = (dpiPerMeter >> 24) & 0xFF;
    physData[1] = (dpiPerMeter >> 16) & 0xFF;
    physData[2] = (dpiPerMeter >> 8) & 0xFF;
    physData[3] = dpiPerMeter & 0xFF;
    // Y direction pixel density (4 bytes)
    physData[4] = (dpiPerMeter >> 24) & 0xFF;
    physData[5] = (dpiPerMeter >> 16) & 0xFF;
    physData[6] = (dpiPerMeter >> 8) & 0xFF;
    physData[7] = dpiPerMeter & 0xFF;
    // Unit: 1 = Meter (1 byte)
    physData[8] = 1;
    
    // Calculate pHYs chunk CRC (including type and data)
    const physType = new Uint8Array([112, 72, 89, 115]); // 'pHYs'
    const crcData = new Uint8Array([...physType, ...physData]);
    const physCrc = calculateCrc32(crcData);
    
    // Build new PNG array
    const beforeChunk = uint8Array.slice(0, 33); // Until IHDR ends
    const afterChunk = uint8Array.slice(33);
    
    // Assemble new array: File header + IHDR + pHYs chunk + remaining parts
    const newPng = new Uint8Array(beforeChunk.length + 4 + 4 + 9 + 4 + afterChunk.length); // Length + Type + Data + CRC
    
    let offset = 0;
    newPng.set(beforeChunk, offset);
    offset += beforeChunk.length;
    
    // pHYs Block: Length (4 bytes)
    newPng[offset] = 0;
    newPng[offset + 1] = 0;
    newPng[offset + 2] = 0;
    newPng[offset + 3] = 9;
    offset += 4;
    
    // pHYs Type (4 bytes)
    newPng[offset] = 112; // 'p'
    newPng[offset + 1] = 72;  // 'H'
    newPng[offset + 2] = 89;  // 'Y'
    newPng[offset + 3] = 115; // 's'
    offset += 4;
    
    // pHYs Data (9 bytes)
    newPng.set(physData, offset);
    offset += 9;
    
    // CRC(4 byte)
    newPng[offset] = (physCrc >> 24) & 0xFF;
    newPng[offset + 1] = (physCrc >> 16) & 0xFF;
    newPng[offset + 2] = (physCrc >> 8) & 0xFF;
    newPng[offset + 3] = physCrc & 0xFF;
    offset += 4;
    
    // The remaining part
    newPng.set(afterChunk, offset);
    
    return newPng.buffer;
}

// Simple CRC32 implementation
function calculateCrc32(bytes) {
    // Precomputed CRC32 table
    const crcTable = [];
    for (let i = 0; i < 256; i++) {
        let c = i;
        for (let j = 0; j < 8; j++) {
            if (c & 1) {
                c = 0xEDB88320 ^ (c >>> 1);
            } else {
                c = c >>> 1;
            }
        }
        crcTable[i] = c;
    }
    
    let crc = 0xFFFFFFFF;
    for (let i = 0; i < bytes.length; i++) {
        const tableIndex = (crc ^ bytes[i]) & 0xFF;
        crc = crcTable[tableIndex] ^ (crc >>> 8);
    }
    
    return (crc ^ 0xFFFFFFFF) >>> 0;
}

// PAGE_MAP for different URL routes with titles and descriptions
const PAGE_MAP = {
    "resize-image": {
        title: "मुफ्त इमेज रेजाइज़ ऑनलाइन | CaliperTools",
        description: "इमेज को ऑनलाइन मुफ्त में रेसाइज़ करें। क्रॉप, रोटेट, स्केल और इमेज समायोजित करें। कई प्रारूप, सोशल प्रीसेट। कोई पंजीकरण की आवश्यकता नहीं। सर्वोत्तम गुणवत्ता।"
    },
    "resize-image-png": {
        title: "मुफ्त PNG रेजाइज़ ऑनलाइन | CaliperTools",
        description: "PNG इमेज को ऑनलाइन मुफ्त में रेसाइज़ करें। पारदर्शिता समर्थन। कोई पंजीकरण की आवश्यकता नहीं। सर्वोत्तम गुणवत्ता।"
    },
    "resize-image-jpg": {
        title: "मुफ्त JPG रेजाइज़ ऑनलाइन | CaliperTools",
        description: "JPG इमेज को ऑनलाइन मुफ्त में रेसाइज़ करें। वेब के लिए संपीड़ित और अनुकूलित करें। कोई पंजीकरण की आवश्यकता नहीं। सर्वोत्तम गुणवत्ता।"
    },
    "resize-image-webp": {
        title: "मुफ्त WebP रेजाइज़ ऑनलाइन | CaliperTools",
        description: "WebP इमेज को ऑनलाइन मुफ्त में रेसाइज़ करें। आधुनिक प्रारूप संपीड़न। कोई पंजीकरण की आवश्यकता नहीं। सर्वोत्तम गुणवत्ता।"
    },
    "resize-image-facebook": {
        title: "मुफ्त फेसबुक रेजाइज़ ऑनलाइन | CaliperTools",
        description: "फेसबुक के लिए ऑनलाइन मुफ्त में रेसाइज़ करें। पोस्ट, कवर, विज्ञापन। कोई पंजीकरण की आवश्यकता नहीं। सर्वोत्तम गुणवत्ता।"
    },
    "resize-image-instagram": {
        title: "मुफ्त इंस्टाग्राम रेजाइज़ ऑनलाइन | CaliperTools",
        description: "इंस्टाग्राम के लिए ऑनलाइन मुफ्त में रेसाइज़ करें। पोस्ट, स्टोरीज, प्रोफ़ाइल। कोई पंजीकरण की आवश्यकता नहीं। सर्वोत्तम गुणवत्ता।"
    },
    "resize-image-twitter": {
        title: "मुफ्त ट्विटर रेजाइज़ ऑनलाइन | CaliperTools",
        description: "ट्विटर के लिए ऑनलाइन मुफ्त में रेसाइज़ करें। पोस्ट, हेडर, कार्ड। कोई पंजीकरण की आवश्यकता नहीं। सर्वोत्तम गुणवत्ता।"
    },
    "resize-image-youtube": {
        title: "मुफ्त यूट्यूब रेजाइज़ ऑनलाइन | CaliperTools",
        description: "यूट्यूब के लिए ऑनलाइन मुफ्त में रेसाइज़ करें। थंबनेल, चैनल, प्रोफ़ाइल। कोई पंजीकरण की आवश्यकता नहीं। सर्वोत्तम गुणवत्ता।"
    },
    "crop-image": {
        title: "मुफ्त क्रॉप इमेज ऑनलाइन | CaliperTools",
        description: "इमेज को ऑनलाइन मुफ्त में क्रॉप करें। कस्टम आयाम अनुपात। कोई पंजीकरण की आवश्यकता नहीं। सर्वोत्तम गुणवत्ता।"
    },
    "rotate-clockwise": {
        title: "मुफ्त दक्षिणावर्त घूमाएं ऑनलाइन | CaliperTools",
        description: "दक्षिणावर्त घूमाएं ऑनलाइन मुफ्त में। 90 डिग्री रोटेशन। कोई पंजीकरण की आवश्यकता नहीं। सर्वोत्तम गुणवत्ता।"
    },
    "rotate-counterclockwise": {
        title: "मुफ्त वामावर्त घूमाएं ऑनलाइन | CaliperTools",
        description: "वामावर्त घूमाएं ऑनलाइन मुफ्त में। 90 डिग्री रोटेशन। कोई पंजीकरण की आवश्यकता नहीं। सर्वोत्तम गुणवत्ता।"
    },
    "flip-horizontal": {
        title: "मुफ्त क्षैतिज फ्लिप ऑनलाइन | CaliperTools",
        description: "क्षैतिज फ्लिप ऑनलाइन मुफ्त में। मिरर इफेक्ट। कोई पंजीकरण की आवश्यकता नहीं। सर्वोत्तम गुणवत्ता।"
    },
    "flip-vertical": {
        title: "मुफ्त ऊर्ध्वाधर फ्लिप ऑनलाइन | CaliperTools",
        description: "ऊर्ध्वाधर फ्लिप ऑनलाइन मुफ्त में। मिरर इफेक्ट। कोई पंजीकरण की आवश्यकता नहीं। सर्वोत्तम गुणवत्ता।"
    },
    "rotate-image": {
        title: "मुफ्त रोटेट इमेज ऑनलाइन | CaliperTools",
        description: "इमेज को ऑनलाइन मुफ्त में घुमाएं। दक्षिणावर्त, वामावर्त, फ्लिप। कोई पंजीकरण की आवश्यकता नहीं। सर्वोत्तम गुणवत्ता।"
    },
    "flip-image": {
        title: "मुफ्त फ्लिप इमेज ऑनलाइन | CaliperTools",
        description: "इमेज को ऑनलाइन मुफ्त में फ्लिप करें। क्षैतिज, ऊर्ध्वाधर। कोई पंजीकरण की आवश्यकता नहीं। सर्वोत्तम गुणवत्ता।"
    },
    "resize-by-dimensions": {
        title: "मापदंडों द्वारा मुफ्त रेजाइज़ ऑनलाइन | CaliperTools",
        description: "मापदंडों द्वारा ऑनलाइन मुफ्त में रेसाइज़ करें। चौड़ाई और ऊंचाई सेट करें। कोई पंजीकरण की आवश्यकता नहीं। सर्वोत्तम गुणवत्ता।"
    },
    "resize-by-percentage": {
        title: "प्रतिशत द्वारा मुफ्त रेजाइज़ ऑनलाइन | CaliperTools",
        description: "प्रतिशत द्वारा ऑनलाइन मुफ्त में रेसाइज़ करें। ऊपर या नीचे स्केल करें। कोई पंजीकरण की आवश्यकता नहीं। सर्वोत्तम गुणवत्ता।"
    },
    "resize-for-social-media": {
        title: "मुफ्त सोशल मीडिया रेजाइज़ ऑनलाइन | CaliperTools",
        description: "सोशल मीडिया के लिए ऑनलाइन मुफ्त में रेसाइज़ करें। फेसबुक, इंस्टाग्राम। कोई पंजीकरण की आवश्यकता नहीं। सर्वोत्तम गुणवत्ता।"
    },
    "batch-resize-images": {
        title: "मुफ्त बैच रेजाइज़ ऑनलाइन | CaliperTools",
        description: "बैच रेजाइज़ ऑनलाइन मुफ्त में। एक बार में कई इमेज। कोई पंजीकरण की आवश्यकता नहीं। सर्वोत्तम गुणवत्ता।"
    },
    "compress-images": {
        title: "मुफ्त संपीड़ित इमेज ऑनलाइन | CaliperTools",
        description: "इमेज को ऑनलाइन मुफ्त में संपीड़ित करें। फ़ाइल आकार कम करें। कोई पंजीकरण की आवश्यकता नहीं। सर्वोत्तम गुणवत्ता।"
    },
    "change-image-format": {
        title: "मुफ्त फॉर्मेट बदलें ऑनलाइन | CaliperTools",
        description: "फॉर्मेट बदलें ऑनलाइन मुफ्त में। JPG, PNG, WebP। कोई पंजीकरण की आवश्यकता नहीं। सर्वोत्तम गुणवत्ता।"
    },
    "transparent-background": {
        title: "मुफ्त पारदर्शी बैकग्राउंड ऑनलाइन | CaliperTools",
        description: "पारदर्शी बनाएं ऑनलाइन मुफ्त में। बैकग्राउंड रंग हटाएं। कोई पंजीकरण की आवश्यकता नहीं। सर्वोत्तम गुणवत्ता।"
    },
    "change-background-color": {
        title: "मुफ्त बैकग्राउंड रंग बदलें ऑनलाइन | CaliperTools",
        description: "बैकग्राउंड बदलें ऑनलाइन मुफ्त में। रंग बदलें। कोई पंजीकरण की आवश्यकता नहीं। सर्वोत्तम गुणवत्ता।"
    }
};

// Update page title and description based on slug
function updatePageConfig(slug) {
    const pageConfig = PAGE_MAP[slug] || {
        title: "मुफ्त ऑनलाइन इमेज रेसाइज़र | CaliperTools",
        description: "इमेज को ऑनलाइन मुफ्त में रेसाइज़ करें। कई प्रारूप, सोशल प्रीसेट। कोई पंजीकरण की आवश्यकता नहीं। सर्वोत्तम गुणवत्ता।"
    };
    
    document.getElementById('page-title').textContent = pageConfig.title;
    document.getElementById('page-description').setAttribute('content', pageConfig.description);
}

// Update URL based on selected tab
function updateUrlForTab(tabId) {
    const slugMap = {
        'dimensions': 'resize-by-dimensions',
        'percentage': 'resize-by-percentage',
        'social': 'resize-for-social-media'
    };
    
    const slug = slugMap[tabId];
    if (slug) {
        const newUrl = new URL(window.location.href);
        
        // Remove any existing query parameters and set path format
        newUrl.search = '';
        
        // Build the new path without .html suffix
        const pathParts = newUrl.pathname.split('/');
        // Find the index of Image-resizer or Image-resizer.html
        const resizerIndex = pathParts.findIndex(part => 
            part === 'Image-resizer' || part === 'Image-resizer.html'
        );
        
        if (resizerIndex !== -1) {
            // Remove .html suffix from the filename
            const basePath = pathParts.slice(0, resizerIndex).join('/') + '/Image-resizer';
            newUrl.pathname = basePath + '/' + slug;
        }
        
        history.replaceState(null, '', newUrl);
        updatePageConfig(slug);
    }
}

// Update URL based on selected platform
function updateUrlForPlatform(platform) {
    const newUrl = new URL(window.location.href);
    newUrl.search = '';
    
    const pathParts = newUrl.pathname.split('/');
    const resizerIndex = pathParts.findIndex(part => 
        part === 'Image-resizer' || part === 'Image-resizer.html'
    );
    
    let slug;
    if (!platform) {
        slug = 'resize-for-social-media';
    } else {
        slug = `resize-image-${platform}`;
    }
    
    if (resizerIndex !== -1) {
        // Remove .html suffix from the filename
        const basePath = pathParts.slice(0, resizerIndex).join('/') + '/Image-resizer';
        newUrl.pathname = basePath + '/' + slug;
    }
    
    history.replaceState(null, '', newUrl);
    updatePageConfig(slug);
}

// Update URL based on selected format
function updateUrlForFormat(format) {
    const newUrl = new URL(window.location.href);
    newUrl.search = '';
    
    const pathParts = newUrl.pathname.split('/');
    const resizerIndex = pathParts.findIndex(part => 
        part === 'Image-resizer' || part === 'Image-resizer.html'
    );
    
    let slug;
    if (!format || format === 'original') {
        slug = 'resize-image';
    } else {
        slug = `resize-image-${format}`;
    }
    
    if (resizerIndex !== -1) {
        // Remove .html suffix from the filename
        const basePath = pathParts.slice(0, resizerIndex).join('/') + '/Image-resizer';
        newUrl.pathname = basePath + '/' + slug;
    }
    
    history.replaceState(null, '', newUrl);
    updatePageConfig(slug);
}

// Helper function to update URL with path-based mode
function updateUrlWithMode(slug) {
    const newUrl = new URL(window.location.href);
    newUrl.search = '';
    
    const pathParts = newUrl.pathname.split('/');
    const resizerIndex = pathParts.findIndex(part => 
        part === 'Image-resizer' || part === 'Image-resizer.html'
    );
    
    if (resizerIndex !== -1) {
        // Remove .html suffix from the filename
        const basePath = pathParts.slice(0, resizerIndex).join('/') + '/Image-resizer';
        newUrl.pathname = basePath + '/' + slug;
    } else {
        // If Image-resizer not found in path, check if we're on a language-specific page
        // Handle cases like /bn/Image/Image-resizer or /Image/Image-resizer
        const imageIndex = pathParts.findIndex(part => part === 'Image');
        if (imageIndex !== -1) {
            // Construct the proper path with Image-resizer
            const basePath = pathParts.slice(0, imageIndex + 1).join('/') + '/Image-resizer';
            newUrl.pathname = basePath + '/' + slug;
        } else {
            // Fallback for root or unexpected paths
            newUrl.pathname = '/Image/Image-resizer/' + slug;
        }
    }
    
    history.replaceState(null, '', newUrl);
    updatePageConfig(slug);
}

// Update URL for crop functionality
function updateUrlForCrop() {
    updateUrlWithMode('crop-image');
}

// Update URL for rotate clockwise
function updateUrlForRotateClockwise() {
    updateUrlWithMode('rotate-clockwise');
}

// Update URL for rotate counter clockwise
function updateUrlForRotateCounterClockwise() {
    updateUrlWithMode('rotate-counterclockwise');
}

// Update URL for rotate functionality (general)
function updateUrlForRotate() {
    updateUrlWithMode('rotate-image');
}

// Update URL for flip horizontal
function updateUrlForFlipHorizontal() {
    updateUrlWithMode('flip-horizontal');
}

// Update URL for flip vertical
function updateUrlForFlipVertical() {
    updateUrlWithMode('flip-vertical');
}

// Update URL for flip functionality (general)
function updateUrlForFlip() {
    updateUrlWithMode('flip-image');
}

// Update URL for transparent background
function updateUrlForTransparent() {
    updateUrlWithMode('transparent-background');
}

// Update URL for background color
function updateUrlForBackgroundColor() {
    updateUrlWithMode('change-background-color');
}

// Parse URL parameters and update page accordingly
function parseUrlParams() {
    // Check both path and query params, with query params taking precedence for complex cases
    let mode = null;
    const pathname = window.location.pathname;
    const pathParts = pathname.split('/');
    
    // First check query params for mode (higher priority for complex cases)
    const urlParams = new URLSearchParams(window.location.search);
    const queryMode = urlParams.get('mode');
    if (queryMode) {
        mode = queryMode;
    } else {
        // Fallback to extracting mode from path (e.g., /Image/Image-resizer/flip-horizontal -> flip-horizontal)
        const lastPart = pathParts[pathParts.length - 1];
        if (lastPart && lastPart !== 'Image-resizer' && lastPart !== 'Image-resizer.html') {
            mode = lastPart;
        }
    }
    
    // Update page configuration based on mode
    if (mode && PAGE_MAP[mode]) {
        updatePageConfig(mode);
    } else {
        // Default to resize-image if no mode specified
        updatePageConfig('resize-image');
    }
    
    // Handle different modes
    if (mode) {
        // Handle format modes
        if (mode.startsWith('resize-image-')) {
            const format = mode.replace('resize-image-', '');
            if (['png', 'jpg', 'webp'].includes(format)) {
                const saveAsSelect = document.getElementById('save-as');
                if (saveAsSelect) {
                    saveAsSelect.value = format;
                }
            }
        }
        
        // Handle platform modes
        if (['resize-image-facebook', 'resize-image-instagram', 'resize-image-twitter', 'resize-image-youtube'].includes(mode)) {
            const platform = mode.replace('resize-image-', '');
            const socialPlatformSelect = document.getElementById('social-platform');
            if (socialPlatformSelect) {
                socialPlatformSelect.value = platform;
                // Trigger change event to load presets
                socialPlatformSelect.dispatchEvent(new Event('change'));
            }
        }
        
        // Handle tab modes
        if (mode === 'resize-by-dimensions') {
            const tabElement = document.querySelector('.tab[data-tab="dimensions"]');
            if (tabElement) {
                tabElement.click();
            }
        } else if (mode === 'resize-by-percentage') {
            const tabElement = document.querySelector('.tab[data-tab="percentage"]');
            if (tabElement) {
                tabElement.click();
            }
        } else if (mode === 'resize-for-social-media') {
            const tabElement = document.querySelector('.tab[data-tab="social"]');
            if (tabElement) {
                tabElement.click();
            }
        }
    }
}

// Reset to original state
function resetToOriginalState() {
    // Reset URL to original with .html suffix and no mode
    const newUrl = new URL(window.location.href);
    newUrl.search = '';
    
    const pathParts = newUrl.pathname.split('/');
    const resizerIndex = pathParts.findIndex(part => 
        part === 'Image-resizer' || part === 'Image-resizer.html'
    );
    
    if (resizerIndex !== -1) {
        // Use Image-resizer.html with .html suffix explicitly
        const basePath = pathParts.slice(0, resizerIndex).join('/');
        newUrl.pathname = basePath + '/Image-resizer.html';
    }
    
    history.replaceState(null, '', newUrl);
    
    // Reset title and description to original
    updatePageConfig('resize-image');
    
    // Reset tab to dimensions (without triggering click event)
    elements.tabs.forEach(t => t.classList.remove('active'));
    elements.tabContents.forEach(content => content.classList.remove('active'));
    
    const dimensionsTab = document.querySelector('.tab[data-tab="dimensions"]');
    const dimensionsContent = document.getElementById('dimensions');
    if (dimensionsTab) dimensionsTab.classList.add('active');
    if (dimensionsContent) dimensionsContent.classList.add('active');
    
    // Reset format to original
    const saveAsSelect = document.getElementById('save-as');
    if (saveAsSelect) {
        saveAsSelect.value = 'original';
    }
    
    // Reset platform selection
    const socialPlatformSelect = document.getElementById('social-platform');
    if (socialPlatformSelect) {
        socialPlatformSelect.value = '';
    }
    
    // Reset dimension inputs
    const widthInputDim = document.getElementById('width-dim');
    const heightInputDim = document.getElementById('height-dim');
    if (widthInputDim) widthInputDim.value = '';
    if (heightInputDim) heightInputDim.value = '';
    
    // Reset percentage slider
    const percentageSlider = document.getElementById('percentage-slider');
    const percentageInput = document.getElementById('percentage-input');
    if (percentageSlider) percentageSlider.value = 100;
    if (percentageInput) percentageInput.value = 100;
    
    // Reset background options
    const useBackgroundDim = document.getElementById('use-background-dim');
    const useTransparencyDim = document.getElementById('use-transparency-dim');
    const useBackgroundSocial = document.getElementById('use-background-social');
    const useTransparencySocial = document.getElementById('use-transparency-social');
    
    if (useBackgroundDim) useBackgroundDim.checked = false;
    if (useTransparencyDim) useTransparencyDim.checked = false;
    if (useBackgroundSocial) useBackgroundSocial.checked = false;
    if (useTransparencySocial) useTransparencySocial.checked = false;
    
    // Reset file size input
    const fileSizeInput = document.getElementById('file-size');
    if (fileSizeInput) fileSizeInput.value = '';
    
    // Reset pixel dimensions
    currentPixelWidth = 0;
    currentPixelHeight = 0;
    originalAspectRatio = 1;
}

</script>
</body>
</html>    
