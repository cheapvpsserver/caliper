<!DOCTYPE html>
<html lang="ko-KR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title id="page-title">무료 온라인 이미지 리사이저 | CaliperTools</title>
    <meta name="description" id="page-description" content="온라인으로 무료로 이미지를 리사이즈하세요. 크롭, 회전, 확대/축소 및 조정이 가능합니다. 여러 형식과 소셜 미디어 프리셋 지원. 등록이 필요 없습니다. 최고 품질.">
    <link rel="icon" type="image/png" sizes="32x32" href="../../images/favicon32.png">
    <link rel="stylesheet" href="../../styles.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <script src="../scripts/script.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
    <style>
/* Basic Style Reset */
* {
    margin: 0;
    padding: 0;
    box-sizing: border-box;
}

/* Tutorial and Introduction Section Styles */
.tutorial-section {
    background: linear-gradient(to right, #3b82f6, #8b5cf6);
    color: white;
    padding: 5rem 0;
    margin-top: 5rem;
}

.container {
    max-width: 1400px;
    margin: 0 auto;
    padding: 0 1.5rem;
}

.text-4xl {
    font-size: 2.5rem;
    font-weight: bold;
    text-align: center;
    margin-bottom: 4rem;
}

.grid {
    display: grid;
    gap: 2rem;
}

.grid-cols-1 {
    grid-template-columns: 1fr;
}

@media (min-width: 640px) {
    .sm\:grid-cols-2 {
        grid-template-columns: repeat(2, 1fr);
    }
}

@media (min-width: 1024px) {
    .lg\:grid-cols-4 {
        grid-template-columns: repeat(4, 1fr);
    }
}

.tutorial-card {
    background: white;
    color: #1f2937;
    border-radius: 0.75rem;
    padding: 2rem;
    box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1);
    transition: all 0.3s ease;
}

.tutorial-card:hover {
    transform: scale(1.05);
    box-shadow: 0 20px 25px -5px rgba(0, 0, 0, 0.1);
}

.tutorial-card h3 {
    font-size: 1.5rem;
    font-weight: bold;
    display: flex;
    align-items: center;
    margin-bottom: 1rem;
}

.tutorial-icon {
    background: #3b82f6;
    color: white;
    width: 2.5rem;
    height: 2.5rem;
    border-radius: 50%;
    display: flex;
    align-items: center;
    justify-content: center;
    margin-right: 1rem;
    font-size: 1.25rem;
}

.tutorial-card p {
    color: #6b7280;
    line-height: 1.5;
    overflow: hidden;
    display: -webkit-box;
    -webkit-line-clamp: 3;
    -webkit-box-orient: vertical;
    cursor: help;
    font-size: 0.875rem;
}

/* Feature Section Styles */
.feature-section {
    padding: 5rem 0;
    background: white;
}

.feature-section.gray {
    background: #f9fafb;
}

.grid-cols-2 {
    display: grid;
    grid-template-columns: 1fr;
    gap: 4rem;
    align-items: center;
}

@media (min-width: 768px) {
    .grid-cols-2 {
        grid-template-columns: repeat(2, 1fr);
    }
}

.content-image img {
    border-radius: 0.75rem;
    box-shadow: 0 20px 25px -5px rgba(0, 0, 0, 0.1);
    width: 100%;
}

.content-text h2 {
    font-size: 2.25rem;
    font-weight: bold;
    color: #111827;
    margin-bottom: 1.5rem;
}

.content-text p {
    font-size: 1.125rem;
    color: #6b7280;
    margin-bottom: 1.5rem;
    line-height: 1.75;
}

/* Order Classes */
.order-2 {
    order: 2;
}

.order-1 {
    order: 1;
}

@media (min-width: 768px) {
    .md\:order-1 {
        order: 1;
    }
    .md\:order-2 {
        order: 2;
    }
}

/* Bottom Text Area */
.bottom-text-section {
    padding: 5rem 0;
    background: linear-gradient(to bottom, #f9fafb, white);
}

.bottom-text-section h2 {
    font-size: 2.25rem;
    font-weight: bold;
    color: #111827;
    margin-bottom: 1.5rem;
}

.bottom-text-section p {
    font-size: 1.125rem;
    color: #6b7280;
    margin-bottom: 1.5rem;
    line-height: 1.75;
}

.mb-10 {
    margin-bottom: 2.5rem;
}

/* Related Tools Section */
.related-tools {
    padding: 4rem 0;
    background: white;
}

.section-title {
    font-size: 2.25rem;
    font-weight: bold;
    color: #111827;
    margin-bottom: 3rem;
    text-align: center;
}

body {
    font-family: Arial, sans-serif;
    background-color: #f4f4f4;
}

/* Container Styles */
.image-resizer-container {
    display: flex;
    width: 100%;
    max-width: 1400px;
    margin: 40px auto 0;
    background-color: #fff;
    height: 850px;
}

/* Responsive Design */
@media (max-width: 768px) {
    .image-resizer-container {
        flex-direction: column;
        height: auto;
    }

    .sidebar-container {
        width: 100%;
        border-right: none;
        border-bottom: 1px solid #ddd;
    }

    .sidebar {
        height: auto;
        max-height: 500px;
    }

    .gallery {
        height: auto;
        max-height: 500px;
    }

    .export-area {
        width: 100%;
        float: none;
    }
}

@media (max-width: 480px) {
    .resize-tabs {
        flex-direction: column;
    }

    .tab {
        margin-right: 0;
        margin-bottom: 5px;
    }

    .dimension-group, .percentage-group {
        flex-direction: column;
    }

    .dimension-group input, .dimension-group select, .percentage-group select {
        width: 100%;
        margin-bottom: 5px;
    }
}

/* Left Menu - Scrolling Function */
.sidebar-container {
    width: 380px;
    border-right: 1px solid #ddd;
}

.sidebar {
    padding: 20px;
    background-color: #ffffff;
    height: 750px;
    overflow-y: auto;
    overflow-x: hidden;
    display: flex;
    flex-direction: column;
}

.sidebar::-webkit-scrollbar {
    width: 6px;
}

.sidebar::-webkit-scrollbar-track {
    background: #f1f1f1;
}

.sidebar::-webkit-scrollbar-thumb {
    background: #bbb;
    border-radius: 3px;
}

.sidebar::-webkit-scrollbar-thumb:hover {
    background: #999;
}

.upload-section {
    margin-bottom: 20px;
    display: flex;
    justify-content: space-between;
    align-items: center;
}

.upload-btn {
    background-color: #007bff;
    color: #fff;
    border: none;
    padding: 10px 20px;
    font-size: 20px;
    cursor: pointer;
    transition: background-color 0.3s ease;
}

.upload-btn:hover {
    background-color: #0056b3;
}

.delete-btn {
    background: none;
    border: none;
    color: #dc3545;
    font-size: 20px;
    cursor: pointer;
    transition: color 0.3s ease;
}

.delete-btn:hover {
    color: #b21f2d;
}

.file-input {
    display: none;
}

.resize-settings, .export-settings {
    margin-bottom: 20px;
}

.resize-settings {
    margin-top: 30px;
}

h2 {
    font-size: 18px;
    margin-bottom: 15px;
    color: #0F172A;
}

/* Optimized Tab Styles */
.resize-tabs {
    display: flex;
    margin-bottom: 15px;
    width: 100%;
}

.tab {
    background-color: #eee;
    border: none;
    padding: 12px 0;
    flex: 1;
    margin-right: 5px;
    cursor: pointer;
    font-size: 16px;
    transition: all 0.3s ease;
}

.tab:last-child {
    margin-right: 0;
}

.tab.active {
    background-color: #007bff;
    color: #fff;
}

.tab:hover:not(.active) {
    background-color: #ddd;
}

.tab-content {
    display: none;
    padding: 10px;
}

.tab-content.active {
    display: block;
}

.input-group {
    margin-bottom: 10px;
    display: flex;
    flex-direction: column;
}

.input-row {
    display: flex;
    align-items: center;
    gap: 10px;
}

/* Fix Target File Size Input Box Proportion */
.input-row #file-size {
    flex: 3; /* Input box longer */
}

.input-row #size-unit {
    flex: 1; /* Unit box shorter */
    width: auto;
}

.full-width-input select {
    width: 100%;
    box-sizing: border-box;
}

.dimension-group {
    display: flex;
    align-items: center;
    gap: 10px;
    margin-bottom: 15px;
    width: 100%;
}

.percentage-group {
    display: flex;
    align-items: center;
    gap: 10px;
    margin-bottom: 15px;
    width: 100%;
}

/* Percentage Slider Container */
.percentage-slider-container {
    display: flex;
    align-items: center;
    gap: 10px;
    margin-bottom: 15px;
    width: 100%;
}

.percentage-slider {
    flex: 1;
    height: 8px;
    -webkit-appearance: none;
    appearance: none;
    background: #ddd;
    outline: none;
    border-radius: 4px;
}

.percentage-slider::-webkit-slider-thumb {
    -webkit-appearance: none;
    appearance: none;
    width: 20px;
    height: 20px;
    border-radius: 50%;
    background: #007bff;
    cursor: pointer;
}

/* Percentage Input Box and Unit Container */
.percentage-input-container {
    display: flex;
    justify-content: space-between;
    align-items: center;
    gap: 10px;
    margin-bottom: 15px;
}

.percentage-input {
    flex: 2;
    padding: 12px 8px;
    border: 1px solid #ddd;
    box-sizing: border-box;
    height: 44px;
    font-size: 16px;
}

.percentage-unit-select {
    flex: 1;
    padding: 12px 8px;
    border: 1px solid #ddd;
    box-sizing: border-box;
    height: 44px;
    font-size: 16px;
}

.percentage-value {
    min-width: 50px;
    text-align: right;
}

.dimension-group input, 
.dimension-group select,
.percentage-group select {
    padding: 12px 8px;
    border: 1px solid #ddd;
    box-sizing: border-box;
    height: 44px;
    font-size: 16px;
}

.dimension-group input {
    flex: 2;
    min-width: 0;
}

.dimension-group select,
.percentage-group select {
    flex: 1;
    min-width: 80px;
}

.dimension-group span {
    margin: 0 5px;
}

.input-group label {
    display: block;
    margin-bottom: 5px;
    text-align: left;
    font-weight: bold;
}

.input-group input, .input-group select {
    padding: 12px 8px;
    border: 1px solid #ddd;
    width: 100%;
    height: 44px;
    font-size: 16px;
}

.checkbox-group {
    display: flex;
    align-items: center;
    margin-bottom: 15px;
}

.checkbox-group input {
    margin-right: 5px;
    width: auto;
}

.resolution-options {
    margin-top: 10px;
    margin-bottom: 15px;
}

.background-options {
    margin-top: 10px;
    margin-bottom: 15px;
    display: none;
}

.color-input-group {
    display: flex;
    align-items: center;
    gap: 10px;
    margin-bottom: 10px;
}

.color-input-group input[type="checkbox"] {
    width: auto;
}

.color-input-group label {
    flex: 1;
    margin-bottom: 0;
}

.color-input-group input[type="color"] {
    width: 40px;
    height: 30px;
    padding: 0;
    border: 1px solid #ddd;
}

.color-input-group input[type="text"] {
    width: 80px;
}

.help-tooltip {
    position: relative;
    display: inline-block;
    cursor: help;
    font-size: 16px;
}

.help-tooltip .tooltip-text {
    visibility: hidden;
    width: 120px;
    background-color: #555;
    color: #fff;
    text-align: center;
    border-radius: 6px;
    padding: 5px;
    position: absolute;
    z-index: 1;
    bottom: 125%;
    left: 24%;
    margin-left: -60px;
    opacity: 0;
    transition: opacity 0.3s;
    font-size: 12px;
}

.help-tooltip:hover .tooltip-text {
    visibility: visible;
    opacity: 1;
}

/* New Area Below Left Menu Function Zone - Export Area */
.export-area {
    width: 333px;
    background-color: #f9f9f9;
    border-radius: 4px;
    box-shadow: 0 2px 10px rgba(0,0,0,0.05);
    border: 1px solid #ddd;
    margin-top: 20px;
    clear: both;
    display: block;
    float: left;
    margin-left: 20px;
}

.export-actions {
    display: flex;
    gap: 10px;
    width: 100%;
    box-sizing: border-box;
}

/* Export and ZIP Button Style Optimization */
.export-btn, .zip-btn {
    font-size: 18px;
    padding: 15px 20px;
    height: auto;
    font-weight: bold;
    transition: all 0.2s ease;
    white-space: nowrap;
    min-width: 0;
    flex: 1;
    display: flex;
    align-items: center;
    justify-content: center;
    gap: 5px;
}

.export-btn {
    background-color: #007bff;
    color: #fff;
    border: none;
    cursor: pointer;
    flex: 1;
}

.zip-btn {
    background-color: #28a745;
    color: #fff;
    border: none;
    cursor: pointer;
    flex: 1;
}

.export-btn:hover, .zip-btn:hover {
    transform: translateY(-2px);
    box-shadow: 0 4px 8px rgba(0,0,0,0.1);
}

/* Right Side Image Browser Window */
.gallery {
    flex: 1;
    padding: 20px;
    overflow-y: auto;
    height: 850px;
    display: flex;
    flex-direction: column;
}

.upload-prompt {
    flex: 1;
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    text-align: center;
    padding: 20px;
    border: 2px dashed #ccc;
    border-radius: 8px;
    margin: 20px;
    transition: all 0.3s ease;
    cursor: pointer;
}

.upload-prompt:hover {
    border-color: #007bff;
    background-color: rgba(0, 123, 255, 0.05);
}

.upload-prompt.drag-over {
    border-color: #007bff;
    background-color: rgba(0, 123, 255, 0.1);
}

.upload-prompt-icon {
    font-size: 60px;
    color: #007bff;
    margin-bottom: 20px;
}

.upload-prompt-title {
    font-size: 24px;
    font-weight: bold;
    margin-bottom: 15px;
    color: #0F172A;
}

.upload-prompt-instruction {
    font-size: 16px;
    margin-bottom: 20px;
    color: #666;
}

.supported-formats {
    display: flex;
    flex-wrap: wrap;
    justify-content: center;
    gap: 10px;
    margin-bottom: 15px;
    font-size: 14px;
    max-width: 450px;
}

.format-item {
    color: #555;
}

.more-formats {
    display: flex;
    align-items: center;
    gap: 5px;
    color: #007bff;
    cursor: pointer;
    margin-bottom: 20px;
    font-size: 14px;
}

.formats-tooltip {
    position: relative;
    display: inline-block;
}

.formats-tooltip .tooltip-text {
    visibility: hidden;
    width: 300px;
    background-color: #555;
    color: #fff;
    text-align: center;
    border-radius: 6px;
    padding: 10px;
    position: absolute;
    z-index: 100;
    bottom: 125%;
    left: 50%;
    margin-left: -150px;
    opacity: 0;
    transition: opacity 0.3s;
    font-size: 12px;
    text-align: left;
    line-height: 1.5;
}

.formats-tooltip:hover .tooltip-text {
    visibility: visible;
    opacity: 1;
}

.recommendation {
    font-size: 14px;
    color: #666;
    margin-bottom: 8px;
}

.image-container {
    display: flex;
    flex-wrap: wrap;
    gap: 20px;
    margin-top: 20px;
}

.image-item {
    width: calc(25% - 15px);
    height: 300px;
    margin-bottom: 20px;
    border: 1px solid #ddd;
    padding: 10px;
    position: relative;
    display: flex;
    flex-direction: column;
    transition: box-shadow 0.3s ease;
}

.image-item:hover {
    box-shadow: 0 4px 8px rgba(0,0,0,0.1);
}

.image-preview-container {
    flex: 1;
    height: 220px;
    width: 100%;
    display: flex;
    align-items: center;
    justify-content: center;
    overflow: hidden;
    background-color: #f9f9f9;
    margin-bottom: 10px;
    position: relative;
}

.image-item img {
    max-width: 100% !important;
    max-height: 100% !important;
    width: auto !important;
    height: auto !important;
    object-fit: contain !important;
    display: block !important;
    transform: none !important;
    transition: none !important;
}

.image-actions {
    position: absolute;
    top: 10px;
    right: 10px;
    display: flex;
    gap: 5px;
}

.image-action-btn {
    width: 28px;
    height: 28px;
    border-radius: 50%;
    background-color: rgba(255, 255, 255, 0.8);
    border: none;
    display: flex;
    align-items: center;
    justify-content: center;
    cursor: pointer;
    font-size: 14px;
    color: #0F172A;
    transition: all 0.2s ease;
    position: relative;
}

.image-action-btn:hover {
    background-color: white;
    transform: scale(1.1);
}

.image-action-btn .tooltip {
    visibility: hidden;
    width: auto;
    background-color: #555;
    color: #fff;
    text-align: center;
    border-radius: 6px;
    padding: 5px 10px;
    position: absolute;
    z-index: 1;
    bottom: 125%;
    left: 50%;
    transform: translateX(-50%);
    opacity: 0;
    transition: opacity 0.3s;
    font-size: 12px;
    white-space: nowrap;
}

.image-action-btn:hover .tooltip {
    visibility: visible;
    opacity: 1;
}

.crop-btn:hover {
    color: #28a745;
}

.rotate-btn:hover {
    color: #007bff;
}

.info-btn:hover {
    color: #ffc107;
}

.delete-img-btn:hover {
    color: #dc3545;
}

.image-info {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: 5px;
    font-size: 13px;
}

.image-meta {
    font-size: 12px;
    color: #666;
}

/* Modal Box Styles */
.modal {
    display: none;
    position: fixed;
    z-index: 1000;
    left: 0;
    top: 0;
    width: 100%;
    height: 100%;
    overflow: auto;
    background-color: rgba(0, 0, 0, 0.4);
    opacity: 0;
    transition: opacity 0.3s ease;
}

.modal.show {
    display: block;
    opacity: 1;
}

.modal-content {
    background-color: #fefefe;
    margin: 15% auto;
    padding: 20px;
    border: 1px solid #888;
    width: 300px;
    text-align: center;
    border-radius: 5px;
    transform: translateY(-20px);
    transition: transform 0.3s ease;
}

/* Crop Modal Box Styles */
.crop-modal-content {
    width: 900px;
    height: 740px;
    margin: 50px auto;
    max-width: none;
    padding: 0;
    display: flex;
    flex-direction: column;
    border-radius: 8px;
    overflow: hidden;
    box-shadow: 0 5px 15px rgba(0,0,0,0.3);
    transform: none;
    transition: none;
}

/* Vertical Layout Group */
.vertical-group {
    margin-bottom: 15px;
}

/* Full Width Input Box */
.full-width-input {
    width: 100%;
}

/* Half Width Input Box */
.half-width {
    flex: 1;
}

/* Input Row */
.input-row {
    display: flex;
    gap: 10px;
    margin-bottom: 15px;
}

.crop-modal-content .modal-header {
    height: 66px;
    width: 100%;
    background-color: #f5f5f5;
    padding: 0 20px;
    display: flex;
    align-items: center;
    justify-content: space-between;
    border-bottom: 1px solid #ddd;
}

.crop-modal-content h2 {
    margin: 0;
    font-size: 20px;
    font-weight: 600;
}

.modal-navigation {
    display: flex;
    gap: 10px;
}

.nav-btn {
    border: none;
    width: 30px;
    height: 30px;
    border-radius: 4px;
    cursor: pointer;
    display: flex;
    align-items: center;
    justify-content: center;
}

.crop-body {
    display: flex;
    height: calc(100% - 66px);
}

.crop-modal-body {
    display: flex;
    flex: 1;
    padding: 15px;
    gap: 20px;
    overflow: hidden;
    height: 100%;
}

.crop-preview-container {
    width: 570px;
    height: 640px;
    padding: 15px;
    background-color: #f9f9f9;
    border-radius: 8px;
    display: flex;
    align-items: center;
    justify-content: center;
}

.crop-image-container {
    width: 540px;
    height: 610px;
    position: relative;
    overflow: hidden;
    background-color: white;
    border: 1px solid #e0e0e0;
}

#cropImage {
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
}

.crop-selection {
    position: absolute;
    border: 1px dashed #0F172A;
    background-color: rgba(50, 150, 255, 0.2);
    cursor: move;
    box-sizing: border-box;
    pointer-events: none; /* Disable mouse events for the entire crop box, let child elements handle */
}

.crop-grid {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background-image: linear-gradient(to right, transparent 33%, rgba(0,0,0,0.1) 33%, rgba(0,0,0,0.1) 34%, transparent 34%, transparent 66%, rgba(0,0,0,0.1) 66%, rgba(0,0,0,0.1) 67%, transparent 67%),
                      linear-gradient(to bottom, transparent 33%, rgba(0,0,0,0.1) 33%, rgba(0,0,0,0.1) 34%, transparent 34%, transparent 66%, rgba(0,0,0,0.1) 66%, rgba(0,0,0,0.1) 67%, transparent 67%);
    pointer-events: auto; /* Ensure grid can receive mouse events for dragging */
}
        
/* Ensure control point cursor has higher priority */
.crop-handle {
    position: absolute;
    width: 20px;
    height: 20px;
    background-color: white;
    border: 1px solid #0F172A;
    border-radius: 4px;
    z-index: 20;
    cursor: pointer; /* Default pointer */
    pointer-events: auto; /* Ensure control points can receive mouse events */
}

.crop-selection-top {
    position: absolute;
    top: -5px;
    left: 15px; /* Leave space for top-left corner point */
    right: 15px; /* Leave space for top-right corner point */
    height: 10px;
    cursor: ns-resize;
    z-index: 10;
    pointer-events: auto; /* Enable mouse events for top border */
}

.crop-selection-bottom {
    position: absolute;
    bottom: -5px;
    left: 15px; /* Leave space for bottom-left corner point */
    right: 15px; /* Leave space for bottom-right corner point */
    height: 10px;
    cursor: ns-resize;
    z-index: 10;
    pointer-events: auto; /* Enable mouse events for bottom border */
}

.crop-selection-left {
    position: absolute;
    left: -5px;
    top: 15px; /* Leave space for top-left corner point */
    bottom: 15px; /* Leave space for bottom-left corner point */
    width: 10px;
    cursor: ew-resize;
    z-index: 10;
    pointer-events: auto; /* Enable mouse events for left border */
}

.crop-selection-right {
    position: absolute;
    right: -5px;
    top: 15px; /* Leave space for top-right corner point */
    bottom: 15px; /* Leave space for bottom-right corner point */
    width: 10px;
    cursor: ew-resize;
    z-index: 10;
    pointer-events: auto; /* Enable mouse events for right border */
}

.crop-handle {
    position: absolute;
    width: 20px;
    height: 20px;
    background-color: white;
    border: 1px solid #0F172A;
    border-radius: 4px;
    z-index: 20;
    cursor: pointer; /* Default pointer */
}

.crop-handle.top-left {
    top: -10px;
    left: -10px;
    cursor: nwse-resize !important;
    z-index: 35; /* Corner points have higher z-index */
}

.crop-handle.top-middle {
    top: -10px;
    left: 50%;
    transform: translateX(-50%);
    cursor: ns-resize !important;
    z-index: 32; /* Edge midpoints have slightly lower z-index */
}

.crop-handle.top-right {
    top: -10px;
    right: -10px;
    cursor: nesw-resize !important;
    z-index: 35; /* Corner points have higher z-index */
}

.crop-handle.middle-left {
    top: 50%;
    left: -10px;
    transform: translateY(-50%);
    cursor: ew-resize !important;
    z-index: 32; /* Edge midpoints have slightly lower z-index */
}

.crop-handle.middle-right {
    top: 50%;
    right: -10px;
    transform: translateY(-50%);
    cursor: ew-resize !important;
    z-index: 32; /* Edge midpoints have slightly lower z-index */
}

.crop-handle.bottom-left {
    bottom: -10px;
    left: -10px;
    cursor: nesw-resize !important;
    z-index: 35; /* Corner points have higher z-index */
}

.crop-handle.bottom-middle {
    bottom: -10px;
    left: 50%;
    transform: translateX(-50%);
    cursor: ns-resize !important;
    z-index: 32; /* Edge midpoints have slightly lower z-index */
}

.crop-handle.bottom-right {
    bottom: -10px;
    right: -10px;
    cursor: nwse-resize !important;
    z-index: 35; /* Corner points have higher z-index */
}

.crop-grid {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background-image: linear-gradient(to right, transparent 33%, rgba(0,0,0,0.1) 33%, rgba(0,0,0,0.1) 34%, transparent 34%, transparent 66%, rgba(0,0,0,0.1) 66%, rgba(0,0,0,0.1) 67%, transparent 67%),
                      linear-gradient(to bottom, transparent 33%, rgba(0,0,0,0.1) 33%, rgba(0,0,0,0.1) 34%, transparent 34%, transparent 66%, rgba(0,0,0,0.1) 66%, rgba(0,0,0,0.1) 67%, transparent 67%);
}

.crop-controls {
    flex: 1;
    min-width: 250px;
    display: flex;
    flex-direction: column;
}

.crop-controls h3 {
    margin: 15px 0 20px;
    font-size: 20px;
    font-weight: 600;
    text-align: left;
}

.input-group, .aspect-ratio-group, .position-group {
    margin-bottom: 15px;
}

.crop-controls label {
    display: block;
    margin-bottom: 5px;
    font-size: 14px;
    color: #555;
    text-align: left;
}

.crop-input, .crop-select {
    width: 100%;
    padding: 8px 10px;
    border: 1px solid #ddd;
    border-radius: 4px;
    font-size: 14px;
    margin-bottom: 8px;
}

.input-group, .position-group {
    display: flex;
    gap: 10px;
}

.input-group .crop-input, .position-group .crop-input {
    flex: 1;
}

.custom-ratio-group {
    display: flex;
    gap: 10px;
    margin-bottom: 15px;
    display: none;
}

.small-input {
    flex: 1;
}

.crop-actions {
    margin-top: auto;
    display: flex;
    justify-content: flex-end;
    gap: 10px;
    padding-top: 20px;
}

.modal.show .modal-content {
    transform: translateY(0);
}

.modal-buttons {
    display: flex;
    justify-content: center;
    gap: 10px;
    margin-top: 20px;
}

.modal-btn {
    padding: 8px 16px;
    cursor: pointer;
    border: none;
    border-radius: 4px;
    transition: background-color 0.3s ease;
}

.cancel-btn {
    background-color: #6c757d;
    color: white;
}

.cancel-btn:hover {
    background-color: #5a6268;
}

.confirm-btn {
    background-color: #dc3545;
    color: white;
}

.confirm-btn:hover {
    background-color: #c82333;
}

/* Social Media Related Styles */
.social-select-fullwidth {
    width: 100%;
    padding: 12px 8px;
    border: 1px solid #ddd;
    box-sizing: border-box;
    margin-bottom: 15px;
    height: 44px;
    font-size: 16px;
}

/* Rotate and Flip Modal Box Styles */
#rotate-flip-modal {
    z-index: 2000;
}

.rotate-flip-modal-content {
    width: 900px;
    height: 740px;
    margin: 50px auto;
    padding: 0;
    border-radius: 8px;
    overflow: hidden;
    box-shadow: 0 5px 15px rgba(0,0,0,0.3);
}

/* Rotate and Flip Top */
.rotate-flip-header {
    height: 66px;
    width: 100%;
    background-color: #f5f5f5;
    padding: 0 20px;
    display: flex;
    align-items: center;
    justify-content: space-between;
    border-bottom: 1px solid #ddd;
}

.rotate-flip-header h2 {
    margin: 0;
    font-size: 20px;
    color: #0F172A;
}

.rotate-flip-navigation {
    display: flex;
    align-items: center;
    gap: 10px;
}

.close-rotate-flip {
    background: none;
    border: none;
    font-size: 24px;
    cursor: pointer;
    color: #495057;
    transition: color 0.2s ease;
}

.close-rotate-flip:hover {
    color: #dc3545;
}

.rotate-flip-body {
    display: flex;
    height: calc(100% - 66px);
}

.rotate-flip-preview-container {
    flex: 570;
    padding: 15px;
    background-color: #f9f9f9;
    display: flex;
    align-items: center;
    justify-content: center;
    position: relative;
}

.rotate-flip-preview {
    position: relative;
    max-width: 100%;
    max-height: 100%;
}

.rotate-flip-image {
    max-width: 100%;
    max-height: 570px;
    display: block;
    margin: 0 auto;
}

.rotate-flip-controls {
    flex: 330;
    padding: 20px;
    background-color: #fff;
    overflow-y: auto;
    display: flex;
    flex-direction: column;
}

.rotate-controls {
    display: flex;
    justify-content: space-between;
    margin-bottom: 30px;
}

.flip-controls {
    display: flex;
    justify-content: space-between;
    margin-bottom: 30px;
}

.rotate-btn-large, .flip-btn-large {
        width: 128px;
        height: 110px;
        background-color: #e9f5ff;
        border: 1px solid #007bff;
        border-radius: 8px;
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        cursor: pointer;
        transition: all 0.3s ease;
        box-shadow: 0 2px 4px rgba(0,0,0,0.05);
    }

    .rotate-btn-large:hover, .flip-btn-large:hover {
        background-color: #d1e7ff;
        border-color: #0056b3;
        transform: translateY(-2px);
        box-shadow: 0 4px 8px rgba(0,0,0,0.1);
    }

    .rotate-btn-large i, .flip-btn-large i {
        font-size: 40px;
        color: #007bff;
        margin-bottom: 8px;
    }

    .btn-name {
        font-size: 14px;
        font-weight: bold;
        color: #0F172A;
        text-align: center;
    }

.rotate-flip-actions {
    display: flex;
    justify-content: space-between;
    gap: 10px;
    padding: 10px;
    border-top: 1px solid #eee;
    background-color: #fff;
    margin-top: auto;
    width: 100%;
    box-sizing: border-box;
}

.apply-rotate-flip-btn, .reset-rotate-flip-btn {
    flex: 1;
    padding: 15px;
    border: none;
    border-radius: 4px;
    cursor: pointer;
    font-size: 18px;
    font-weight: bold;
    transition: all 0.3s ease;
}

.apply-rotate-flip-btn {
    background-color: #007bff;
    color: white;
    box-shadow: 0 2px 4px rgba(0,0,0,0.1);
}

.apply-rotate-flip-btn:hover {
    background-color: #0056b3;
    transform: translateY(-2px);
    box-shadow: 0 4px 8px rgba(0,0,0,0.15);
}

.reset-rotate-flip-btn {
    background-color: #6c757d;
    color: white;
    box-shadow: 0 2px 4px rgba(0,0,0,0.1);
}

.reset-rotate-flip-btn:hover {
    background-color: #5a6268;
    transform: translateY(-2px);
    box-shadow: 0 4px 8px rgba(0,0,0,0.15);
}

.nav-btn {
    border: none;
    width: 36px;
    height: 36px;
    border-radius: 4px;
    display: flex;
    align-items: center;
    justify-content: center;
    cursor: pointer;
    font-size: 16px;
    color: #495057;
    transition: all 0.2s ease;
}

.nav-btn:hover {
    background-color: #007bff;
    color: white;
}

.close-crop {
    background: none;
    border: none;
    font-size: 24px;
    cursor: pointer;
    color: #495057;
    transition: color 0.2s ease;
}

.close-crop:hover {
    color: #dc3545;
}

.crop-body {
    display: flex;
    height: calc(100% - 66px);
}

.crop-preview-container {
    width: 570px;
    height: 640px;
    padding: 0;
    background-color: #999;
    border: 15px solid #e7e6e6;
    display: flex;
    align-items: center;
    justify-content: center;
    position: relative;
    box-sizing: border-box;
}




/* Responsive Design */
@media (max-width: 1200px) {
    .image-item {
        width: calc(33.333% - 14px);
    }
}

@media (max-width: 992px) {
    .image-item {
        width: calc(50% - 10px);
    }
    
    .crop-modal-content {
        width: 90%;
        height: auto;
        max-height: 90vh;
    }
    
    .crop-body {
        flex-direction: column;
    }
    
    .crop-preview-container {
        flex: none;
        height: 400px;
    }
    
    .crop-controls {
        flex: none;
        max-height: 400px;
    }
}

@media (max-width: 768px) {
    .image-resizer-container {
        flex-direction: column;
    }

    .sidebar-container {
        width: 100%;
        border-right: none;
        border-bottom: 1px solid #ddd;
        order: 2;
    }

    .sidebar {
        height: auto;
        max-height: 70vh;
    }

    .gallery {
        width: 100%;
        order: 1;
        height: auto;
        max-height: 50vh;
    }

    .dimension-group, .percentage-group, .percentage-slider-container,
    .percentage-input-container {
        flex-direction: column;
        align-items: stretch;
    }
    
    .dimension-group input, .dimension-group select,
    .percentage-group input, .percentage-group select,
    .percentage-slider-container select,
    .percentage-input, .percentage-unit-select,
    .input-group input, .input-group select {
        width: 100%;
        box-sizing: border-box;
    }
    
    .dimension-group span, .percentage-value {
        display: none;
    }
}

@media (max-width: 480px) {
    .image-item {
        width: 100%;
    }
    
    .supported-formats {
        gap: 8px;
        font-size: 12px;
    }
}

.nav-btn:hover {
    background-color: #007bff !important;
    color: white !important;
}
</style>
<script>  
    document.addEventListener('contextmenu', function(e) {
        e.preventDefault();
        alert('마우스 오른쪽 클릭 메뉴가 비활성화되어 있습니다');
    });

    document.addEventListener('selectstart', function(e) {
        e.preventDefault();
    });

    document.addEventListener('keydown', function(e) {
        if ((e.ctrlKey || e.metaKey) && (e.key === 'c' || e.key === 'u' || e.key === 's' || e.key === 'a')) {
            e.preventDefault();
            alert('복사 기능이 비활성화되었습니다');
        }
    });

    document.addEventListener('keydown', function(e) {
        if (e.key === 'F12' || (e.ctrlKey && e.shiftKey && e.key === 'I')) {
            e.preventDefault();
            alert('개발자 도구가 비활성화되었습니다');
        }
    });
</script>
<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-5020583079217470"crossorigin="anonymous"></script> </head>
<body>
    <main class="main">
    <div id="tool-main-section" class="image-resizer-container">
        <!-- Left Menu Container -->
        <div class="sidebar-container">
            <div class="sidebar">
                <div class="upload-section">
                    <button id="upload-btn" class="upload-btn">+</button>
                    <input type="file" id="file-input" class="file-input" multiple accept="image/*">
                    <button id="delete-all-btn" class="delete-btn"><i class="fas fa-trash"></i></button>
                </div>
                <p>Maximum file size: 10 MB</p>

                <div class="resize-settings">
                    <h2>리사이즈 설정</h2>
                    <div class="resize-tabs">
                        <button class="tab active" data-tab="dimensions">크기로 조정</button>
                        <button class="tab" data-tab="percentage">백분율로 조정</button>
                        <button class="tab" data-tab="social">소셜 미디어</button>
                    </div>

                    <!-- Resize by Dimensions -->
                    <div class="tab-content active" id="dimensions">
                        <label>너비 & 높이</label>
                        <div class="dimension-group">
                            <input type="number" id="width-dim" placeholder="너비">
                            <span>x</span>
                            <input type="number" id="height-dim" placeholder="높이">
                        </div>
                        
                        <div class="checkbox-group">
                            <input type="checkbox" id="lock-aspect-dim" checked>
                            <label for="lock-aspect-dim">가로세로비 유지</label>
                        </div>

                        <!-- Background Fill Options - Hidden by Default -->
                        <div id="background-options-dim" class="background-options">
                            <div class="color-input-group">
                                <input type="checkbox" id="use-background-dim">
                                <label for="use-background-dim">색상 선택</label>
                                <input type="text" id="color-code-dim" value="#FFFFFF" readonly>
                                <input type="color" id="color-picker-dim" value="#FFFFFF">
                            </div>
                            <div class="color-input-group">
                                <input type="checkbox" id="use-transparency-dim">
                                <label for="use-transparency-dim">투명</label>
                                <span class="help-tooltip">❓
                                    <span class="tooltip-text">PNG 이미지에만 적용 가능</span>
                                </span>
                            </div>
                        </div>
                    </div>

                    <!-- Resize by Percentage -->
                    <div class="tab-content" id="percentage">
                        <div class="input-group">
                            <label>확대/축소 백분율</label>
                            <div class="percentage-slider-container">
                                <input type="range" id="percentage-slider" class="percentage-slider" min="10" max="300" value="100">
                                <span id="percentage-display" class="percentage-value">100%</span>
                            </div>
                            
                            <div class="percentage-input-container">
                                <input type="number" id="percentage-input" class="percentage-input" min="10" max="300" value="100" placeholder="백분율">
                            </div>
                        </div>
                    </div>

                    <!-- Social Media Presets -->
                    <div class="tab-content" id="social">
                        <div class="input-group">
                            <label>소셜 미디어 플랫폼</label>
                            <select id="social-platform" class="social-select-fullwidth">
                                <option value="">플랫폼을 선택하세요</option>
                                <option value="facebook">Facebook</option>
                                <option value="instagram">Instagram</option>
                                <option value="twitter">Twitter</option>
                                <option value="youtube">YouTube</option>
                            </select>
                        </div>

                        <div class="input-group">
                            <label>프리셋 유형</label>
                            <select id="social-preset" class="social-select-fullwidth">
                                <option value="">먼저 플랫폼을 선택하세요</option>
                            </select>
                        </div>

                        <label>너비 & 높이</label>
                        <div class="dimension-group">
                            <input type="number" id="width-social" placeholder="너비">
                            <span>x</span>
                            <input type="number" id="height-social" placeholder="높이">
                        </div>
                        
                        <div class="checkbox-group">
                            <input type="checkbox" id="lock-aspect-social" checked>
                            <label for="lock-aspect-social">가로세로비 유지</label>
                        </div>

                        <div id="background-options-social" class="background-options">
                            <div class="color-input-group">
                                <input type="checkbox" id="use-background-social">
                                <label for="use-background-social">색상 선택</label>
                                <input type="text" id="color-code-social" value="#FFFFFF" readonly>
                                <input type="color" id="color-picker-social" value="#FFFFFF">
                            </div>
                            <div class="color-input-group">
                                <input type="checkbox" id="use-transparency-social">
                                <label for="use-transparency-social">투명</label>
                                <span class="help-tooltip">❓
                                    <span class="tooltip-text">PNG 이미지에만 적용 가능</span>
                                </span>
                            </div>
                        </div>
                    </div>
                </div>

                <div class="export-settings">
                    <h2>Export Settings</h2>
                    <div class="input-group">
                        <label for="file-size">Target File Size (Optional)</label>
                        <div class="input-row">
                            <input type="number" id="file-size" placeholder="Enter Size">
                            <select id="size-unit">
                                <option value="KB">KB</option>
                                <option value="MB">MB</option>
                            </select>
                        </div>
                    </div>
                    

                    
                    <div class="input-group full-width-input">
                        <label for="save-as">Output format</label>
                        <select id="save-as">
                            <option value="original">Original</option>
                            <option value="jpg">JPG</option>
                            <option value="png">PNG</option>
                            <option value="webp">WEBP</option>
                        </select>
                    </div>
                </div>
            </div>

        <!-- New Area Below Left Menu Function Zone - Export Area -->
        <div class="export-area">
            <div class="export-actions">
                <button id="export-btn" class="export-btn"><i class="fas fa-download"></i> Export</button>
                <button id="zip-btn" class="zip-btn"><i class="fas fa-file-archive"></i> ZIP Archive</button>
            </div>
    </div>
    </div>

    <!-- Crop Image Modal Box -->
    <div id="cropModal" class="modal">
        <div class="modal-content crop-modal-content">
            <div class="modal-header">
                <h2>Crop Image</h2>
                <div class="modal-navigation" id="cropModalNavigation">
                    <button class="nav-btn prev-image" id="prevImageCropBtn">
                        <i class="fas fa-chevron-left"></i>
                    </button>
                    <button class="nav-btn next-image" id="nextImageCropBtn">
                        <i class="fas fa-chevron-right"></i>
                    </button>
                </div>
                <button class="close-rotate-flip" id="closeCropModal">×</button>
            </div>
            <div class="crop-body">
                <div class="crop-modal-body">
                    <div class="crop-preview-container">
                        <div class="crop-image-container" id="cropImageContainer">
                            <img id="cropImage" alt="Crop Preview">
                            <div class="crop-selection" id="cropSelection">
                                <div class="crop-handle top-left"></div>
                                <div class="crop-handle top-middle"></div>
                                <div class="crop-handle top-right"></div>
                                <div class="crop-handle middle-left"></div>
                                <div class="crop-handle middle-right"></div>
                                <div class="crop-handle bottom-left"></div>
                                <div class="crop-handle bottom-middle"></div>
                                <div class="crop-handle bottom-right"></div>
                                <div class="crop-selection-top"></div>
                                <div class="crop-selection-bottom"></div>
                                <div class="crop-selection-left"></div>
                                <div class="crop-selection-right"></div>
                                <div class="crop-grid"></div>
                            </div>
                        </div>
                    </div>
                    <div class="crop-controls">
                        <h3>자르기 영역</h3>
                        <div class="vertical-group">
                            <div class="input-row">
                                <div class="vertical-group half-width">
                                    <label for="cropWidth">너비</label>
                                    <input type="number" id="cropWidth" class="crop-input full-width-input">
                                </div>
                                <div class="vertical-group half-width">
                                    <label for="cropHeight">높이</label>
                                    <input type="number" id="cropHeight" class="crop-input full-width-input">
                                </div>
                            </div>
                        </div>
                        <div class="vertical-group">
                            <label for="aspectRatioSelect">가로세로비</label>
                            <select id="aspectRatioSelect" class="crop-select full-width-input">
                                <option value="free">자유 비율</option>
                                <option value="original">원본 비율</option>
                                <option value="custom">사용자 정의</option>
                            </select>
                        </div>
                        <div id="customRatioGroup" class="vertical-group">
                            <div class="input-row">
                                <div class="vertical-group half-width">
                                    <label for="customRatioX">비율 (X)</label>
                                    <input type="number" id="customRatioX" class="crop-input full-width-input" min="1">
                                </div>
                                <div class="vertical-group half-width">
                                    <label for="customRatioY">비율 (Y)</label>
                                    <input type="number" id="customRatioY" class="crop-input full-width-input" min="1">
                                </div>
                            </div>
                        </div>
                        <h3>자르기 위치</h3>
                        <div class="vertical-group">
                            <div class="input-row">
                                <div class="vertical-group half-width">
                                    <label for="cropPositionX">위치 (X)</label>
                                    <input type="number" id="cropPositionX" class="crop-input full-width-input">
                                </div>
                                <div class="vertical-group half-width">
                                    <label for="cropPositionY">위치 (Y)</label>
                                    <input type="number" id="cropPositionY" class="crop-input full-width-input">
                                </div>
                            </div>
                        </div>
                        <div class="crop-actions">
                            <button id="applyCropBtn" class="apply-rotate-flip-btn"><i class="fas fa-check"></i> 자르기</button>
                            <button id="resetCropBtn" class="reset-rotate-flip-btn"><i class="fas fa-undo"></i> 초기화</button>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>
    <!-- End Crop Image Modal Box -->

        <!-- Right Side Image Browser Window -->
        <div class="gallery">
            <div id="upload-prompt" class="upload-prompt">
                <div class="upload-prompt-icon">
                    <i class="fas fa-image"></i>
                </div>
                <div class="upload-prompt-title">다기능 이미지 리사이저</div>
                <div class="upload-prompt-instruction">여기를 클릭하거나, 드래그 & 드롭, Ctrl+V를 사용하여 이미지를 업로드하세요</div>
                <div class="supported-formats">
                    <div class="format-item">✅ jpg</div>
                    <div class="format-item">✅ png</div>
                    <div class="format-item">✅ webp</div>
                    <div class="format-item">✅ gif</div>
                    <div class="format-item">✅ psd/psb</div>
                    <div class="format-item">✅ heic/heif</div>
                </div>
                <div class="formats-tooltip">
                    <div class="more-formats">
                        <i class="fas fa-ellipsis-h"></i> 더 많은 형식
                    </div>
                    <span class="tooltip-text">
                        tga, xcf, miff, dcm, xpm, pcx, fits, ppm, pgm, pím, mng, dds, otb
                    </span>
                </div>
                <div class="recommendation">권장 총 파일 수: &lt; 100</div>
                <div class="recommendation">권장 파일 크기: &lt; 10Mb</div>
            </div>
            
            <div id="image-container" class="image-container">
                <!-- Images Will Be Added Dynamically Via JavaScript -->
            </div>
        </div>
    </div>

    <!-- Delete Confirmation Modal Box -->
    <div id="delete-modal" class="modal">
        <div class="modal-content">
            <p>모든 이미지를 삭제하시겠습니까?</p>
            <div class="modal-buttons">
                <button id="cancel-delete" class="modal-btn cancel-btn">취소</button>
                <button id="confirm-delete" class="modal-btn confirm-btn">확인</button>
            </div>
        </div>
    </div>

    <!-- Single Image Delete Confirmation Modal Box -->
    <div id="delete-image-modal" class="modal">
        <div class="modal-content">
            <p>이 이미지를 삭제하시겠습니까?</p>
            <div class="modal-buttons">
                <button id="cancel-delete-image" class="modal-btn cancel-btn">취소</button>
                <button id="confirm-delete-image" class="modal-btn confirm-btn">확인</button>
            </div>
        </div>
    </div>

    <!-- Rotate and Flip Modal Box -->
    <div id="rotate-flip-modal" class="modal">
        <div class="rotate-flip-modal-content">
            <div class="rotate-flip-header">
                <h2>이미지 회전 및 뒤집기</h2>
                <div class="rotate-flip-navigation" id="rotate-flip-navigation">
                    <button class="nav-btn prev-image" id="prev-image-rotate">
                        <i class="fas fa-chevron-left"></i>
                    </button>
                    <button class="nav-btn next-image" id="next-image-rotate">
                        <i class="fas fa-chevron-right"></i>
                    </button>
                </div>
                <button class="close-rotate-flip" id="close-rotate-flip">×</button>
            </div>
            <div class="rotate-flip-body">
                <div class="rotate-flip-preview-container">
                    <div class="rotate-flip-preview">
                        <img id="rotate-flip-image" class="rotate-flip-image" src="" alt="Rotate and Flip Image">
                    </div>
                </div>
                <div class="rotate-flip-controls">
                    <div class="rotate-controls">
                    <button class="rotate-btn-large clockwise" id="rotate-clockwise">
                        <i class="fas fa-sync-alt"></i>
                        <div class="btn-name">시계 방향</div>
                    </button>
                    <button class="rotate-btn-large counterclockwise" id="rotate-counterclockwise">
                        <i class="fas fa-sync-alt fa-rotate-180"></i>
                        <div class="btn-name">반시계 방향</div>
                    </button>
                </div>
                <div class="flip-controls">
                    <button class="flip-btn-large horizontal" id="flip-horizontal">
                        <i class="fas fa-exchange-alt"></i>
                        <div class="btn-name">수평 뒤집기</div>
                    </button>
                    <button class="flip-btn-large vertical" id="flip-vertical">
                        <i class="fas fa-exchange-alt fa-rotate-90"></i>
                        <div class="btn-name">수직 뒤집기</div>
                    </button>
                </div>
                <div class="rotate-flip-actions">
                <button id="apply-rotate-flip" class="apply-rotate-flip-btn"><i class="fas fa-check"></i> 적용</button>
                <button id="reset-rotate-flip" class="reset-rotate-flip-btn"><i class="fas fa-undo"></i> 초기화</button>
            </div>
            </div>
            </div>
        </div>
    </div>

    <!-- Tutorial Section -->
    <section class="tutorial-section">
        <div class="container">
            <h2 class="text-4xl">이미지 리사이저 사용 방법</h2>
            <div class="grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-4">
                <!-- Step 1 -->
                <div class="tutorial-card">
                    <h3>
                        <span class="tutorial-icon">
                            <i class="fas fa-cloud-upload-alt"></i>
                        </span>
                        이미지 업로드
                    </h3>
                    <div>
                        <p title="이미지를 업로드 영역에 직접 드래그 앤 드롭하거나 업로드 버튼을 클릭하여 기기에서 선택하세요. JPG, PNG, WebP 형식을 지원합니다.">이미지를 업로드 영역에 직접 드래그 앤 드롭하거나 업로드 버튼을 클릭하여 기기에서 선택하세요. JPG, PNG, WebP 형식을 지원합니다.</p>
                    </div>
                </div>
                <!-- Step 2 -->
                <div class="tutorial-card">
                    <h3>
                        <span class="tutorial-icon">
                            <i class="fas fa-sliders-h"></i>
                        </span>
                        옵션 선택
                    </h3>
                    <div>
                        <p title="세 가지 리사이즈 모드 중 선택하세요: 크기, 백분율, 또는 소셜 미디어용. 너비, 높이를 설정하거나 Facebook, Instagram, Twitter, YouTube용 프리셋을 선택하세요.">세 가지 리사이즈 모드 중 선택하세요: 크기, 백분율, 또는 소셜 미디어용. 너비, 높이를 설정하거나 Facebook, Instagram, Twitter, YouTube용 프리셋을 선택하세요.</p>
                    </div>
                </div>
                <!-- Step 3 -->
                <div class="tutorial-card">
                    <h3>
                        <span class="tutorial-icon">
                            <i class="fas fa-crop-alt"></i>
                        </span>
                        이미지 리사이즈
                    </h3>
                    <div>
                        <p title="이미지에 리사이즈 설정을 적용하세요. 이미지를 자르고, 회전하고, 뒤집을 수도 있습니다. 일괄 처리로 여러 이미지를 한 번에 리사이즈하세요.">이미지에 리사이즈 설정을 적용하세요. 이미지를 자르고, 회전하고, 뒤집을 수도 있습니다. 일괄 처리로 여러 이미지를 한 번에 리사이즈하세요.</p>
                    </div>
                </div>
                <!-- Step 4 -->
                <div class="tutorial-card">
                    <h3>
                        <span class="tutorial-icon">
                            <i class="fas fa-download"></i>
                        </span>
                        결과 다운로드
                    </h3>
                    <div>
                        <p title="형식 선택기는 원본 이미지 형식과 자동으로 일치합니다. PNG, JPG, WebP 형식을 수동으로 선택할 수도 있습니다. 내보내기를 클릭하여 리사이즈된 이미지를 다운로드하세요.">형식 선택기는 원본 이미지 형식과 자동으로 일치합니다. PNG, JPG, WebP 형식을 수동으로 선택할 수도 있습니다. 내보내기를 클릭하여 리사이즈된 이미지를 다운로드하세요.</p>
                    </div>
                </div>
            </div>
        </div>
    </section>

    <!-- Feature Introduction Area -->
    <section class="feature-section">
        <div class="container">
            <div class="grid-cols-2">
                <div class="content-image">
                    <img src="https://images.unsplash.com/photo-1542831371-29b0f74f9713?w=600&h=400&fit=crop" alt="Image Resizer">
                </div>
                <div class="content-text">
                    <h2>전문적인 이미지 리사이징</h2>
                    <p>정확하고 쉽게 이미지를 리사이즈하세요. 여러 가지 리사이징 옵션을 제공하여 어떤 목적에도 최적화된 이미지를 얻을 수 있습니다.</p>
                    <p>크기, 백분율로 리사이즈하거나 Facebook, Instagram, Twitter, YouTube용 소셜 미디어 프리셋을 사용하세요. 웹 디자이너, 소셜 미디어 관리자 및 이미지 작업자에게 완벽합니다.</p>
                </div>
            </div>
        </div>
    </section>

    <!-- Tool Features Area -->
    <section class="feature-section gray">
        <div class="container">
            <div class="grid-cols-2">
                <div class="content-text order-2 md:order-1">
                    <h2>강력한 리사이징 도구</h2>
                    <p>간단한 크기 조정부터 일괄 처리를까지, 전문적인 이미지 리사이징에 필요한 모든 기능을 갖추고 있습니다.</p>
                    <p>사용자 정의 가로세로비로 이미지를 자르고, 회전하고, 뒤집고, 배경색을 변경하거나 투명하게 만들 수 있습니다. PNG, JPG, WebP 형식으로 최적화된 품질로 내보낼 수 있습니다.</p>
                </div>
                <div class="content-image order-1 md:order-2">
                    <img src="https://images.unsplash.com/photo-1551288049-bebda4e38f71?w=600&h=400&fit=crop" alt="Resizing Tools">
                </div>
            </div>
        </div>
    </section>

    <!-- Privacy Security Area -->
    <section class="feature-section">
        <div class="container">
            <div class="grid-cols-2">
                <div class="content-image">
                    <img src="https://plus.unsplash.com/premium_photo-1687382111414-7b87afa5da34?w=600&h=400&fit=crop" alt="Privacy Protection">
                </div>
                <div class="content-text">
                    <h2>100% 개인정보 보호</h2>
                    <p>모든 이미지 처리가 브라우저에서 로컬로 이루어집니다. 이미지가 어떤 서버에도 업로드되지 않습니다.</p>
                    <p>데이터는 기기에서만 유지되어 민감한 이미지에 대한 완전한 개인정보 보호와 보안을 보장합니다.</p>
                </div>
            </div>
        </div>
    </section>

    <!-- Mobile Support Area -->
    <section class="feature-section gray">
        <div class="container">
            <div class="grid-cols-2">
                <div class="content-text order-2 md:order-1">
                    <h2>모바일 친화적 설계</h2>
                    <p>모바일 친화적인 설계로 언제 어디서나 이미지를 리사이즈하세요. 스마트폰과 태블릿에서 원활하게 작동하여 어디서나 이미지를 편집할 수 있습니다.</p>
                    <p>어떤 화면 크기에도 적응하는 반응형 인터페이스로 모바일 기기를 사용하여 쉽게 이미지를 업로드, 리사이즈, 다운로드할 수 있습니다. 설치할 앱이 없으며, 브라우저만 열고 리사이즈를 시작하세요.</p>
                </div>
                <div class="content-image order-1 md:order-2">
                    <img src="https://images.unsplash.com/photo-1520333789090-1afc82db536a?w=600&h=400&fit=crop" alt="Mobile-Friendly Design">
                </div>
            </div>
        </div>
    </section>

    <!-- Bottom Text Area -->
    <section class="bottom-text-section">
        <div class="container">
            <h2>무료로 이미지 리사이즈</h2>
            <p>복잡한 소프트웨어를 사용하여 이미지를 리사이즈하는 시대는 끝났습니다. CaliperTools Image Resizer로 무료로 손쉽게 이미지를 리사이즈할 수 있습니다. 가장 좋은 점은 브라우저가 있는 어떤 기기에서도 도구를 사용할 수 있으며, 다운로드나 설치가 필요 없다는 것입니다. 경험이 필요 없습니다!</p>
            <p class="mb-10">드래그 앤 드롭 편집기를 사용하여 이미지를 업로드하면, CaliperTools Image Resizer가 나머지 작업을 처리합니다. 완료되면 형식 선택기가 원본 이미지 형식과 자동으로 일치하거나, PNG, JPG, WebP를 수동으로 선택할 수 있습니다. 원하는 만큼 많은 사진을 리사이즈할 수 있으며, 모두 몇 번의 클릭으로 완료됩니다.</p>
            
            <h2>항상 고품질 리사이징</h2>
            <p>이미지를 리사이즈하는 동안 품질을 유지하세요. 고급 알고리즘을 사용하여 웹, 소셜 미디어 또는 인쇄용으로 리사이즈하든 이미지의 선명도와 세부 사항을 유지합니다.</p>
            <p>내장된 사용자 정의 옵션으로 크기, 백분율을 조정하거나 소셜 미디어 프리셋을 사용하여 어떤 플랫폼에도 완벽한 이미지를 만들 수 있습니다. 완벽하게 리사이즈된 이미지로 사진을 향상시키고 작업 흐름을 개선하세요.</p>
        </div>
    </section>

    <!-- Related Tools Area -->
    <section class="section related-tools">
        <div class="container">
            <h2 class="section-title">관련 도구</h2>
            <div class="tools-grid" id="relatedTools">
                <!-- Related tools will be dynamically generated by JS -->
            </div>
        </div>
    </section>
</main>
<script src="../scripts/script-related-tools.js"></script>
<script>
    // Initialize related tools
    document.addEventListener('DOMContentLoaded', function() {
        const currentSlug = 'image-resizer';
        if (typeof initRelatedTools === 'function') {
            initRelatedTools(currentSlug);
        }
    });
</script>

    

    
    <script>
// Execute after DOM is loaded
document.addEventListener('DOMContentLoaded', function() {
    // Social media preset data
    const socialPresets = {
        facebook: [
            { name: 'Profile', width: 170, height: 170 },
            { name: 'Cover', width: 820, height: 312 },
            { name: 'Post', width: 1200, height: 900 },
            { name: 'Ad', width: 1280, height: 720 }
        ],
        instagram: [
            { name: 'Profile', width: 110, height: 110 },
            { name: 'Post', width: 320, height: 320 },
            { name: 'Story', width: 1080, height: 1920 }
        ],
        twitter: [
            { name: 'Profile', width: 400, height: 400 },
            { name: 'Header', width: 1500, height: 500 },
            { name: 'Image', width: 1024, height: 512 },
            { name: 'Card', width: 1200, height: 628 },
            { name: 'Ad', width: 1200, height: 675 }
        ],
        youtube: [
            { name: 'Profile', width: 800, height: 800 },
            { name: 'Channel Art', width: 2560, height: 1440 },
            { name: 'Thumbnail', width: 1280, height: 720 }
        ]
    };

    // Rotation and flip related variables
    let currentRotateFlipImageIndex = -1;
    let originalRotateFlipImage = null;
    let rotateFlipData = {
        rotation: 0, // Rotation angle
        flipX: false, // Horizontal flip
        flipY: false // Vertical flip
    };

    // DOM element cache
    const elements = {
        // Rotation and flip related
        rotateFlipModal: document.getElementById('rotate-flip-modal'),
        rotateFlipImage: document.getElementById('rotate-flip-image'),
        closeRotateFlipBtn: document.getElementById('close-rotate-flip'),
        prevImageRotateBtn: document.getElementById('prev-image-rotate'),
        nextImageRotateBtn: document.getElementById('next-image-rotate'),
        rotateClockwiseBtn: document.getElementById('rotate-clockwise'),
        rotateCounterclockwiseBtn: document.getElementById('rotate-counterclockwise'),
        flipHorizontalBtn: document.getElementById('flip-horizontal'),
        flipVerticalBtn: document.getElementById('flip-vertical'),
        applyRotateFlipBtn: document.getElementById('apply-rotate-flip'),
        resetRotateFlipBtn: document.getElementById('reset-rotate-flip'),
        rotateFlipNavigation: document.getElementById('rotate-flip-navigation'),
        // Upload related
        uploadBtn: document.getElementById('upload-btn'),
        fileInput: document.getElementById('file-input'),
        deleteAllBtn: document.getElementById('delete-all-btn'),
        uploadPrompt: document.getElementById('upload-prompt'),
        imageContainer: document.getElementById('image-container'),
        
        // Modal box related
        deleteModal: document.getElementById('delete-modal'),
        cancelDeleteBtn: document.getElementById('cancel-delete'),
        confirmDeleteBtn: document.getElementById('confirm-delete'),
        deleteImageModal: document.getElementById('delete-image-modal'),
        cancelDeleteImageBtn: document.getElementById('cancel-delete-image'),
        confirmDeleteImageBtn: document.getElementById('confirm-delete-image'),
        
        // Tab related
        tabs: document.querySelectorAll('.tab'),
        tabContents: document.querySelectorAll('.tab-content'),
        
        // Export related
        exportBtn: document.getElementById('export-btn'),
        zipBtn: document.getElementById('zip-btn'),

        
        // Dimensions related
        widthInputDim: document.getElementById('width-dim'),
        heightInputDim: document.getElementById('height-dim'),
        lockAspectDimCheckbox: document.getElementById('lock-aspect-dim'),
        backgroundOptionsDim: document.getElementById('background-options-dim'),
        
        // Percentage related
        percentageSlider: document.getElementById('percentage-slider'),
        percentageDisplay: document.getElementById('percentage-display'),
        percentageInput: document.getElementById('percentage-input'),
        
        // Social media related
        socialPlatformSelect: document.getElementById('social-platform'),
        socialPresetSelect: document.getElementById('social-preset'),
        widthInputSocial: document.getElementById('width-social'),
        heightInputSocial: document.getElementById('height-social'),
        lockAspectSocialCheckbox: document.getElementById('lock-aspect-social'),
        backgroundOptionsSocial: document.getElementById('background-options-social'),
        
        // Export settings related
        fileSizeInput: document.getElementById('file-size'),
        sizeUnitSelect: document.getElementById('size-unit'),
        saveAsSelect: document.getElementById('save-as'),
        

    };

    // Store uploaded image information
    let uploadedImages = [];
    let currentTab = 'dimensions'; // Current active tab
    let currentSocialPreset = null; // Current selected social media preset
    let imageToDelete = -1; // Index of image to delete
    // Store current image pixel dimensions
    let currentPixelWidth = 0;
    let currentPixelHeight = 0;
    // Store Original Aspect Ratio
    let originalAspectRatio = 1;

    // Initialize
    function init() {
        // Validate if all necessary elements exist
        if (!validateElements()) {
            console.error('Critical DOM elements missing, unable to initialize application');
            return;
        }
        
        // Parse URL parameters first
        parseUrlParams();
        
        // Set event listeners
        setupEventListeners();
        
        // Set Color Picker
        setupColorPicker('color-picker-dim', 'color-code-dim');
        setupColorPicker('color-picker-social', 'color-code-social');
        
        // Set mutex relationship for background and transparency options
        setupBackgroundTransparencyMutex('use-background-dim', 'use-transparency-dim');
        setupBackgroundTransparencyMutex('use-background-social', 'use-transparency-social');
        
        // Set aspect ratio locking for all tabs
        setupDimensionAspectLock(
            elements.widthInputDim, 
            elements.heightInputDim, 
            elements.lockAspectDimCheckbox,
            'dim'
        );
        setupDimensionAspectLock(
            elements.widthInputSocial, 
            elements.heightInputSocial, 
            elements.lockAspectSocialCheckbox,
            'social'
        );
        
        // Set unit conversion for all tabs (using fixed DPI conversion)
        
        // Initialize state
        checkLockAspectForBackground('dim');
        checkLockAspectForBackground('perc');
        checkLockAspectForBackground('social');
        
        // Initialize percentage slider and input box linkage
        setupPercentageSync();

        // Initialize rotation and flip functionality
        setupRotateFlipFunctionality();
        
        // Initially hide image container
        elements.imageContainer.style.display = 'none';
    }

    // Validate if necessary DOM elements exist
    function validateElements() {
        for (const [key, element] of Object.entries(elements)) {
            if (element === null || element === undefined) {
                console.error(`Missing necessary DOM element: ${key}`);
                return false;
            }
        }
        return true;
    }

    // Set all event listeners
    function setupEventListeners() {
        // Upload image
        elements.uploadBtn.addEventListener('click', () => {
            elements.fileInput.click();
        });

        // Click on upload prompt to upload
        elements.uploadPrompt.addEventListener('click', () => {
            elements.fileInput.click();
        });

        elements.fileInput.addEventListener('change', handleFileUpload);

        // Drag and drop upload
        const gallery = document.querySelector('.gallery');
        gallery.addEventListener('dragover', (e) => {
            e.preventDefault();
            elements.uploadPrompt.classList.add('drag-over');
        });

        gallery.addEventListener('dragleave', () => {
            elements.uploadPrompt.classList.remove('drag-over');
        });

        gallery.addEventListener('drop', (e) => {
            e.preventDefault();
            elements.uploadPrompt.classList.remove('drag-over');
            const files = e.dataTransfer.files;
            if (files.length) {
                handleFiles(files);
            }
        });

        // Copy and paste upload
        document.addEventListener('paste', (e) => {
            const items = (e.clipboardData || e.originalEvent.clipboardData).items;
            for (let item of items) {
                if (item.kind === 'file') {
                    const file = item.getAsFile();
                    if (file.type.startsWith('image/')) {
                        handleFiles([file]);
                    }
                }
            }
        });

        // Delete all images related
        elements.deleteAllBtn.addEventListener('click', () => {
            if (uploadedImages.length > 0) {
                elements.deleteModal.classList.add('show');
            }
        });

        elements.cancelDeleteBtn.addEventListener('click', () => {
            elements.deleteModal.classList.remove('show');
        });

        elements.confirmDeleteBtn.addEventListener('click', () => {
            elements.imageContainer.innerHTML = '';
            uploadedImages = [];
            currentPixelWidth = 0;
            currentPixelHeight = 0;
            originalAspectRatio = 1;
            elements.deleteModal.classList.remove('show');
            // Show upload prompt, hide image container
            elements.uploadPrompt.style.display = 'flex';
            elements.imageContainer.style.display = 'none';
            
            // Reset to original state
            resetToOriginalState();
        });

        // Single image delete related
        elements.cancelDeleteImageBtn.addEventListener('click', () => {
            elements.deleteImageModal.classList.remove('show');
            imageToDelete = -1;
        });

        elements.confirmDeleteImageBtn.addEventListener('click', () => {
            if (imageToDelete !== -1 && imageToDelete < uploadedImages.length) {
                // Remove image data
                uploadedImages.splice(imageToDelete, 1);
                
                // Update current image index
                if (currentCropImageIndex === imageToDelete) {
                    currentCropImageIndex = -1; // Reset crop image index
                    // Close crop modal
                    if (cropElements && cropElements.cropModal) {
                        cropElements.cropModal.classList.remove('show');
                    }
                } else if (currentCropImageIndex > imageToDelete) {
                    currentCropImageIndex--; // Adjust index
                }
                
                if (currentRotateFlipImageIndex === imageToDelete) {
                    currentRotateFlipImageIndex = -1; // Reset rotation flip image index
                    // Close rotation flip modal
                    if (elements.rotateFlipModal) {
                        elements.rotateFlipModal.classList.remove('show');
                    }
                } else if (currentRotateFlipImageIndex > imageToDelete) {
                    currentRotateFlipImageIndex--; // Adjust index
                }
                
                // Close delete image modal
                elements.deleteImageModal.classList.remove('show');
                
                // Re-render images
                renderImages();
                
                // If no images, show upload prompt and reset to original state
                if (uploadedImages.length === 0) {
                    elements.uploadPrompt.style.display = 'flex';
                    elements.imageContainer.style.display = 'none';
                    currentPixelWidth = 0;
                    currentPixelHeight = 0;
                    originalAspectRatio = 1;
                    resetToOriginalState();
                } else if (imageToDelete === 0) {
                    // If first image is deleted, update dimension inputs
                    updateDimensionInputsWithFirstImage();
                }
                
                elements.deleteImageModal.classList.remove('show');
                imageToDelete = -1;
            }
        });

        // Close modal when clicking outside area
        window.addEventListener('click', (e) => {
            if (e.target === elements.deleteModal) {
                elements.deleteModal.classList.remove('show');
            }
            if (e.target === elements.deleteImageModal) {
                elements.deleteImageModal.classList.remove('show');
                imageToDelete = -1;
            }

        });

        // Tab switching
        elements.tabs.forEach(tab => {
            tab.addEventListener('click', () => {
                const tabId = tab.getAttribute('data-tab');
                currentTab = tabId;

                elements.tabs.forEach(t => t.classList.remove('active'));
                tab.classList.add('active');

                elements.tabContents.forEach(content => {
                    content.classList.remove('active');
                    if (content.id === tabId) {
                        content.classList.add('active');
                    }
                });

                // Check background options display status for current tab
                checkLockAspectForBackground(tabId === 'dimensions' ? 'dim' : 
                                           tabId === 'percentage' ? 'perc' : 'social');

                updateImageDimensions();

                // Update URL based on tab
                updateUrlForTab(tabId);
            });
        });

        // Social media platform selection change
        elements.socialPlatformSelect.addEventListener('change', () => {
            const platform = elements.socialPlatformSelect.value;
            elements.socialPresetSelect.innerHTML = '';
            
            // Update URL based on platform
            updateUrlForPlatform(platform);
            
            if (!platform) {
                const option = document.createElement('option');
                option.value = '';
                option.textContent = 'Please select platform first';
                elements.socialPresetSelect.appendChild(option);
                if (uploadedImages.length > 0) {
                    elements.widthInputSocial.value = uploadedImages[0].originalWidth;
                    elements.heightInputSocial.value = uploadedImages[0].originalHeight;
                    currentPixelWidth = uploadedImages[0].originalWidth;
                    currentPixelHeight = uploadedImages[0].originalHeight;
                } else {
                    elements.widthInputSocial.value = '';
                    elements.heightInputSocial.value = '';
                    currentPixelWidth = 0;
                    currentPixelHeight = 0;
                }
                currentSocialPreset = null;
            } else {
                // Add preset options for selected platform
                socialPresets[platform].forEach(preset => {
                    const option = document.createElement('option');
                    option.value = JSON.stringify(preset);
                    option.textContent = `${preset.name} (${preset.width} x ${preset.height} px)`;
                    elements.socialPresetSelect.appendChild(option);
                });
                
                // Auto-select first preset
                if (socialPresets[platform].length > 0) {
                    elements.socialPresetSelect.selectedIndex = 0;
                    const firstPreset = socialPresets[platform][0];
                    elements.widthInputSocial.value = firstPreset.width;
                    elements.heightInputSocial.value = firstPreset.height;
                    currentSocialPreset = firstPreset;
                    // Update pixel size record
                    currentPixelWidth = firstPreset.width;
                    currentPixelHeight = firstPreset.height;
                }
            }
            
            updateImageDimensions();
        });

        // Social media preset selection change
        elements.socialPresetSelect.addEventListener('change', () => {
            const presetStr = elements.socialPresetSelect.value;
            if (presetStr) {
                currentSocialPreset = JSON.parse(presetStr);
                elements.widthInputSocial.value = currentSocialPreset.width;
                elements.heightInputSocial.value = currentSocialPreset.height;
                // Update pixel size record
                currentPixelWidth = currentSocialPreset.width;
                currentPixelHeight = currentSocialPreset.height;
            } else {
                currentSocialPreset = null;
                if (uploadedImages.length > 0) {
                    elements.widthInputSocial.value = uploadedImages[0].originalWidth;
                    elements.heightInputSocial.value = uploadedImages[0].originalHeight;
                    currentPixelWidth = uploadedImages[0].originalWidth;
                    currentPixelHeight = uploadedImages[0].originalHeight;
                } else {
                    elements.widthInputSocial.value = '';
                    elements.heightInputSocial.value = '';
                    currentPixelWidth = 0;
                    currentPixelHeight = 0;
                }
            }
            updateImageDimensions();
        });

        // Image processing function
        function processImage(image) {
            return new Promise((resolve) => {
                const canvas = document.createElement('canvas');
                const ctx = canvas.getContext('2d');
                
                // Fixed export resolution to 72 DPI (for web use)
                const exportDPI = 72;
                const defaultDPI = 72;
                
                // Calculate DPI scaling factor
                const dpiScale = exportDPI / defaultDPI;
                
                // Calculate new dimensions based on current settings (considering DPI scaling)
                let displayWidth = currentPixelWidth;
                let displayHeight = currentPixelHeight;
                
                // Set canvas actual size (pixels = display size × DPI scaling factor)
                canvas.width = Math.round(displayWidth * dpiScale);
                canvas.height = Math.round(displayHeight * dpiScale);
                
                // Set CSS display size to ensure image displays correctly
                canvas.style.width = `${displayWidth}px`;
                canvas.style.height = `${displayHeight}px`;
                
                // Set Canvas context scaling factor to ensure drawn content scales according to DPI
                ctx.scale(dpiScale, dpiScale);
                
                // Decide whether to fill background color based on user selection
                const useBackgroundDim = document.getElementById('use-background-dim');
                const useTransparencyDim = document.getElementById('use-transparency-dim');
                const useBackgroundSocial = document.getElementById('use-background-social');
                const useTransparencySocial = document.getElementById('use-transparency-social');
                
                // Check background settings for current tab
                let shouldUseBackground = false;
                let shouldUseTransparent = false;
                let backgroundColor = '#FFFFFF'; // Default white
                
                if (currentTab === 'dimensions' || currentTab === 'percentage') {
                    if (useTransparencyDim && useTransparencyDim.checked) {
                        shouldUseTransparent = true; // Transparent background
                    } else if (useBackgroundDim && useBackgroundDim.checked) {
                        shouldUseBackground = true;
                        // Get color picker value
                        const colorPicker = document.getElementById('color-picker-dim');
                        if (colorPicker) {
                            backgroundColor = colorPicker.value;
                        }
                    }
                } else if (currentTab === 'social') {
                    if (useTransparencySocial && useTransparencySocial.checked) {
                        shouldUseTransparent = true; // Transparent background
                    } else if (useBackgroundSocial && useBackgroundSocial.checked) {
                        shouldUseBackground = true;
                        // Get color picker value
                        const colorPicker = document.getElementById('color-picker-social');
                        if (colorPicker) {
                            backgroundColor = colorPicker.value;
                        }
                    }
                }
                
                // Draw image (centered)
                const img = new Image();
                img.crossOrigin = 'anonymous';
                img.src = image.src;
                img.onload = () => {
                    // Draw image directly according to set dimensions, without preserving original aspect ratio
                    ctx.drawImage(img, 0, 0, displayWidth, displayHeight);
                    
                    // If user selected Transparent or Select Color, process the image to remove/replace background
                    if (shouldUseTransparent || shouldUseBackground) {
                        const imageData = ctx.getImageData(0, 0, displayWidth, displayHeight);
                        const data = imageData.data;
                        
                        // Get background color from top-left corner pixel
                        const bgR = data[0];
                        const bgG = data[1];
                        const bgB = data[2];
                        
                        // Process each pixel
                        for (let i = 0; i < data.length; i += 4) {
                            const r = data[i];
                            const g = data[i + 1];
                            const b = data[i + 2];
                            
                            // Check if pixel matches background color (with some tolerance)
                            const tolerance = 30;
                            if (Math.abs(r - bgR) < tolerance && 
                                Math.abs(g - bgG) < tolerance && 
                                Math.abs(b - bgB) < tolerance) {
                                if (shouldUseTransparent) {
                                    // Make transparent
                                    data[i + 3] = 0;
                                } else if (shouldUseBackground) {
                                    // Replace with selected color
                                    const hexColor = backgroundColor;
                                    const colorR = parseInt(hexColor.slice(1, 3), 16);
                                    const colorG = parseInt(hexColor.slice(3, 5), 16);
                                    const colorB = parseInt(hexColor.slice(5, 7), 16);
                                    data[i] = colorR;
                                    data[i + 1] = colorG;
                                    data[i + 2] = colorB;
                                    data[i + 3] = 255;
                                }
                            }
                        }
                        
                        ctx.putImageData(imageData, 0, 0);
                    }
                    
                    // Convert image according to save format
                    let saveFormat = elements.saveAsSelect.value === 'original' ? 
                        image.file.type.split('/')[1] : elements.saveAsSelect.value;
                    
                    // If transparent background is selected, force PNG format
                    if (shouldUseTransparent) {
                        saveFormat = 'png';
                    }
                    
                    // Generate image with DPI information
                    const dataURL = canvas.toDataURL(`image/${saveFormat}`);
                    
                    // For PNG format, we need to manually embed DPI information
                    // For JPEG and other formats, use canvas directly (canvas is already set to 72 DPI)
                    if (saveFormat === 'png') {
                        // Convert to Blob and embed DPI information
                        createImageWithDPI(dataURL, exportDPI, saveFormat, shouldUseBackground ? backgroundColor : null, shouldUseTransparent).then(blob => {
                            resolve({
                                blob: blob,
                                name: `${image.name.split('.')[0]}.${saveFormat}`,
                                format: saveFormat,
                                dpi: exportDPI
                            });
                        });
                    } else {
                        canvas.toBlob((blob) => {
                            resolve({
                                blob: blob,
                                name: `${image.name.split('.')[0]}.${saveFormat}`,
                                format: saveFormat,
                                dpi: exportDPI
                            });
                        }, `image/${saveFormat}`);
                    }
                };
            });
        }
        
        // Export functionality
        elements.exportBtn.addEventListener('click', async () => {
            if (uploadedImages.length === 0) {
                alert('Please upload images first');
                return;
            }
            
            // Process and download each image
            for (let i = 0; i < uploadedImages.length; i++) {
                const processedImage = await processImage(uploadedImages[i]);
                
                // Create download link
                const url = URL.createObjectURL(processedImage.blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = processedImage.name;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
            }
        });

        // ZIP packaging functionality
        elements.zipBtn.addEventListener('click', async () => {
            if (uploadedImages.length === 0) {
                alert('Please upload images first');
                return;
            }
            
            const zip = new JSZip();
            
            // Process all images
            for (let i = 0; i < uploadedImages.length; i++) {
                const processedImage = await processImage(uploadedImages[i]);
                zip.file(processedImage.name, processedImage.blob);
            }
            
            // Generate ZIP file
            zip.generateAsync({ type: 'blob' }).then((content) => {
                // Create download link
                const url = URL.createObjectURL(content);
                const a = document.createElement('a');
                a.href = url;
                a.download = 'images.zip';
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
            });
        });

        // Save format selection change
        elements.saveAsSelect.addEventListener('change', () => {
            const format = elements.saveAsSelect.value;
            updateUrlForFormat(format);
        });
    }

    // Crop related variables
    let currentCropImageIndex = -1;
    let originalCropImage = null;
    let cropData = {
        x: 0,
        y: 0,
        width: 0,
        height: 0,
        aspectRatio: null,
        imageNaturalWidth: 0,
        imageNaturalHeight: 0,
        scale: 1
    };
    let isDragging = false;
    let isResizing = false;
    let resizeHandle = null;
    let startX, startY, startCropX, startCropY, startCropWidth, startCropHeight;

    // Crop DOM elements
    const cropElements = {
        cropModal: document.getElementById('cropModal'),
        closeCropModal: document.getElementById('closeCropModal'),
        prevImageCropBtn: document.getElementById('prevImageCropBtn'),
        nextImageCropBtn: document.getElementById('nextImageCropBtn'),
        cropImage: document.getElementById('cropImage'),
        cropSelection: document.getElementById('cropSelection'),
        cropImageContainer: document.getElementById('cropImageContainer'),
        cropWidth: document.getElementById('cropWidth'),
        cropHeight: document.getElementById('cropHeight'),
        aspectRatioSelect: document.getElementById('aspectRatioSelect'),
        customRatioGroup: document.getElementById('customRatioGroup'),
        customRatioX: document.getElementById('customRatioX'),
        customRatioY: document.getElementById('customRatioY'),
        cropPositionX: document.getElementById('cropPositionX'),
        cropPositionY: document.getElementById('cropPositionY'),
        applyCropBtn: document.getElementById('applyCropBtn'),
        resetCropBtn: document.getElementById('resetCropBtn'),
        cropModalNavigation: document.getElementById('cropModalNavigation')
    };

    // Set crop functionality
    function setupCropFunctionality() {
        // Close crop window
        cropElements.closeCropModal.addEventListener('click', () => {
            cropElements.cropModal.classList.remove('show');
        });

        // Previous/next image navigation
        cropElements.prevImageCropBtn.addEventListener('click', () => {
            if (uploadedImages.length <= 1) return;
            currentCropImageIndex = (currentCropImageIndex - 1 + uploadedImages.length) % uploadedImages.length;
            openCropModal(currentCropImageIndex);
        });

        cropElements.nextImageCropBtn.addEventListener('click', () => {
            if (uploadedImages.length <= 1) return;
            currentCropImageIndex = (currentCropImageIndex + 1) % uploadedImages.length;
            openCropModal(currentCropImageIndex);
        });

        // Aspect ratio selection change
        cropElements.aspectRatioSelect.addEventListener('change', () => {
            const selectedValue = cropElements.aspectRatioSelect.value;
            cropElements.customRatioGroup.style.display = selectedValue === 'custom' ? 'flex' : 'none';

            if (selectedValue === 'free') {
                cropData.aspectRatio = null;
                resetCropSelection();
            } else if (selectedValue === 'original') {
                cropData.aspectRatio = originalCropImage.naturalWidth / originalCropImage.naturalHeight;
                resetCropSelection();
            } else if (selectedValue === 'custom') {
                // Custom ratio will be applied after user input
                cropData.aspectRatio = null;
            }
        });

        // Custom ratio input change
        cropElements.customRatioX.addEventListener('input', updateCustomRatio);
        cropElements.customRatioY.addEventListener('input', updateCustomRatio);

        // Crop size input change
        cropElements.cropWidth.addEventListener('input', () => {
            let width = parseInt(cropElements.cropWidth.value) || 0;
            if (cropData.aspectRatio && !isNaN(cropData.aspectRatio)) {
                cropData.width = width;
                cropData.height = width / cropData.aspectRatio;
                cropElements.cropHeight.value = Math.round(cropData.height);
            } else {
                cropData.width = width;
            }
            constrainCropSize();
            updateCropSelection();
        });

        cropElements.cropHeight.addEventListener('input', () => {
            let height = parseInt(cropElements.cropHeight.value) || 0;
            if (cropData.aspectRatio && !isNaN(cropData.aspectRatio)) {
                cropData.height = height;
                cropData.width = height * cropData.aspectRatio;
                cropElements.cropWidth.value = Math.round(cropData.width);
            } else {
                cropData.height = height;
            }
            constrainCropSize();
            updateCropSelection();
        });

        // Crop position input change
        cropElements.cropPositionX.addEventListener('input', () => {
            cropData.x = parseInt(cropElements.cropPositionX.value) || 0;
            constrainCropPosition();
            updateCropSelection();
        });

        cropElements.cropPositionY.addEventListener('input', () => {
            cropData.y = parseInt(cropElements.cropPositionY.value) || 0;
            constrainCropPosition();
            updateCropSelection();
        });

        // Apply crop
        cropElements.applyCropBtn.addEventListener('click', applyCrop);

        // Reset Crop
        cropElements.resetCropBtn.addEventListener('click', resetCropSelection);

        // Set crop selection area event listener
        setupCropSelectionEvents();
    }

    // Update custom ratio
    function updateCustomRatio() {
        const x = parseInt(cropElements.customRatioX.value) || 1;
        const y = parseInt(cropElements.customRatioY.value) || 1;
        cropData.aspectRatio = x / y;
        resetCropSelection();
    }

    // Set crop selection area event listener
    function setupCropSelectionEvents() {
        // Crop area dragging - Only triggers inside crop box area (not on borders and handles)
        cropElements.cropSelection.addEventListener('mousedown', (e) => {
            // Check if click is inside crop box (not on borders and handles)
            const isOnHandle = e.target.classList.contains('crop-handle');
            const isOnBorder = e.target.classList.contains('crop-selection-top') || 
                              e.target.classList.contains('crop-selection-bottom') ||
                              e.target.classList.contains('crop-selection-left') ||
                              e.target.classList.contains('crop-selection-right');
            
            if (!isOnHandle && !isOnBorder) {
                startDrag(e);
            }
        });
        document.addEventListener('mousemove', drag);
        document.addEventListener('mouseup', stopDrag);

        // Resize Handle Events
        const handles = cropElements.cropSelection.querySelectorAll('.crop-handle');
        handles.forEach(handle => {
            handle.addEventListener('mousedown', (e) => {
                e.stopPropagation(); // Prevent event propagation
                startResize(e, handle);
            });
        });
        
        // Resize border event - Top border
        const topBorder = cropElements.cropSelection.querySelector('.crop-selection-top');
        if (topBorder) {
            topBorder.addEventListener('mousedown', (e) => {
                e.stopPropagation(); // Prevent event propagation
                // Create a virtual middle top handle
                const fakeHandle = document.createElement('div');
                fakeHandle.className = 'crop-handle top-middle';
                startResize(e, fakeHandle);
            });
        }
        
        // Resize border event - Bottom border
        const bottomBorder = cropElements.cropSelection.querySelector('.crop-selection-bottom');
        if (bottomBorder) {
            bottomBorder.addEventListener('mousedown', (e) => {
                e.stopPropagation(); // Prevent event propagation
                // Create a virtual middle bottom handle
                const fakeHandle = document.createElement('div');
                fakeHandle.className = 'crop-handle bottom-middle';
                startResize(e, fakeHandle);
            });
        }
        
        // Resize border event - Left border
        const leftBorder = cropElements.cropSelection.querySelector('.crop-selection-left');
        if (leftBorder) {
            leftBorder.addEventListener('mousedown', (e) => {
                e.stopPropagation(); // Prevent event propagation
                // Create a virtual middle left handle
                const fakeHandle = document.createElement('div');
                fakeHandle.className = 'crop-handle middle-left';
                startResize(e, fakeHandle);
            });
        }
        
        // Resize border event - Right border
        const rightBorder = cropElements.cropSelection.querySelector('.crop-selection-right');
        if (rightBorder) {
            rightBorder.addEventListener('mousedown', (e) => {
                e.stopPropagation(); // Prevent event propagation
                // Create a virtual middle right handle
                const fakeHandle = document.createElement('div');
                fakeHandle.className = 'crop-handle middle-right';
                startResize(e, fakeHandle);
            });
        }
    }

    // Start dragging
    function startDrag(e) {
        // Only trigger dragging when clicking on crop box itself or grid, not on borders and handles
        const isOnHandle = e.target.classList.contains('crop-handle');
        const isOnBorder = e.target.classList.contains('crop-selection-top') || 
                          e.target.classList.contains('crop-selection-bottom') ||
                          e.target.classList.contains('crop-selection-left') ||
                          e.target.classList.contains('crop-selection-right');
        
        // Check if click is inside crop box (but not on control points or borders)
        const isOnCropSelection = e.target === cropElements.cropSelection || 
                                 e.target.classList.contains('crop-grid') ||
                                 cropElements.cropSelection.contains(e.target);
        
        if (isOnCropSelection && !isOnHandle && !isOnBorder) {
            isDragging = true;
            startX = e.clientX;
            startY = e.clientY;
            startCropX = cropData.x;
            startCropY = cropData.y;
            cropElements.cropSelection.style.cursor = 'grabbing';
            e.preventDefault();
        }
    }

    // During dragging
    function drag(e) {
        if (isDragging) {
            const dx = (e.clientX - startX) / cropData.scale;
            const dy = (e.clientY - startY) / cropData.scale;

            // Calculate new position
            let newX = startCropX + dx;
            let newY = startCropY + dy;
            
            // Ensure crop box is completely within image bounds
            const imageWidth = cropData.imageNaturalWidth;
            const imageHeight = cropData.imageNaturalHeight;
            
            // Limit top-left corner
            newX = Math.max(0, newX);
            newY = Math.max(0, newY);
            
            // Limit bottom-right corner
            newX = Math.min(newX, imageWidth - cropData.width);
            newY = Math.min(newY, imageHeight - cropData.height);
            
            // Update crop data
            cropData.x = newX;
            cropData.y = newY;

            // Save crop state to current image
            if (currentCropImageIndex !== -1 && currentCropImageIndex < uploadedImages.length) {
                const imageInfo = uploadedImages[currentCropImageIndex];
                imageInfo.cropData.x = cropData.x;
                imageInfo.cropData.y = cropData.y;
            }

            // Update UI
            updateCropSelection();
            updateCropPositionInputs();
        } else if (isResizing && resizeHandle) {
            resizeCrop(e);
        }
    }

    // Stop dragging
    function stopDrag() {
        isDragging = false;
        isResizing = false;
        resizeHandle = null;
        cropElements.cropSelection.style.cursor = 'move';
    }

    // Start resizing
    function startResize(e, handle) {
        isResizing = true;
        resizeHandle = handle;
        startX = e.clientX;
        startY = e.clientY;
        startCropX = cropData.x;
        startCropY = cropData.y;
        startCropWidth = cropData.width;
        startCropHeight = cropData.height;
        e.preventDefault();
    }

    // Resize logic (corrected)
    function resizeCrop(e) {
        const dx = (e.clientX - startX) / cropData.scale;
        const dy = (e.clientY - startY) / cropData.scale;

        // Reset crop data to initial state
        cropData.x = startCropX;
        cropData.y = startCropY;
        cropData.width = startCropWidth;
        cropData.height = startCropHeight;

        // Only apply correction logic when not in free ratio (exclude free ratio)
        const isFixedRatio = cropData.aspectRatio && !isNaN(cropData.aspectRatio);
        const EDGE_TOLERANCE = 1; // Edge tolerance (pixels)
        let isHitTopOrBottomEdge = false; // Mark if top/bottom edges touched (for subsequent ratio validation)

        switch (resizeHandle.className) {
            // -------------------------- Corner Handles (Solving Issue ①) --------------------------
            case 'crop-handle bottom-right':
                if (isFixedRatio) {
                    const fixedLeft = startCropX;
                    const fixedTop = startCropY;
                    const maxWidth = cropData.imageNaturalWidth - fixedLeft;
                    const maxHeight = cropData.imageNaturalHeight - fixedTop;
                    
                    let newWidth = Math.min(maxWidth, startCropWidth + dx);
                    let newHeight = Math.min(maxHeight, startCropHeight + dy);
                    newWidth = Math.max(10, newWidth);
                    newHeight = Math.max(10, newHeight);

                    const hitRightEdge = newWidth >= maxWidth - EDGE_TOLERANCE;
                    const hitBottomEdge = newHeight >= maxHeight - EDGE_TOLERANCE;
                    isHitTopOrBottomEdge = hitBottomEdge; // Mark bottom edge touched

                    if (hitRightEdge) {
                        newWidth = maxWidth; // Force lock width
                        newHeight = newWidth / cropData.aspectRatio;
                        newHeight = Math.min(newHeight, maxHeight);
                    } else if (hitBottomEdge) {
                        newHeight = maxHeight; // Force lock height
                        newWidth = newHeight * cropData.aspectRatio;
                        newWidth = Math.min(newWidth, maxWidth);
                    } else {
                        newHeight = newWidth / cropData.aspectRatio;
                    }

                    cropData.width = newWidth;
                    cropData.height = newHeight;
                } else {
                    cropData.width = Math.min(cropData.imageNaturalWidth - startCropX, startCropWidth + dx);
                    cropData.height = Math.min(cropData.imageNaturalHeight - startCropY, startCropHeight + dy);
                }
                break;

            case 'crop-handle bottom-left':
                if (isFixedRatio) {
                    const fixedRight = startCropX + startCropWidth;
                    const fixedTop = startCropY;
                    const maxHeight = cropData.imageNaturalHeight - fixedTop;
                    
                    let newX = Math.max(0, startCropX + dx);
                    let newHeight = Math.min(maxHeight, startCropHeight + dy);
                    newHeight = Math.max(10, newHeight);
                    let newWidth = fixedRight - newX;
                    newWidth = Math.max(10, newWidth);

                    const hitLeftEdge = newX <= EDGE_TOLERANCE;
                    const hitBottomEdge = newHeight >= maxHeight - EDGE_TOLERANCE;
                    isHitTopOrBottomEdge = hitBottomEdge;

                    if (hitLeftEdge) {
                        newX = 0;
                        newWidth = fixedRight - newX;
                        newHeight = newWidth / cropData.aspectRatio;
                        newHeight = Math.min(newHeight, maxHeight);
                    } else if (hitBottomEdge) {
                        newHeight = maxHeight; // Force lock height
                        newWidth = newHeight * cropData.aspectRatio;
                        newX = fixedRight - newWidth;
                        newX = Math.max(0, newX);
                    } else {
                        newHeight = newWidth / cropData.aspectRatio;
                    }

                    cropData.x = newX;
                    cropData.width = newWidth;
                    cropData.height = newHeight;
                } else {
                    cropData.x = Math.max(0, startCropX + dx);
                    cropData.width = Math.max(10, startCropX + startCropWidth - cropData.x);
                    cropData.height = Math.min(cropData.imageNaturalHeight - startCropY, startCropHeight + dy);
                }
                break;

            case 'crop-handle top-left':
                if (isFixedRatio) {
                    const fixedRight = startCropX + startCropWidth;
                    const fixedBottom = startCropY + startCropHeight;
                    const minY = 0;
                    
                    let newX = Math.max(0, startCropX + dx);
                    let newY = Math.max(minY, startCropY + dy);
                    let newWidth = fixedRight - newX;
                    let newHeight = fixedBottom - newY;
                    newWidth = Math.max(10, newWidth);
                    newHeight = Math.max(10, newHeight);

                    const hitLeftEdge = newX <= EDGE_TOLERANCE;
                    const hitTopEdge = newY <= EDGE_TOLERANCE;
                    isHitTopOrBottomEdge = hitTopEdge; // Mark top edge touched

                    if (hitLeftEdge) {
                        newX = 0;
                        newWidth = fixedRight - newX;
                        newHeight = newWidth / cropData.aspectRatio;
                        newY = fixedBottom - newHeight;
                        newY = Math.max(minY, newY);
                    } else if (hitTopEdge) {
                        newY = minY; // Force lock y coordinate (top edge)
                        newHeight = fixedBottom - newY;
                        newWidth = newHeight * cropData.aspectRatio;
                        newX = fixedRight - newWidth;
                        newX = Math.max(0, newX);
                    } else {
                        newHeight = newWidth / cropData.aspectRatio;
                        newY = fixedBottom - newHeight;
                    }

                    cropData.x = newX;
                    cropData.y = newY;
                    cropData.width = newWidth;
                    cropData.height = newHeight;
                } else {
                    cropData.x = Math.max(0, startCropX + dx);
                    cropData.y = Math.max(0, startCropY + dy);
                    cropData.width = Math.max(10, startCropX + startCropWidth - cropData.x);
                    cropData.height = Math.max(10, startCropY + startCropHeight - cropData.y);
                }
                break;

            case 'crop-handle top-right':
                if (isFixedRatio) {
                    const fixedLeft = startCropX;
                    const fixedBottom = startCropY + startCropHeight;
                    const minY = 0;
                    
                    let newY = Math.max(minY, startCropY + dy);
                    let newWidth = Math.min(cropData.imageNaturalWidth - fixedLeft, startCropWidth + dx);
                    newWidth = Math.max(10, newWidth);
                    let newHeight = fixedBottom - newY;
                    newHeight = Math.max(10, newHeight);

                    const hitRightEdge = newWidth >= (cropData.imageNaturalWidth - fixedLeft) - EDGE_TOLERANCE;
                    const hitTopEdge = newY <= EDGE_TOLERANCE;
                    isHitTopOrBottomEdge = hitTopEdge;

                    if (hitRightEdge) {
                        newWidth = cropData.imageNaturalWidth - fixedLeft;
                        newHeight = newWidth / cropData.aspectRatio;
                        newY = fixedBottom - newHeight;
                        newY = Math.max(minY, newY);
                    } else if (hitTopEdge) {
                        newY = minY; // Force lock y coordinate (top edge)
                        newHeight = fixedBottom - newY;
                        newWidth = newHeight * cropData.aspectRatio;
                        newWidth = Math.min(newWidth, cropData.imageNaturalWidth - fixedLeft);
                    } else {
                        newHeight = newWidth / cropData.aspectRatio;
                        newY = fixedBottom - newHeight;
                    }

                    cropData.y = newY;
                    cropData.width = newWidth;
                    cropData.height = newHeight;
                } else {
                    cropData.y = Math.max(0, startCropY + dy);
                    cropData.width = Math.min(cropData.imageNaturalWidth - startCropX, startCropWidth + dx);
                    cropData.height = Math.max(10, startCropY + startCropHeight - cropData.y);
                }
                break;
            // -------------------------- Middle Handles (Solving Issue ②) --------------------------
            case 'crop-handle middle-left':
                if (isFixedRatio) {
                    const fixedRight = startCropX + startCropWidth; // Right position remains unchanged
                    let newX = Math.max(0, startCropX + dx); // Left x coordinate (drag adjustment)
                    let newWidth = fixedRight - newX; // New width = Right fixed point - New x
                    newWidth = Math.max(10, newWidth);

                    // Calculate new height based on aspect ratio
                    let newHeight = newWidth / cropData.aspectRatio;
                    // Keep vertical center unchanged (adjust y)
                    const centerY = startCropY + startCropHeight / 2;
                    let newY = centerY - newHeight / 2;

                    // Restrict within image range
                    newY = Math.max(0, newY);
                    newHeight = Math.min(newHeight, cropData.imageNaturalHeight - newY);

                    cropData.x = newX;
                    cropData.y = newY;
                    cropData.width = newWidth;
                    cropData.height = newHeight;
                } else {
                    cropData.x = Math.max(0, startCropX + dx);
                    cropData.width = Math.max(10, startCropX + startCropWidth - cropData.x);
                }
                break;

            case 'crop-handle middle-right':
                if (isFixedRatio) {
                    const fixedLeft = startCropX; // Left position remains unchanged
                    let newWidth = Math.min(cropData.imageNaturalWidth - fixedLeft, startCropWidth + dx); // Drag to adjust width
                    newWidth = Math.max(10, newWidth);

                    // Calculate new height based on aspect ratio
                    let newHeight = newWidth / cropData.aspectRatio;
                    // Keep vertical center unchanged
                    const centerY = startCropY + startCropHeight / 2;
                    let newY = centerY - newHeight / 2;

                    // Restrict within image range
                    newY = Math.max(0, newY);
                    newHeight = Math.min(newHeight, cropData.imageNaturalHeight - newY);

                    cropData.y = newY;
                    cropData.width = newWidth;
                    cropData.height = newHeight;
                } else {
                    cropData.width = Math.min(cropData.imageNaturalWidth - startCropX, startCropWidth + dx);
                }
                break;

            case 'crop-handle top-middle':
                if (isFixedRatio) {
                    const fixedBottom = startCropY + startCropHeight; // Bottom position remains unchanged
                    let newY = Math.max(0, startCropY + dy); // Top y coordinate (drag adjustment)
                    let newHeight = fixedBottom - newY; // New height = Bottom fixed point - New y
                    newHeight = Math.max(10, newHeight);

                    // Calculate new width based on aspect ratio
                    let newWidth = newHeight * cropData.aspectRatio;
                    // Keep horizontal center unchanged
                    const centerX = startCropX + startCropWidth / 2;
                    let newX = centerX - newWidth / 2;

                    // Restrict within image range
                    newX = Math.max(0, newX);
                    newWidth = Math.min(newWidth, cropData.imageNaturalWidth - newX);

                    cropData.x = newX;
                    cropData.y = newY;
                    cropData.width = newWidth;
                    cropData.height = newHeight;
                } else {
                    cropData.y = Math.max(0, startCropY + dy);
                    cropData.height = Math.max(10, startCropY + startCropHeight - cropData.y);
                }
                break;

            case 'crop-handle bottom-middle':
                if (isFixedRatio) {
                    const fixedTop = startCropY; // Top position remains unchanged
                    let newHeight = Math.min(cropData.imageNaturalHeight - fixedTop, startCropHeight + dy); // Drag to adjust height
                    newHeight = Math.max(10, newHeight);

                    // Calculate new width based on aspect ratio
                    let newWidth = newHeight * cropData.aspectRatio;
                    // Keep horizontal center unchanged
                    const centerX = startCropX + startCropWidth / 2;
                    let newX = centerX - newWidth / 2;

                    // Restrict within image range
                    newX = Math.max(0, newX);
                    newWidth = Math.min(newWidth, cropData.imageNaturalWidth - newX);

                    cropData.x = newX;
                    cropData.width = newWidth;
                    cropData.height = newHeight;
                } else {
                    cropData.height = Math.min(cropData.imageNaturalHeight - startCropY, startCropHeight + dy);
                }
                break;
        }

        // Ratio validation: Only execute when not touching top/bottom edges (avoid breaking lock)
        if (isFixedRatio && !isHitTopOrBottomEdge) {
            const targetHeight = cropData.width / cropData.aspectRatio;
            if (Math.abs(cropData.height - targetHeight) > 0.5) {
                cropData.height = targetHeight;
                if (['top-left', 'top-right', 'top-middle'].includes(resizeHandle.className.split(' ')[1])) {
                    cropData.y = Math.min(cropData.y, cropData.imageNaturalHeight - cropData.height);
                }
            }
        }

        // Boundary constraints
        constrainCropPosition();
        // Update UI
        updateCropSelection();
        updateCropSizeInputs();
        updateCropPositionInputs();
    }

    // Limit crop position within image bounds
    function constrainCropPosition() {
        // Ensure crop box top-left corner is within image bounds
        cropData.x = Math.max(0, cropData.x);
        cropData.y = Math.max(0, cropData.y);
        
        // Ensure crop box bottom-right corner is within image bounds
        cropData.x = Math.min(cropData.x, cropData.imageNaturalWidth - cropData.width);
        cropData.y = Math.min(cropData.y, cropData.imageNaturalHeight - cropData.height);
    }

    // Limit crop size not to exceed image
    function constrainCropSize() {
        // Ensure crop box size is within reasonable range
        cropData.width = Math.max(20, cropData.width);
        cropData.height = Math.max(20, cropData.height);
        
        // Ensure crop box doesn't exceed image boundaries
        cropData.width = Math.min(cropData.width, cropData.imageNaturalWidth);
        cropData.height = Math.min(cropData.height, cropData.imageNaturalHeight);
        
        // Ensure crop box bottom-right corner doesn't exceed image range
        cropData.width = Math.min(cropData.width, cropData.imageNaturalWidth - cropData.x);
        cropData.height = Math.min(cropData.height, cropData.imageNaturalHeight - cropData.y);
        
        // Recheck position to ensure crop box is completely within image bounds
        constrainCropPosition();
    }

    // Update custom ratio
    function updateCustomRatio() {
        const x = parseInt(cropElements.customRatioX.value) || 1;
        const y = parseInt(cropElements.customRatioY.value) || 1;
        if (x > 0 && y > 0) {
            cropData.aspectRatio = x / y;
            resetCropSelection();
        }
    }

    // Update crop selection area display
    function updateCropSelection() {
        // Calculate image offset in container (center display)
        const containerWidth = 540;
        const containerHeight = 610;
        const imageDisplayWidth = cropData.imageNaturalWidth * cropData.scale;
        const imageDisplayHeight = cropData.imageNaturalHeight * cropData.scale;
        const offsetX = (containerWidth - imageDisplayWidth) / 2;
        const offsetY = (containerHeight - imageDisplayHeight) / 2;

        // Apply offset
        cropElements.cropSelection.style.left = `${cropData.x * cropData.scale + offsetX}px`;
        cropElements.cropSelection.style.top = `${cropData.y * cropData.scale + offsetY}px`;
        cropElements.cropSelection.style.width = `${cropData.width * cropData.scale}px`;
        cropElements.cropSelection.style.height = `${cropData.height * cropData.scale}px`;
    }

    // Update crop size input boxes
    function updateCropSizeInputs() {
        cropElements.cropWidth.value = Math.round(cropData.width);
        cropElements.cropHeight.value = Math.round(cropData.height);
    }

    // Update crop position input boxes
    function updateCropPositionInputs() {
        cropElements.cropPositionX.value = Math.round(cropData.x);
        cropElements.cropPositionY.value = Math.round(cropData.y);
    }

    // Reset crop selection
    function resetCropSelection() {
        // Default crop area is the middle half of the image
        if (cropData.aspectRatio && !isNaN(cropData.aspectRatio)) {
            // Calculate by Ratio
            if (cropData.aspectRatio > cropData.imageNaturalWidth / cropData.imageNaturalHeight) {
                // Wide image
                cropData.width = cropData.imageNaturalWidth / 2;
                cropData.height = cropData.width / cropData.aspectRatio;
            } else {
                // Tall image
                cropData.height = cropData.imageNaturalHeight / 2;
                cropData.width = cropData.height * cropData.aspectRatio;
            }
        } else {
            // Free ratio
            cropData.width = cropData.imageNaturalWidth / 2;
            cropData.height = cropData.imageNaturalHeight / 2;
        }

        // Center display
        cropData.x = (cropData.imageNaturalWidth - cropData.width) / 2;
        cropData.y = (cropData.imageNaturalHeight - cropData.height) / 2;

        // Ensure Crop Box is Within Image Range
        constrainCropSize();
        constrainCropPosition();

        // Save crop state to current image
        if (currentCropImageIndex !== -1 && currentCropImageIndex < uploadedImages.length) {
            const imageInfo = uploadedImages[currentCropImageIndex];
            imageInfo.cropData.x = cropData.x;
            imageInfo.cropData.y = cropData.y;
            imageInfo.cropData.width = cropData.width;
            imageInfo.cropData.height = cropData.height;
            imageInfo.cropData.aspectRatio = cropData.aspectRatio;
            imageInfo.cropData.scale = cropData.scale;
        }

        // Update UI
        updateCropSelection();
        updateCropSizeInputs();
        updateCropPositionInputs();
    }

    // Open crop modal
    function openCropModal(index) {
        if (index < 0 || index >= uploadedImages.length) return;

        currentCropImageIndex = index;
        const imageInfo = uploadedImages[index];

        // Load crop data from image's independent state
        cropData.x = imageInfo.cropData.x;
        cropData.y = imageInfo.cropData.y;
        cropData.width = imageInfo.cropData.width;
        cropData.height = imageInfo.cropData.height;
        cropData.aspectRatio = imageInfo.cropData.aspectRatio;
        cropData.scale = imageInfo.cropData.scale;

        // Control navigation button display
        if (uploadedImages.length <= 1) {
            cropElements.cropModalNavigation.style.display = 'none';
        } else {
            cropElements.cropModalNavigation.style.display = 'flex';
        }

        // Load original image
        originalCropImage = new Image();
        originalCropImage.src = imageInfo.src;

        originalCropImage.onload = () => {
            // Set crop image source
            cropElements.cropImage.src = imageInfo.src;
            cropData.imageNaturalWidth = originalCropImage.naturalWidth;
            cropData.imageNaturalHeight = originalCropImage.naturalHeight;

            // Calculate image scaling ratio - Ensure image fills entire container
            const containerWidth = 540;
            const containerHeight = 610;
            const imageRatio = cropData.imageNaturalWidth / cropData.imageNaturalHeight;
            const containerRatio = containerWidth / containerHeight;

            if (imageRatio > containerRatio) {
                // Image is wider, scale by width to fill container
                cropData.scale = containerWidth / cropData.imageNaturalWidth;
            } else {
                // Image is taller, scale by height to fill container
                cropData.scale = containerHeight / cropData.imageNaturalHeight;
            }
            
            // Ensure image always fills entire container regardless of original size
            // Remove scaling ratio limits, allow image to be enlarged or reduced
            
            // Apply scaling ratio to image, combined with centering effect
            cropElements.cropImage.style.transform = `translate(-50%, -50%) scale(${cropData.scale})`;

            // Set default crop area
            cropElements.aspectRatioSelect.value = 'free';
            cropElements.customRatioGroup.style.display = 'none';
            resetCropSelection();

            // Update URL for crop functionality
            updateUrlForCrop();

            // Show crop window
            cropElements.cropModal.classList.add('show');
        };
    }

    // Apply crop
    function applyCrop() {
        if (currentCropImageIndex === -1 || !originalCropImage) return;

        // Create canvas for cropping
        const canvas = document.createElement('canvas');
        const ctx = canvas.getContext('2d');

        // Set canvas size
        canvas.width = cropData.width;
        canvas.height = cropData.height;

        // Draw crop area
        ctx.drawImage(
            originalCropImage,
            cropData.x, cropData.y, cropData.width, cropData.height,
            0, 0, canvas.width, canvas.height
        );

        // Convert cropped image to dataURL
        const dataUrl = canvas.toDataURL('image/png', 1.0);

        // Update image data
        const img = new Image();
        img.onload = () => {
            // Save current crop state to image's independent state
            uploadedImages[currentCropImageIndex] = {
                ...uploadedImages[currentCropImageIndex],
                src: dataUrl,
                originalWidth: img.width,
                originalHeight: img.height,
                aspectRatio: img.width / img.height,
                // Save Crop State
                cropData: {
                    x: 0,
                    y: 0,
                    width: img.width,
                    height: img.height,
                    aspectRatio: null,
                    scale: 1
                },
                // Reset rotation flip state
                rotateFlipData: {
                    rotation: 0,
                    flipX: false,
                    flipY: false
                }
            };

            // Update input boxes with cropped dimensions
            elements.widthInputDim.value = img.width;
            elements.heightInputDim.value = img.height;
            elements.widthInputSocial.value = img.width;
            elements.heightInputSocial.value = img.height;
            
            // Update current pixel dimensions
            currentPixelWidth = img.width;
            currentPixelHeight = img.height;

            // Update display
            renderImages();

            // Close crop window
            cropElements.cropModal.classList.remove('show');
        };
        img.src = dataUrl;
    }

    // Set rotation and flip functionality
    function setupRotateFlipFunctionality() {
        setupCropFunctionality(); // Initialize crop functionality
        // Close rotation and flip window
        elements.closeRotateFlipBtn.addEventListener('click', () => {
            elements.rotateFlipModal.classList.remove('show');
        });
        
        // Previous/next image navigation
        elements.prevImageRotateBtn.addEventListener('click', () => {
            if (uploadedImages.length <= 1) return;
            
            currentRotateFlipImageIndex = (currentRotateFlipImageIndex - 1 + uploadedImages.length) % uploadedImages.length;
            openRotateFlipModal(currentRotateFlipImageIndex);
        });
        
        elements.nextImageRotateBtn.addEventListener('click', () => {
            if (uploadedImages.length <= 1) return;
            
            currentRotateFlipImageIndex = (currentRotateFlipImageIndex + 1) % uploadedImages.length;
            openRotateFlipModal(currentRotateFlipImageIndex);
        });
        
        // Rotate clockwise
        elements.rotateClockwiseBtn.addEventListener('click', () => {
            rotateFlipData.rotation = (rotateFlipData.rotation + 90) % 360;
            updateRotateFlipPreview();
            updateUrlForRotateClockwise();
        });
        
        // Rotate counter clockwise
        elements.rotateCounterclockwiseBtn.addEventListener('click', () => {
            rotateFlipData.rotation = (rotateFlipData.rotation - 90 + 360) % 360;
            updateRotateFlipPreview();
            updateUrlForRotateCounterClockwise();
        });
        
        // Horizontal flip
        elements.flipHorizontalBtn.addEventListener('click', () => {
            rotateFlipData.flipX = !rotateFlipData.flipX;
            updateRotateFlipPreview();
            updateUrlForFlipHorizontal();
        });
        
        // Vertical flip
        elements.flipVerticalBtn.addEventListener('click', () => {
            rotateFlipData.flipY = !rotateFlipData.flipY;
            updateRotateFlipPreview();
            updateUrlForFlipVertical();
        });
        
        // Apply rotation and flip
        elements.applyRotateFlipBtn.addEventListener('click', () => {
            applyRotateFlip();
        });
        
        // Reset rotation and flip
        elements.resetRotateFlipBtn.addEventListener('click', () => {
            resetRotateFlip();
        });
    }

    // Open rotation and flip window
    function openRotateFlipModal(index) {
        if (index < 0 || index >= uploadedImages.length) return;
        
        currentRotateFlipImageIndex = index;
        const imageInfo = uploadedImages[index];
        
        // Load rotation flip data from image's independent state
        rotateFlipData.rotation = imageInfo.rotateFlipData.rotation;
        rotateFlipData.flipX = imageInfo.rotateFlipData.flipX;
        rotateFlipData.flipY = imageInfo.rotateFlipData.flipY;
        
        // Control navigation button display
        if (uploadedImages.length <= 1) {
            elements.rotateFlipNavigation.style.display = 'none';
        } else {
            elements.rotateFlipNavigation.style.display = 'flex';
        }
        
        // Load original image
        originalRotateFlipImage = new Image();
        originalRotateFlipImage.src = imageInfo.src;
        
        originalRotateFlipImage.onload = () => {
            // Set Rotation and Flip Image Source
            elements.rotateFlipImage.src = imageInfo.src;
            
            // Apply current rotation and flip state
            updateRotateFlipPreview();

            // Show rotation and flip window
            elements.rotateFlipModal.classList.add('show');
        };
    }

    // Reset rotation and flip
    function resetRotateFlip() {
        rotateFlipData = {
            rotation: 0,
            flipX: false,
            flipY: false
        };
        
        if (elements.rotateFlipImage) {
            elements.rotateFlipImage.style.transform = 'none';
        }
    }

    // Update Rotation and Flip Preview
    function updateRotateFlipPreview() {
        if (!originalRotateFlipImage) return;
        
        // Apply rotation and flip transformation
        let transform = `rotate(${rotateFlipData.rotation}deg)`;
        if (rotateFlipData.flipX) {
            transform += ' scaleX(-1)';
        }
        if (rotateFlipData.flipY) {
            transform += ' scaleY(-1)';
        }
        
        elements.rotateFlipImage.style.transform = transform;
    }

    // Apply rotation and flip
    function applyRotateFlip() {
        if (currentRotateFlipImageIndex === -1 || !originalRotateFlipImage) return;
        
        // Create canvas for rotation and flip
        const canvas = document.createElement('canvas');
        const ctx = canvas.getContext('2d');
        
        // Adjust canvas size based on rotation angle
        let canvasWidth, canvasHeight;
        if (rotateFlipData.rotation === 90 || rotateFlipData.rotation === 270) {
            canvasWidth = originalRotateFlipImage.height;
            canvasHeight = originalRotateFlipImage.width;
        } else {
            canvasWidth = originalRotateFlipImage.width;
            canvasHeight = originalRotateFlipImage.height;
        }
        
        canvas.width = canvasWidth;
        canvas.height = canvasHeight;
        
        // Move origin to canvas center
        ctx.translate(canvasWidth / 2, canvasHeight / 2);
        
        // Apply Rotation
        ctx.rotate(rotateFlipData.rotation * Math.PI / 180);
        
        // Apply flip
        if (rotateFlipData.flipX) {
            ctx.scale(-1, 1);
        }
        if (rotateFlipData.flipY) {
            ctx.scale(1, -1);
        }
        
        // Draw Image
        ctx.drawImage(
            originalRotateFlipImage,
            -originalRotateFlipImage.width / 2,
            -originalRotateFlipImage.height / 2
        );
        
        // Convert rotated and flipped image to dataURL
        const dataUrl = canvas.toDataURL('image/png', 1.0);
        
        // Update image data
        const img = new Image();
        img.src = dataUrl;
        img.onload = () => {
            uploadedImages[currentRotateFlipImageIndex] = {
                ...uploadedImages[currentRotateFlipImageIndex],
                src: dataUrl,
                originalWidth: img.width,
                originalHeight: img.height,
                aspectRatio: img.width / img.height,
                // Save rotation flip state
                rotateFlipData: {
                    rotation: 0,
                    flipX: false,
                    flipY: false
                },
                // Reset crop state
                cropData: {
                    x: 0,
                    y: 0,
                    width: img.width,
                    height: img.height,
                    aspectRatio: null,
                    scale: 1
                }
            };
            
            // Update input boxes with rotated dimensions
            elements.widthInputDim.value = img.width;
            elements.heightInputDim.value = img.height;
            elements.widthInputSocial.value = img.width;
            elements.heightInputSocial.value = img.height;
            
            // Update current pixel dimensions
            currentPixelWidth = img.width;
            currentPixelHeight = img.height;
            
            // Update display
            renderImages();
            
            // Close rotation and flip window
            elements.rotateFlipModal.classList.remove('show');
        };
    }




    // Render all images
    function renderImages() {
        elements.imageContainer.innerHTML = '';
        // Reverse array to ensure newly uploaded images appear first
        [...uploadedImages].reverse().forEach((image, reversedIndex) => {
            // Calculate index in original array
            const originalIndex = uploadedImages.length - 1 - reversedIndex;
            addImageToGallery(image, originalIndex);
        });
        updateImageDimensions();
    }

    // Set percentage slider and input box linkage
    function setupPercentageSync() {
        // Update input box when slider changes
        elements.percentageSlider.addEventListener('input', () => {
            const value = elements.percentageSlider.value;
            elements.percentageDisplay.textContent = `${value}%`;
            // Prevent circular triggering
            if (parseInt(elements.percentageInput.value) !== parseInt(value)) {
                elements.percentageInput.value = value;
            }
            updateImageDimensions();
        });

        // Update slider when input box changes
        elements.percentageInput.addEventListener('input', () => {
            let value = parseInt(elements.percentageInput.value);
            // Limit to 10-300 range
            if (isNaN(value)) value = 100;
            if (value < 10) value = 10;
            if (value > 300) value = 300;
            
            elements.percentageInput.value = value;
            elements.percentageDisplay.textContent = `${value}%`;
            
            // Prevent circular triggering
            if (elements.percentageSlider.value !== value.toString()) {
                elements.percentageSlider.value = value;
            }
            updateImageDimensions();
        });

        // Ensure value is within valid range when input box loses focus
        elements.percentageInput.addEventListener('blur', () => {
            let value = parseInt(elements.percentageInput.value);
            if (isNaN(value) || value < 10 || value > 300) {
                value = 100;
                elements.percentageInput.value = value;
                elements.percentageSlider.value = value;
                elements.percentageDisplay.textContent = `${value}%`;
            }
            updateImageDimensions();
        });
    }

    // Handle file upload
    function handleFileUpload(e) {
        const files = e.target.files;
        if (files.length) {
            handleFiles(files);
            // Reset file input to allow re-uploading the same file
            e.target.value = '';
        }
    }

    // Handle files
    function handleFiles(files) {
        // Hide upload prompt, show image container
        elements.uploadPrompt.style.display = 'none';
        elements.imageContainer.style.display = 'flex';
        
        for (let file of files) {
            if (file.type.startsWith('image/')) {
                const reader = new FileReader();
                reader.onload = (e) => {
                    const img = new Image();
                    img.src = e.target.result;
                    img.onload = () => {
                        // Store original image information and independent crop and rotation flip state
                        const imageInfo = {
                            src: img.src,
                            name: file.name,
                            originalWidth: img.width,
                            originalHeight: img.height,
                            file: file,
                            aspectRatio: img.width / img.height, // Store original aspect ratio
                            // Independent crop state for each image
                            cropData: {
                                x: 0,
                                y: 0,
                                width: img.width / 2, // Default to half of image
                                height: img.height / 2,
                                aspectRatio: null,
                                scale: 1
                            },
                            // Independent rotation flip state for each image
                            rotateFlipData: {
                                rotation: 0,
                                flipX: false,
                                flipY: false
                            }
                        };
                        uploadedImages.push(imageInfo);
                        
                        // If first image, auto-fill dimensions
                        if (uploadedImages.length === 1) {
                            currentPixelWidth = img.width;
                            currentPixelHeight = img.height;
                            originalAspectRatio = img.width / img.height;
                            updateDimensionInputsWithFirstImage();
                        }
                        
                        renderImages();
                    };
                };
                reader.readAsDataURL(file);
            }
        }
    }

    // Update input boxes using first image's dimensions
    function updateDimensionInputsWithFirstImage() {
        if (uploadedImages.length === 0) return;
        
        const firstImage = uploadedImages[0];
        
        // Update dimensions tab
        elements.widthInputDim.value = firstImage.originalWidth;
        elements.heightInputDim.value = firstImage.originalHeight;
        
        // Update social media tab
        if (elements.socialPlatformSelect.value === "") {
            elements.widthInputSocial.value = firstImage.originalWidth;
            elements.heightInputSocial.value = firstImage.originalHeight;
        }
    }

    // Add image to gallery
    function addImageToGallery(image, index) {
        const imageItem = document.createElement('div');
        imageItem.className = 'image-item';
        imageItem.dataset.index = index;

        // Image preview container
        const previewContainer = document.createElement('div');
        previewContainer.className = 'image-preview-container';
        
        const imgElement = document.createElement('img');
        imgElement.src = image.src;
        imgElement.alt = image.name;
        
        previewContainer.appendChild(imgElement);

        // Image operation buttons
        const actionsContainer = document.createElement('div');
        actionsContainer.className = 'image-actions';
        
        // Rotate button
        const rotateBtn = document.createElement('button');
        rotateBtn.className = 'image-action-btn rotate-btn';
        rotateBtn.innerHTML = '<i class="fas fa-rotate-right"></i>';
        rotateBtn.title = 'Rotate and Flip';
        rotateBtn.addEventListener('click', () => {
            openRotateFlipModal(index);
        });
        // Add mouse hover event
        rotateBtn.addEventListener('mouseover', (e) => {
            // Create tooltip element
            let tooltip = document.createElement('div');
            tooltip.className = 'custom-tooltip';
            tooltip.textContent = 'Rotate and Flip Image';
            tooltip.style.position = 'absolute';
            tooltip.style.backgroundColor = 'rgba(0, 0, 0, 0.9)';
            tooltip.style.color = 'white';
            tooltip.style.padding = '8px 15px';
            tooltip.style.borderRadius = '3px';
            tooltip.style.fontSize = '14px';
            tooltip.style.height = '56px';
            tooltip.style.display = 'flex';
            tooltip.style.alignItems = 'center';
            tooltip.style.zIndex = '1000';
            tooltip.style.top = `${e.clientY + 10}px`;
            tooltip.style.left = `${e.clientX + 10}px`;
            document.body.appendChild(tooltip);
            // Store tooltip reference
            rotateBtn.tooltip = tooltip;
        });
        // Add mouse out event
        rotateBtn.addEventListener('mouseout', () => {
            if (rotateBtn.tooltip) {
                document.body.removeChild(rotateBtn.tooltip);
                rotateBtn.tooltip = null;
            }
        });
        
        // Info button
        const infoBtn = document.createElement('button');
        infoBtn.className = 'image-action-btn info-btn';
        infoBtn.innerHTML = '<i class="fas fa-info"></i>';
        infoBtn.title = 'Info';
        infoBtn.addEventListener('click', () => {
            // Calculate file size
            const fileSize = image.file.size;
            let sizeText;
            if (fileSize < 1024) {
                sizeText = `${fileSize} B`;
            } else if (fileSize < 1024 * 1024) {
                sizeText = `${(fileSize / 1024).toFixed(2)} KB`;
            } else {
                sizeText = `${(fileSize / (1024 * 1024)).toFixed(2)} MB`;
            }
            alert(`${image.name}\nOriginal Size: ${image.originalWidth} x ${image.originalHeight} px\nFile Size: ${sizeText}`);
        });
        // Add mouse hover event
        infoBtn.addEventListener('mouseover', (e) => {
            // Calculate file size
            const fileSize = image.file.size;
            let sizeText;
            if (fileSize < 1024) {
                sizeText = `${fileSize} B`;
            } else if (fileSize < 1024 * 1024) {
                sizeText = `${(fileSize / 1024).toFixed(2)} KB`;
            } else {
                sizeText = `${(fileSize / (1024 * 1024)).toFixed(2)} MB`;
            }
            // Create tooltip element
            let tooltip = document.createElement('div');
            tooltip.className = 'custom-tooltip';
            tooltip.innerHTML = `${image.name}<br>Original Size: ${image.originalWidth} x ${image.originalHeight} px<br>File Size: ${sizeText}`;
            tooltip.style.position = 'absolute';
            tooltip.style.backgroundColor = 'rgba(0, 0, 0, 0.9)';
            tooltip.style.color = 'white';
            tooltip.style.padding = '8px 15px';
            tooltip.style.borderRadius = '3px';
            tooltip.style.fontSize = '14px';
            tooltip.style.zIndex = '1000';
            tooltip.style.top = `${e.clientY + 10}px`;
            tooltip.style.left = `${e.clientX + 10}px`;
            tooltip.style.whiteSpace = 'pre-line';
            document.body.appendChild(tooltip);
            // Store tooltip reference
            infoBtn.tooltip = tooltip;
        });
        // Add mouse out event
        infoBtn.addEventListener('mouseout', () => {
            if (infoBtn.tooltip) {
                document.body.removeChild(infoBtn.tooltip);
                infoBtn.tooltip = null;
            }
        });
        
        // Crop button
        const cropBtn = document.createElement('button');
        cropBtn.className = 'image-action-btn crop-btn';
        cropBtn.innerHTML = '<i class="fas fa-crop"></i>';
        cropBtn.title = 'Crop Image';
        cropBtn.addEventListener('click', () => {
            openCropModal(index);
        });
        // Add mouse hover event
        cropBtn.addEventListener('mouseover', (e) => {
            // Create tooltip element
            let tooltip = document.createElement('div');
            tooltip.className = 'custom-tooltip';
            tooltip.textContent = 'Crop Image';
            tooltip.style.position = 'absolute';
            tooltip.style.backgroundColor = 'rgba(0, 0, 0, 0.9)';
            tooltip.style.color = 'white';
            tooltip.style.padding = '8px 15px';
            tooltip.style.borderRadius = '3px';
            tooltip.style.fontSize = '14px';
            tooltip.style.height = '56px';
            tooltip.style.display = 'flex';
            tooltip.style.alignItems = 'center';
            tooltip.style.zIndex = '1000';
            tooltip.style.top = `${e.clientY + 10}px`;
            tooltip.style.left = `${e.clientX + 10}px`;
            document.body.appendChild(tooltip);
            // Store tooltip reference
            cropBtn.tooltip = tooltip;
        });
        // Add mouse out event
        cropBtn.addEventListener('mouseout', () => {
            if (cropBtn.tooltip) {
                document.body.removeChild(cropBtn.tooltip);
                cropBtn.tooltip = null;
            }
        });
        
        // Delete button
        const deleteBtn = document.createElement('button');
        deleteBtn.className = 'image-action-btn delete-img-btn';
        deleteBtn.innerHTML = '<i class="fas fa-trash"></i>';
        deleteBtn.title = 'Delete Image';
        deleteBtn.addEventListener('click', () => {
            imageToDelete = index;
            elements.deleteImageModal.classList.add('show');
        });
        // Add mouse hover event
        deleteBtn.addEventListener('mouseover', (e) => {
            // Create tooltip element
            let tooltip = document.createElement('div');
            tooltip.className = 'custom-tooltip';
            tooltip.textContent = 'Delete Image';
            tooltip.style.position = 'absolute';
            tooltip.style.backgroundColor = 'rgba(0, 0, 0, 0.9)';
            tooltip.style.color = 'white';
            tooltip.style.padding = '8px 15px';
            tooltip.style.borderRadius = '3px';
            tooltip.style.fontSize = '14px';
            tooltip.style.height = '56px';
            tooltip.style.display = 'flex';
            tooltip.style.alignItems = 'center';
            tooltip.style.zIndex = '1000';
            tooltip.style.top = `${e.clientY + 10}px`;
            tooltip.style.left = `${e.clientX + 10}px`;
            document.body.appendChild(tooltip);
            // Store tooltip reference
            deleteBtn.tooltip = tooltip;
        });
        // Add mouse out event
        deleteBtn.addEventListener('mouseout', () => {
            if (deleteBtn.tooltip) {
                document.body.removeChild(deleteBtn.tooltip);
                deleteBtn.tooltip = null;
            }
        });
        
        actionsContainer.appendChild(rotateBtn);
        actionsContainer.appendChild(cropBtn);
        actionsContainer.appendChild(infoBtn);
        actionsContainer.appendChild(deleteBtn);

        // Image info
        const imageInfo = document.createElement('div');
        imageInfo.className = 'image-info';
        
        // Truncate image name to 15 characters, add ellipsis and keep file extension
        const originalName = image.name;
        const nameParts = originalName.split('.');
        const extension = nameParts.length > 1 ? nameParts.pop() : '';
        const baseName = nameParts.join('.');
        let truncatedName = baseName;
        if (baseName.length > 15) {
            truncatedName = baseName.substring(0, 15) + '...';
        }
        const displayName = extension ? `${truncatedName}.${extension}` : truncatedName;
        
        const imageName = document.createElement('div');
        imageName.className = 'image-name';
        imageName.textContent = displayName;
        
        imageInfo.appendChild(imageName);

        // Image metadata container with size and dimensions
        const imageMeta = document.createElement('div');
        imageMeta.className = 'image-meta';
        imageMeta.style.display = 'flex';
        imageMeta.style.justifyContent = 'space-between';
        imageMeta.style.alignItems = 'center';
        
        // Calculate file size
        const fileSize = image.file.size;
        let sizeText;
        if (fileSize < 1024) {
            sizeText = `${fileSize} B`;
        } else if (fileSize < 1024 * 1024) {
            sizeText = `${(fileSize / 1024).toFixed(2)} KB`;
        } else {
            sizeText = `${(fileSize / (1024 * 1024)).toFixed(2)} MB`;
        }
        
        // File size (left aligned)
        const fileSizeElement = document.createElement('span');
        fileSizeElement.style.textAlign = 'left';
        fileSizeElement.textContent = sizeText;
        
        // Image dimensions (right aligned)
        const imageSize = document.createElement('span');
        imageSize.style.textAlign = 'right';
        // Display the resized dimensions instead of original dimensions
        imageSize.textContent = `${currentPixelWidth} × ${currentPixelHeight} px`;
        
        imageMeta.appendChild(fileSizeElement);
        imageMeta.appendChild(imageSize);

        imageItem.appendChild(previewContainer);
        imageItem.appendChild(actionsContainer);
        imageItem.appendChild(imageInfo);
        imageItem.appendChild(imageMeta);

        elements.imageContainer.appendChild(imageItem);
    }

    // Sync all dimension inputs based on current pixel dimensions
    function syncAllDimensions() {
        if (uploadedImages.length === 0) return;
        
        const baseImage = uploadedImages[0];
        const percentage = (currentPixelWidth / baseImage.originalWidth) * 100;
        
        // Update dimensions tab
        if (parseInt(elements.widthInputDim.value) !== currentPixelWidth) {
            elements.widthInputDim.value = currentPixelWidth;
        }
        if (parseInt(elements.heightInputDim.value) !== currentPixelHeight) {
            elements.heightInputDim.value = currentPixelHeight;
        }
        
        // Update percentage tab
        const percentageValue = Math.round(percentage);
        if (parseInt(elements.percentageInput.value) !== percentageValue) {
            elements.percentageInput.value = percentageValue;
        }
        if (parseInt(elements.percentageSlider.value) !== percentageValue) {
            elements.percentageSlider.value = percentageValue;
        }
        elements.percentageDisplay.textContent = `${percentageValue}%`;
        
        // Update social media tab if no specific preset is selected
        if (!currentSocialPreset) {
            if (parseInt(elements.widthInputSocial.value) !== currentPixelWidth) {
                elements.widthInputSocial.value = currentPixelWidth;
            }
            if (parseInt(elements.heightInputSocial.value) !== currentPixelHeight) {
                elements.heightInputSocial.value = currentPixelHeight;
            }
        }
    }
    
    // Update image dimensions and sync across all tabs
    function updateImageDimensions() {
        // Update current pixel dimensions based on current tab
        if (currentTab === 'dimensions') {
            // Update by dimensions tab
            const widthValue = parseFloat(elements.widthInputDim.value);
            const heightValue = parseFloat(elements.heightInputDim.value);
            
            if (!isNaN(widthValue) && !isNaN(heightValue) && widthValue > 0 && heightValue > 0) {
                currentPixelWidth = widthValue;
                currentPixelHeight = heightValue;
            }
        } else if (currentTab === 'percentage') {
            // Update percentage tab
            const percentageValue = parseFloat(elements.percentageInput.value);
            
            if (!isNaN(percentageValue) && uploadedImages.length > 0) {
                const baseImage = uploadedImages[0];
                const percentage = percentageValue / 100;
                
                currentPixelWidth = Math.round(baseImage.originalWidth * percentage);
                currentPixelHeight = Math.round(baseImage.originalHeight * percentage);
            }
        } else if (currentTab === 'social') {
            // Update social media tab
            const widthValue = parseFloat(elements.widthInputSocial.value);
            const heightValue = parseFloat(elements.heightInputSocial.value);
            
            if (!isNaN(widthValue) && !isNaN(heightValue) && widthValue > 0 && heightValue > 0) {
                currentPixelWidth = widthValue;
                currentPixelHeight = heightValue;
            }
        }
        
        // Sync all dimensions after updating current pixel dimensions
        syncAllDimensions();
        
        // Update image size display in gallery
        updateImageSizeDisplays();
    }
    
    // Update image size displays in gallery
    function updateImageSizeDisplays() {
        if (uploadedImages.length === 0) return;
        
        // Get all image size elements in the gallery
        const imageSizeElements = document.querySelectorAll('.image-meta span:nth-child(2)');
        imageSizeElements.forEach((element) => {
            element.textContent = `${currentPixelWidth} × ${currentPixelHeight} px`;
        });
    }

    // Set color picker functionality
    function setupColorPicker(colorPickerId, colorCodeId) {
        const colorPicker = document.getElementById(colorPickerId);
        const colorCode = document.getElementById(colorCodeId);
        if (colorPicker && colorCode) {
            colorPicker.addEventListener('input', () => {
                colorCode.value = colorPicker.value;
            });
        }
    }

    // Set mutex relationship for background and transparency options
    function setupBackgroundTransparencyMutex(backgroundCheckboxId, transparentCheckboxId) {
        const backgroundCheckbox = document.getElementById(backgroundCheckboxId);
        const transparentCheckbox = document.getElementById(transparentCheckboxId);
        if (backgroundCheckbox && transparentCheckbox) {
            backgroundCheckbox.addEventListener('change', () => {
                if (backgroundCheckbox.checked) {
                    transparentCheckbox.checked = false;
                    updateUrlForBackgroundColor();
                }
            });
            transparentCheckbox.addEventListener('change', () => {
                if (transparentCheckbox.checked) {
                    backgroundCheckbox.checked = false;
                    updateUrlForTransparent();
                }
            });
        }
    }

    // Update URL for transparent background
    function updateUrlForTransparent() {
        updateUrlWithMode('transparent-background');
    }

    // Update URL for background color
    function updateUrlForBackgroundColor() {
        updateUrlWithMode('change-background-color');
    }

    // Set aspect ratio locking for resize by dimensions
    function setupDimensionAspectLock(widthInput, heightInput, aspectLockCheckbox, tabType) {
        // When aspect ratio is locked, automatically calculate height
        widthInput.addEventListener('input', () => {
            if (aspectLockCheckbox.checked && widthInput.value && originalAspectRatio) {
                const width = parseInt(widthInput.value);
                if (!isNaN(width)) {
                    heightInput.value = Math.round(width / originalAspectRatio);
                }
            }
            updateImageDimensions();
        });
        
        // When aspect ratio is locked, automatically calculate width
        heightInput.addEventListener('input', () => {
            if (aspectLockCheckbox.checked && heightInput.value && originalAspectRatio) {
                const height = parseInt(heightInput.value);
                if (!isNaN(height)) {
                    widthInput.value = Math.round(height * originalAspectRatio);
                }
            }
            updateImageDimensions();
        });
        
        // When aspect ratio lock state changes, handle background option display
        aspectLockCheckbox.addEventListener('change', () => {
            checkLockAspectForBackground(tabType);
            updateImageDimensions();
        });
    }

    // Check aspect ratio lock state, decide whether to show background options
    function checkLockAspectForBackground(tabType) {
        let backgroundOptions, aspectLockCheckbox;
        if (tabType === 'dim') {
            backgroundOptions = elements.backgroundOptionsDim;
            aspectLockCheckbox = elements.lockAspectDimCheckbox;
        } else if (tabType === 'social') {
            backgroundOptions = elements.backgroundOptionsSocial;
            aspectLockCheckbox = elements.lockAspectSocialCheckbox;
        } else {
            // Percentage tab doesn't need background options
            return;
        }
        
        if (backgroundOptions && aspectLockCheckbox) {
            if (!aspectLockCheckbox.checked) {
                backgroundOptions.style.display = 'block';
            } else {
                backgroundOptions.style.display = 'none';
            }
        }
    }

    // Initialize application
    init();
});

// Create image with DPI information
function createImageWithDPI(dataURL, dpi, format, backgroundColor = null, shouldUseTransparent = false) {
    return new Promise((resolve) => {
        // For PNG format, we need to manually modify PNG file header to embed DPI information
        if (format === 'png') {
            // Convert dataURL to ArrayBuffer
            const byteString = atob(dataURL.split(',')[1]);
            const mimeString = dataURL.split(',')[0].split(':')[1].split(';')[0];
            const ab = new ArrayBuffer(byteString.length);
            const ia = new Uint8Array(ab);
            
            for (let i = 0; i < byteString.length; i++) {
                ia[i] = byteString.charCodeAt(i);
            }
            
            // Create a new PNG file, embed DPI information
            const modifiedPng = addPngDPIInfo(ia, dpi);
            const blob = new Blob([modifiedPng], {type: 'image/png'});
            resolve(blob);
        } else {
            // For JPEG format, we create a Canvas and set its size to affect DPI
            const img = new Image();
            img.onload = function() {
                // Calculate actual size (in inches)
                const inchWidth = img.width / 72; // Original image calculated at 72 DPI
                const inchHeight = img.height / 72;
                
                // Calculate new pixel dimensions based on target DPI
                const newWidth = Math.round(inchWidth * dpi);
                const newHeight = Math.round(inchHeight * dpi);
                
                const canvas = document.createElement('canvas');
                const ctx = canvas.getContext('2d');
                
                canvas.width = newWidth;
                canvas.height = newHeight;
                
                // Fill background only if user specified a background color
                if (backgroundColor) {
                    ctx.fillStyle = backgroundColor;
                    ctx.fillRect(0, 0, canvas.width, canvas.height);
                }
                
                // Draw image, preserve aspect ratio
                ctx.drawImage(img, 0, 0, canvas.width, canvas.height);
                
                canvas.toBlob((blob) => {
                    resolve(blob);
                }, `image/${format}`);
            };
            img.src = dataURL;
        }
    });
}

// Add PNG DPI information
function addPngDPIInfo(pngArrayBuffer, dpi) {
    // Create new array to store modified PNG
    const uint8Array = new Uint8Array(pngArrayBuffer);
    
    // Find first block position after IHDR chunk (after PNG header and IHDR chunk)
    let pos = 8 + 4 + 4 + 13 + 4; // PNG signature(8) + Length(4) + Type(4) + IHDR data(13) + CRC(4)
    
    // Find position before IDAT chunk, we'll insert pHYs chunk there
    while (pos < uint8Array.length - 8) {
        const chunkLength = (uint8Array[pos] << 24) | (uint8Array[pos + 1] << 16) | (uint8Array[pos + 2] << 8) | uint8Array[pos + 3];
        const chunkType = String.fromCharCode(uint8Array[pos + 4], uint8Array[pos + 5], uint8Array[pos + 6], uint8Array[pos + 7]);
        
        if (chunkType === 'IDAT') {
            // Found IDAT chunk, we insert pHYs chunk between IHDR and IDAT
            break;
        }
        
        pos += 8 + chunkLength + 4; // Jump to next chunk
    }
    
    // Convert DPI from dots per inch to meters unit (1 inch = 0.0254 meter)
    const dpiPerMeter = Math.round(dpi / 0.0254);
    
    // Create pHYs chunk data
    const physData = new Uint8Array(9); // 9-byte pHYs data (x=4, y=4, unit=1)
    // X direction pixel density (4 bytes)
    physData[0] = (dpiPerMeter >> 24) & 0xFF;
    physData[1] = (dpiPerMeter >> 16) & 0xFF;
    physData[2] = (dpiPerMeter >> 8) & 0xFF;
    physData[3] = dpiPerMeter & 0xFF;
    // Y direction pixel density (4 bytes)
    physData[4] = (dpiPerMeter >> 24) & 0xFF;
    physData[5] = (dpiPerMeter >> 16) & 0xFF;
    physData[6] = (dpiPerMeter >> 8) & 0xFF;
    physData[7] = dpiPerMeter & 0xFF;
    // Unit: 1 = Meter (1 byte)
    physData[8] = 1;
    
    // Calculate pHYs chunk CRC (including type and data)
    const physType = new Uint8Array([112, 72, 89, 115]); // 'pHYs'
    const crcData = new Uint8Array([...physType, ...physData]);
    const physCrc = calculateCrc32(crcData);
    
    // Build new PNG array
    const beforeChunk = uint8Array.slice(0, 33); // Until IHDR ends
    const afterChunk = uint8Array.slice(33);
    
    // Assemble new array: File header + IHDR + pHYs chunk + remaining parts
    const newPng = new Uint8Array(beforeChunk.length + 4 + 4 + 9 + 4 + afterChunk.length); // Length + Type + Data + CRC
    
    let offset = 0;
    newPng.set(beforeChunk, offset);
    offset += beforeChunk.length;
    
    // pHYs Block: Length (4 bytes)
    newPng[offset] = 0;
    newPng[offset + 1] = 0;
    newPng[offset + 2] = 0;
    newPng[offset + 3] = 9;
    offset += 4;
    
    // pHYs Type (4 bytes)
    newPng[offset] = 112; // 'p'
    newPng[offset + 1] = 72;  // 'H'
    newPng[offset + 2] = 89;  // 'Y'
    newPng[offset + 3] = 115; // 's'
    offset += 4;
    
    // pHYs Data (9 bytes)
    newPng.set(physData, offset);
    offset += 9;
    
    // CRC(4 byte)
    newPng[offset] = (physCrc >> 24) & 0xFF;
    newPng[offset + 1] = (physCrc >> 16) & 0xFF;
    newPng[offset + 2] = (physCrc >> 8) & 0xFF;
    newPng[offset + 3] = physCrc & 0xFF;
    offset += 4;
    
    // The remaining part
    newPng.set(afterChunk, offset);
    
    return newPng.buffer;
}

// Simple CRC32 implementation
function calculateCrc32(bytes) {
    // Precomputed CRC32 table
    const crcTable = [];
    for (let i = 0; i < 256; i++) {
        let c = i;
        for (let j = 0; j < 8; j++) {
            if (c & 1) {
                c = 0xEDB88320 ^ (c >>> 1);
            } else {
                c = c >>> 1;
            }
        }
        crcTable[i] = c;
    }
    
    let crc = 0xFFFFFFFF;
    for (let i = 0; i < bytes.length; i++) {
        const tableIndex = (crc ^ bytes[i]) & 0xFF;
        crc = crcTable[tableIndex] ^ (crc >>> 8);
    }
    
    return (crc ^ 0xFFFFFFFF) >>> 0;
}

// PAGE_MAP for different URL routes with titles and descriptions
const PAGE_MAP = {
    "resize-image": {
        title: "무료 온라인 이미지 리사이저 | CaliperTools",
        description: "온라인으로 무료로 이미지를 리사이즈하세요. 이미지를 자르고, 회전하고, 확대/축소하고, 조정하세요. 여러 형식, 소셜 프리셋 지원. 등록이 필요 없습니다. 최고 품질."
    },
    "resize-image-png": {
        title: "무료 온라인 PNG 리사이저 | CaliperTools",
        description: "온라인으로 무료로 PNG 이미지를 리사이즈하세요. 투명도 지원. 등록이 필요 없습니다. 최고 품질."
    },
    "resize-image-jpg": {
        title: "무료 온라인 JPG 리사이저 | CaliperTools",
        description: "온라인으로 무료로 JPG 이미지를 리사이즈하세요. 웹 최적화 압축. 등록이 필요 없습니다. 최고 품질."
    },
    "resize-image-webp": {
        title: "무료 온라인 WebP 리사이저 | CaliperTools",
        description: "온라인으로 무료로 WebP 이미지를 리사이즈하세요. 현대 형식 압축. 등록이 필요 없습니다. 최고 품질."
    },
    "resize-image-facebook": {
        title: "무료 온라인 Facebook 리사이저 | CaliperTools",
        description: "Facebook용으로 온라인으로 무료로 리사이즈하세요. 게시물 커버 광고. 등록이 필요 없습니다. 최고 품질."
    },
    "resize-image-instagram": {
        title: "무료 온라인 Instagram 리사이저 | CaliperTools",
        description: "Instagram용으로 온라인으로 무료로 리사이즈하세요. 게시물 스토리 프로필. 등록이 필요 없습니다. 최고 품질."
    },
    "resize-image-twitter": {
        title: "무료 온라인 Twitter 리사이저 | CaliperTools",
        description: "Twitter용으로 온라인으로 무료로 리사이즈하세요. 게시물 헤더 카드. 등록이 필요 없습니다. 최고 품질."
    },
    "resize-image-youtube": {
        title: "무료 온라인 YouTube 리사이저 | CaliperTools",
        description: "YouTube용으로 온라인으로 무료로 리사이즈하세요. 썸네일 채널 프로필. 등록이 필요 없습니다. 최고 품질."
    },
    "crop-image": {
        title: "무료 온라인 이미지 자르기 | CaliperTools",
        description: "온라인으로 무료로 이미지를 자르세요. 사용자 정의 가로세로비. 등록이 필요 없습니다. 최고 품질."
    },
    "rotate-clockwise": {
        title: "무료 온라인 시계 방향 회전 | CaliperTools",
        description: "온라인으로 무료로 시계 방향으로 회전하세요. 90도 회전. 등록이 필요 없습니다. 최고 품질."
    },
    "rotate-counterclockwise": {
        title: "무료 온라인 반시계 방향 회전 | CaliperTools",
        description: "온라인으로 무료로 반시계 방향으로 회전하세요. 90도 회전. 등록이 필요 없습니다. 최고 품질."
    },
    "flip-horizontal": {
        title: "무료 온라인 수평 뒤집기 | CaliperTools",
        description: "온라인으로 무료로 수평으로 뒤집으세요. 거울 효과. 등록이 필요 없습니다. 최고 품질."
    },
    "flip-vertical": {
        title: "무료 온라인 수직 뒤집기 | CaliperTools",
        description: "온라인으로 무료로 수직으로 뒤집으세요. 거울 효과. 등록이 필요 없습니다. 최고 품질."
    },
    "rotate-image": {
        title: "무료 온라인 이미지 회전 | CaliperTools",
        description: "온라인으로 무료로 이미지를 회전하세요. 시계 방향 반시계 방향 뒤집기. 등록이 필요 없습니다. 최고 품질."
    },
    "flip-image": {
        title: "무료 온라인 이미지 뒤집기 | CaliperTools",
        description: "온라인으로 무료로 이미지를 뒤집으세요. 수평 수직. 등록이 필요 없습니다. 최고 품질."
    },
    "resize-by-dimensions": {
        title: "무료 온라인 크기로 리사이즈 | CaliperTools",
        description: "크기로 온라인으로 무료로 리사이즈하세요. 너비 높이 설정. 등록이 필요 없습니다. 최고 품질."
    },
    "resize-by-percentage": {
        title: "무료 온라인 백분율로 리사이즈 | CaliperTools",
        description: "백분율로 온라인으로 무료로 리사이즈하세요. 확대 축소. 등록이 필요 없습니다. 최고 품질."
    },
    "resize-for-social-media": {
        title: "무료 온라인 소셜 미디어 리사이저 | CaliperTools",
        description: "소셜 미디어용 온라인으로 무료로 리사이즈하세요. Facebook Instagram. 등록이 필요 없습니다. 최고 품질."
    },
    "batch-resize-images": {
        title: "무료 온라인 일괄 리사이즈 | CaliperTools",
        description: "온라인으로 무료로 일괄 리사이즈하세요. 여러 이미지를 한 번에. 등록이 필요 없습니다. 최고 품질."
    },
    "compress-images": {
        title: "무료 온라인 이미지 압축 | CaliperTools",
        description: "온라인으로 무료로 이미지를 압축하세요. 파일 크기 줄이기. 등록이 필요 없습니다. 최고 품질."
    },
    "change-image-format": {
        title: "무료 온라인 형식 변경 | CaliperTools",
        description: "온라인으로 무료로 형식을 변경하세요. JPG PNG WebP. 등록이 필요 없습니다. 최고 품질."
    },
    "transparent-background": {
        title: "무료 온라인 투명 배경 | CaliperTools",
        description: "온라인으로 무료로 투명하게 만드세요. 배경색 제거. 등록이 필요 없습니다. 최고 품질."
    },
    "change-background-color": {
        title: "무료 온라인 배경색 변경 | CaliperTools",
        description: "온라인으로 무료로 배경을 변경하세요. 색상 교체. 등록이 필요 없습니다. 최고 품질."
    }
};

// Update page title and description based on slug
function updatePageConfig(slug) {
    const pageConfig = PAGE_MAP[slug] || {
        title: "무료 온라인 이미지 리사이저 | CaliperTools",
        description: "온라인으로 무료로 이미지를 리사이즈하세요. 여러 형식, 소셜 프리셋 지원. 등록이 필요 없습니다. 최고 품질."
    };
    
    document.getElementById('page-title').textContent = pageConfig.title;
    document.getElementById('page-description').setAttribute('content', pageConfig.description);
}

// Update URL based on selected tab
function updateUrlForTab(tabId) {
    const slugMap = {
        'dimensions': 'resize-by-dimensions',
        'percentage': 'resize-by-percentage',
        'social': 'resize-for-social-media'
    };
    
    const slug = slugMap[tabId];
    if (slug) {
        updateUrlWithMode(slug);
    }
}

// Update URL based on selected platform
function updateUrlForPlatform(platform) {
    if (!platform) {
        updateUrlWithMode('resize-for-social-media');
        return;
    }
    
    const slug = `resize-image-${platform}`;
    updateUrlWithMode(slug);
}

// Update URL based on selected format
function updateUrlForFormat(format) {
    if (!format || format === 'original') {
        updateUrlWithMode('resize-image');
        return;
    }
    
    const slug = `resize-image-${format}`;
    updateUrlWithMode(slug);
}

// Update URL for crop functionality
function updateUrlForCrop() {
    updateUrlWithMode('crop-image');
}

// Update URL for rotate clockwise
function updateUrlForRotateClockwise() {
    updateUrlWithMode('rotate-clockwise');
}

// Update URL for rotate counter clockwise
function updateUrlForRotateCounterClockwise() {
    updateUrlWithMode('rotate-counterclockwise');
}

// Update URL for rotate functionality (general)
function updateUrlForRotate() {
    updateUrlWithMode('rotate-image');
}

// Update URL for flip horizontal
function updateUrlForFlipHorizontal() {
    updateUrlWithMode('flip-horizontal');
}

// Update URL for flip vertical
function updateUrlForFlipVertical() {
    updateUrlWithMode('flip-vertical');
}

// Update URL for flip functionality (general)
function updateUrlForFlip() {
    updateUrlWithMode('flip-image');
}

// Update URL for transparent background
function updateUrlForTransparent() {
    const newUrl = new URL(window.location.href);
    newUrl.searchParams.set('mode', 'transparent-background');
    history.replaceState(null, '', newUrl);
    updatePageConfig('transparent-background');
}

// Update URL for background color
function updateUrlForBackgroundColor() {
    const newUrl = new URL(window.location.href);
    newUrl.searchParams.set('mode', 'change-background-color');
    history.replaceState(null, '', newUrl);
    updatePageConfig('change-background-color');
}

// Parse URL parameters and update page accordingly
// Helper function to update URL with mode using path format
function updateUrlWithMode(slug) {
    const newUrl = new URL(window.location.href);
    newUrl.search = '';
    const pathParts = newUrl.pathname.split('/');
    const resizerIndex = pathParts.findIndex(part => 
        part === 'Image-resizer' || part === 'Image-resizer.html'
    );
    if (resizerIndex !== -1) {
        // Remove .html suffix from the filename
        const basePath = pathParts.slice(0, resizerIndex).join('/') + '/Image-resizer';
        newUrl.pathname = basePath + '/' + slug;
    } else {
        // If Image-resizer not found in path, check if we're on a language-specific page
        // Handle cases like /bn/Image/Image-resizer or /Image/Image-resizer
        const imageIndex = pathParts.findIndex(part => part === 'Image');
        if (imageIndex !== -1) {
            // Construct the proper path with Image-resizer
            const basePath = pathParts.slice(0, imageIndex + 1).join('/') + '/Image-resizer';
            newUrl.pathname = basePath + '/' + slug;
        } else {
            // Fallback for root or unexpected paths
            newUrl.pathname = '/Image/Image-resizer/' + slug;
        }
    }
    history.replaceState(null, '', newUrl);
    updatePageConfig(slug);
}

function parseUrlParams() {
    // Check both path and query params, with query params taking precedence for complex cases
    let mode = null;
    const pathname = window.location.pathname;
    const pathParts = pathname.split('/');
    
    // First check query params for mode (higher priority for complex cases)
    const urlParams = new URLSearchParams(window.location.search);
    const queryMode = urlParams.get('mode');
    if (queryMode) {
        mode = queryMode;
    } else {
        // Fallback to extracting mode from path
        const lastPart = pathParts[pathParts.length - 1];
        if (lastPart && lastPart !== 'Image-resizer' && lastPart !== 'Image-resizer.html') {
            mode = lastPart;
        }
    }
    
    // Update page configuration based on mode
    if (mode && PAGE_MAP[mode]) {
        updatePageConfig(mode);
    } else {
        // Default to resize-image if no mode specified
        updatePageConfig('resize-image');
    }
    
    // Handle different modes
    if (mode) {
        // Handle format modes
        if (mode.startsWith('resize-image-')) {
            const format = mode.replace('resize-image-', '');
            if (['png', 'jpg', 'webp'].includes(format)) {
                const saveAsSelect = document.getElementById('save-as');
                if (saveAsSelect) {
                    saveAsSelect.value = format;
                }
            }
        }
        
        // Handle platform modes
        if (['resize-image-facebook', 'resize-image-instagram', 'resize-image-twitter', 'resize-image-youtube'].includes(mode)) {
            const platform = mode.replace('resize-image-', '');
            const socialPlatformSelect = document.getElementById('social-platform');
            if (socialPlatformSelect) {
                socialPlatformSelect.value = platform;
                // Trigger change event to load presets
                socialPlatformSelect.dispatchEvent(new Event('change'));
            }
        }
        
        // Handle tab modes
        if (mode === 'resize-by-dimensions') {
            const tabElement = document.querySelector('.tab[data-tab="dimensions"]');
            if (tabElement) {
                tabElement.click();
            }
        } else if (mode === 'resize-by-percentage') {
            const tabElement = document.querySelector('.tab[data-tab="percentage"]');
            if (tabElement) {
                tabElement.click();
            }
        } else if (mode === 'resize-for-social-media') {
            const tabElement = document.querySelector('.tab[data-tab="social"]');
            if (tabElement) {
                tabElement.click();
            }
        }
    }
}

// Reset to original state
function resetToOriginalState() {
    // Reset URL to original with .html suffix and no mode
    const newUrl = new URL(window.location.href);
    newUrl.search = '';
    
    const pathParts = newUrl.pathname.split('/');
    const resizerIndex = pathParts.findIndex(part => 
        part === 'Image-resizer' || part === 'Image-resizer.html'
    );
    
    if (resizerIndex !== -1) {
        // Use Image-resizer.html with .html suffix explicitly
        const basePath = pathParts.slice(0, resizerIndex).join('/');
        newUrl.pathname = basePath + '/Image-resizer.html';
    }
    
    history.replaceState(null, '', newUrl);
    
    // Reset title and description to original
    updatePageConfig('resize-image');
    
    // Reset tab to dimensions (without triggering click event)
    elements.tabs.forEach(t => t.classList.remove('active'));
    elements.tabContents.forEach(content => content.classList.remove('active'));
    
    const dimensionsTab = document.querySelector('.tab[data-tab="dimensions"]');
    const dimensionsContent = document.getElementById('dimensions');
    if (dimensionsTab) dimensionsTab.classList.add('active');
    if (dimensionsContent) dimensionsContent.classList.add('active');
    
    // Reset format to original
    const saveAsSelect = document.getElementById('save-as');
    if (saveAsSelect) {
        saveAsSelect.value = 'original';
    }
    
    // Reset platform selection
    const socialPlatformSelect = document.getElementById('social-platform');
    if (socialPlatformSelect) {
        socialPlatformSelect.value = '';
    }
    
    // Reset dimension inputs
    const widthInputDim = document.getElementById('width-dim');
    const heightInputDim = document.getElementById('height-dim');
    if (widthInputDim) widthInputDim.value = '';
    if (heightInputDim) heightInputDim.value = '';
    
    // Reset percentage slider
    const percentageSlider = document.getElementById('percentage-slider');
    const percentageInput = document.getElementById('percentage-input');
    if (percentageSlider) percentageSlider.value = 100;
    if (percentageInput) percentageInput.value = 100;
    
    // Reset background options
    const useBackgroundDim = document.getElementById('use-background-dim');
    const useTransparencyDim = document.getElementById('use-transparency-dim');
    const useBackgroundSocial = document.getElementById('use-background-social');
    const useTransparencySocial = document.getElementById('use-transparency-social');
    
    if (useBackgroundDim) useBackgroundDim.checked = false;
    if (useTransparencyDim) useTransparencyDim.checked = false;
    if (useBackgroundSocial) useBackgroundSocial.checked = false;
    if (useTransparencySocial) useTransparencySocial.checked = false;
    
    // Reset file size input
    const fileSizeInput = document.getElementById('file-size');
    if (fileSizeInput) fileSizeInput.value = '';
    
    // Reset pixel dimensions
    currentPixelWidth = 0;
    currentPixelHeight = 0;
    originalAspectRatio = 1;
}

</script>
</body>
</html>    
